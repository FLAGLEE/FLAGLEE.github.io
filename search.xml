<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习基础知识及常用科学计算库的使用</title>
      <link href="/2020/09/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机器学习是从<strong>数据</strong>中<strong>自动分析获得模型</strong>，并利用<strong>模型</strong>对未知数据进行预测。<br>机器学习研究和构建的是一种特殊算法（<strong>而非某一个特定的算法</strong>），能够让计算机自己在数据中学习从而进行预测。<br>机器学习是人工智能的一个实现途径,深度学习是机器学习的一个方法发展而来。<br>本文主要介绍机器学习基础知识及常用科学计算库(Numpy, Pandas 等)的使用</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%8C%83%E5%9B%B4.png" alt=""></p><a id="more"></a><h2 id="机器学习概念"><a href="#机器学习概念" class="headerlink" title="机器学习概念"></a>机器学习概念</h2><h3 id="机器学习定义"><a href="#机器学习定义" class="headerlink" title="机器学习定义"></a>机器学习定义</h3><p>通过训练集，不断识别特征，不断建模，最后形成有效的模型，这个过程就叫“机器学习”。</p><h3 id="机器学习基本思路"><a href="#机器学习基本思路" class="headerlink" title="机器学习基本思路"></a>机器学习基本思路</h3><ul><li>把现实生活中的问题抽象成数学模型，并且很清楚模型中不同参数的作用</li><li>利用数学方法对这个数学模型进行求解，从而解决现实生活中的问题</li><li>评估这个数学模型，是否真正的解决了现实生活中的问题，解决的如何？</li></ul><h3 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h3><p>机器学习根据训练方法大致可以分为 3 大类：</p><ul><li>监督学习</li><li>非监督学习</li><li>强化学习</li></ul><p>此外的“半监督学习”之类的说法，都是基于上面 3 类的变种，本质没有改变。</p><p><strong>监督学习</strong></p><p>监督学习是指我们给算法一个数据集，并且给定正确答案。机器通过数据来学习正确答案的计算方法。<br>这种通过大量人工打标签来帮助机器学习的方式就是监督学习。这种学习方式效果非常好，但是成本也非常高。</p><p><strong>非监督学习</strong></p><p>非监督学习中，给定的数据集没有“正确答案”，所有的数据都是一样的。无监督学习的任务是从给定的数据集中，挖掘出潜在的结构。<br>比如，通过学习，机器会把一堆猫和狗照片分为 2 类，一类都是猫的照片，一类都是狗的照片。与监督学习有着本质的差别：非监督学习中，虽然照片分为了猫和狗，但是机器并不知道哪个是猫，哪个是狗。对于机器来说，相当于分成了 A、B 两类。</p><p><strong>强化学习</strong></p><p>强化学习更接近生物学习的本质，因此有望获得更高的智能。它关注的是智能体如何在环境中采取一系列行为，从而获得最大的累积回报。通过强化学习，一个智能体应该知道在什么状态下应该采取什么行为。</p><h3 id="机器学习常见算法"><a href="#机器学习常见算法" class="headerlink" title="机器学习常见算法"></a>机器学习常见算法</h3><p><strong>决策树算法</strong><br>决策树及其变种是一类将输入空间分成不同的区域，每个区域有独立参数的算法。决策树算法充分利用了树形模型，根节点到一个叶子节点是一条分类的路径规则，每个叶子节点象征一个判断类别。先将样本分成不同的子集，再进行分割递推，直至每个子集得到同类型的样本，从根节点开始测试，到子树再到叶子节点，即可得出预测类别。此方法的特点是结构简单、处理数据效率较高。</p><p><strong>朴素贝叶斯算法</strong><br>朴素贝叶斯算法是一种分类算法。它不是单一算法，而是一系列算法，它们都有一个共同的原则，即被分类的每个特征都与任何其他特征的值无关。朴素贝叶斯分类器认为这些“特征”中的每一个都独立地贡献概率，而不管特征之间的任何相关性。然而，特征并不总是独立的，这通常被视为朴素贝叶斯算法的缺点。简而言之，朴素贝叶斯算法允许我们使用概率给出一组特征来预测一个类。与其他常见的分类方法相比，朴素贝叶斯算法需要的训练很少。在进行预测之前必须完成的唯一工作是找到特征的个体概率分布的参数，这通常可以快速且确定地完成。这意味着即使对于高维数据点或大量数据点，朴素贝叶斯分类器也可以表现良好。</p><p><strong>支持向量机算法</strong><br>基本思想可概括如下：首先，要利用一种变换将空间高维化，当然这种变换是非线性的，然后，在新的复杂空间取最优线性分类表面。由此种方式获得的分类函数在形式上类似于神经网络算法。支持向量机是统计学习领域中一个代表性算法，但它与传统方式的思维方法很不同，输入空间、提高维度从而将问题简短化，使问题归结为线性可分的经典解问题。支持向量机应用于垃圾邮件识别，人脸识别等多种分类问题。</p><p><strong>随机森林算法</strong><br>控制数据树生成的方式有多种，根据前人的经验，大多数时候更倾向选择分裂属性和剪枝，但这并不能解决所有问题，偶尔会遇到噪声或分裂属性过多的问题。基于这种情况，总结每次的结果可以得到袋外数据的估计误差，将它和测试样本的估计误差相结合可以评估组合树学习器的拟合及预测精度。此方法的优点有很多，可以产生高精度的分类器，并能够处理大量的变数，也可以平衡分类资料集之间的误差。</p><p><strong>人工神经网络算法</strong><br>人工神经网络与神经元组成的异常复杂的网络此大体相似，是个体单元互相连接而成，每个单元有数值量的输入和输出，形式可以为实数或线性组合函数。它先要以一种学习准则去学习，然后才能进行工作。当网络判断错误时，通过学习使其减少犯同样错误的可能性。此方法有很强的泛化能力和非线性映射能力，可以对信息量少的系统进行模型处理。从功能模拟角度看具有并行性，且传递信息速度极快。</p><p><strong>Boosting 与 Bagging 算法</strong><br>Boosting 是种通用的增强基础算法性能的回归分析算法。不需构造一个高精度的回归分析，只需一个粗糙的基础算法即可，再反复调整基础算法就可以得到较好的组合回归模型。它可以将弱学习算法提高为强学习算法，可以应用到其它基础回归算法，如线性回归、神经网络等，来提高精度。Bagging 和前一种算法大体相似但又略有差别，主要想法是给出已知的弱学习算法和训练集，它需要经过多轮的计算，才可以得到预测函数列，最后采用投票方式对示例进行判别。</p><p><strong>关联规则算法</strong><br>关联规则是用规则去描述两个变量或多个变量之间的关系，是客观反映数据本身性质的方法。它是机器学习的一大类任务，可分为两个阶段，先从资料集中找到高频项目组，再去研究它们的关联规则。其得到的分析结果即是对变量间规律的总结。</p><p><strong>EM（期望最大化）算法</strong><br>在进行机器学习的过程中需要用到极大似然估计等参数估计方法，在有潜在变量的情况下，通常选择 EM 算法，不是直接对函数对象进行极大估计，而是添加一些数据进行简化计算，再进行极大化模拟。它是对本身受限制或比较难直接处理的数据的极大似然估计算法。</p><p><strong>深度学习</strong><br>深度学习(DL, Deep Learning)是机器学习(ML, Machine Learning)领域中一个新的研究方向，它被引入机器学习使其更接近于最初的目标——人工智能(AI, Artificial Intelligence)。<br>深度学习是学习样本数据的内在规律和表示层次，这些学习过程中获得的信息对诸如文字，图像和声音等数据的解释有很大的帮助。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。 深度学习是一个复杂的机器学习算法，在语音和图像识别方面取得的效果，远远超过先前相关技术。<br>深度学习在搜索技术、数据挖掘、机器学习、机器翻译、自然语言处理、多媒体学习、语音、推荐和个性化技术，以及其他相关领域都取得了很多成果。深度学习使机器模仿视听和思考等人类的活动，解决了很多复杂的模式识别难题，使得人工智能相关技术取得了很大进步。</p><h3 id="人工智能、机器学习、深度学习关系"><a href="#人工智能、机器学习、深度学习关系" class="headerlink" title="人工智能、机器学习、深度学习关系"></a>人工智能、机器学习、深度学习关系</h3><p>机器学习包含了很多种不同的算法，深度学习就是其中之一，其他方法包括决策树，聚类，贝叶斯等。</p><p>深度学习的灵感来自大脑的结构和功能，即许多神经元的互连。人工神经网络（ANN）是模拟大脑生物结构的算法。</p><p>不管是机器学习还是深度学习，都属于人工智能（AI）的范畴。</p><h2 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><h3 id="Jupyter-Notebook-简介"><a href="#Jupyter-Notebook-简介" class="headerlink" title="Jupyter Notebook 简介"></a>Jupyter Notebook 简介</h3><p>Jupyter 项目是一个非盈利的开源项目，源于 2014 年的 ipython 项目，因为它逐渐发展为支持跨所有编程语言的交互式数据科学和科学计算。</p><p>实时运行的代码、叙事性的文本和可视化被整合在一起，方便使用代码和数据来讲述故事，Jupyter Notebook 相比 Pycharm 在画图和数据展示方面更有优势。</p><ul><li><p>Jupyter Notebook，原名 IPython Notbook，是 IPython 的加强网页版，一个开源 Web 应用程序</p></li><li><p>名字源自 Julia、Python 和 R（数据科学的三种开源语言）</p></li><li><p>是一款程序员和科学工作者的编程/文档/笔记/展示软件</p></li><li><p>.ipynb 文件格式是用于计算型叙述的 JSON 文档格式的正式规范</p></li><li><p>传统软件开发：工程／目标明确</p><ul><li>需求分析，设计架构，开发模块，测试</li></ul></li><li><p>数据挖掘：艺术／目标不明确</p><ul><li>目的是具体的洞察目标，而不是机械的完成任务</li><li>通过执行代码来理解问题</li><li>迭代式地改进代码来改进解决方法</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/jupyternotebook.png" alt=""></p><h3 id="Jupyter-Notebook-使用"><a href="#Jupyter-Notebook-使用" class="headerlink" title="Jupyter Notebook 使用"></a>Jupyter Notebook 使用</h3><p><strong>安装</strong></p><p>安装 Jupyter Notebook 的前提是需要安装了 Python（3.3 版本及以上，或 2.7 版本）。</p><pre><code>pip install jupyter</code></pre><p><strong>启动</strong></p><p>在终端中输入以下命令：</p><pre><code>jupyter notebook</code></pre><p>想让 notebook 打开指定目录，只要进入此目录后执行命令即可。</p><p>执行命令之后，在终端中将会显示一系列 notebook 的服务器信息，同时浏览器将会自动启动 Jupyter Notebook。</p><p>注意：之后在 Jupyter Notebook 的所有操作，都请保持终端不要关闭，因为一旦关闭终端，就会断开与本地服务器的链接，你将无法在 Jupyter Notebook 中进行其他操作啦。</p><p><strong>新建 notebook 文档</strong></p><p>notebook 的文档格式是.ipynb</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/createnotebook.png" alt=""></p><p>点击标题（如 Untitled）修改文档名</p><h3 id="Jupyter-Notebook-操作"><a href="#Jupyter-Notebook-操作" class="headerlink" title="Jupyter Notebook 操作"></a>Jupyter Notebook 操作</h3><p><strong>cell 操作</strong></p><ul><li><p>什么是 cell？</p><ul><li><p>cell：一对 In Out 会话被视作一个代码单元，称为 cell</p></li><li><p>cell 行号前的 * ，表示  代码正在运行</p></li></ul></li></ul><p>Jupyter 支持两种模式：</p><ul><li><p>编辑模式（Enter）</p><ul><li><p>命令模式下回车 Enter 或鼠标双击 cell 进入编辑模式</p></li><li><p>可以操作 cell 内文本或代码，剪切／复制／粘贴移动等操作</p></li></ul></li><li><p>命令模式（Esc）</p><ul><li><p>按 Esc 退出编辑，进入命令模式</p></li><li><p>可以操作 cell 单元本身进行剪切／复制／粘贴／移动等操作</p></li></ul></li></ul><p><strong>鼠标操作</strong></p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/%E5%B7%A5%E5%85%B7%E6%A0%8Fcell.png" alt=""></p><p><strong>快捷键操作</strong></p><ul><li><p>两种模式通用快捷键</p><ul><li>Shift+Enter，执行本单元代码，并跳转到下一单元</li><li>Ctrl+Enter，执行本单元代码，留在本单元</li></ul></li><li><p>命令模式：按 ESC 进入</p><ul><li><p>Y，cell 切换到 Code 模式</p></li><li><p>M，cell 切换到 Markdown 模式</p></li><li><p>A，在当前 cell 的上面添加 cell</p></li><li><p>B，在当前 cell 的下面添加 cell</p></li><li><p>双击 D：删除当前 cell</p></li></ul></li><li><p>编辑模式：按 Enter 进入</p><ul><li>与常规方式一样</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/Notebook%E6%93%8D%E4%BD%9C.png" alt=""></p><hr><p><a href="https://zhuanlan.zhihu.com/p/33105153" target="_blank" rel="noopener">Jupyter Notebook 介绍、安装及使用教程</a></p><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2>]]></content>
      
      
      <categories>
          
          <category> Machine Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> Numpy </tag>
            
            <tag> Pandas </tag>
            
            <tag> Jupyter Notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python项目汇总</title>
      <link href="/2020/09/14/Python%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
      <url>/2020/09/14/Python%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录汇总个人的 Python 项目</p><ul><li>外星人入侵</li></ul></blockquote><a id="more"></a><h2 id="外星人入侵"><a href="#外星人入侵" class="headerlink" title="外星人入侵"></a>外星人入侵</h2><p>本项目是在阅览《Python 编程： 从入门到实践》时敲的练手项目，在本项目中，将在游戏《外星人入侵》中添加外星人。</p><ul><li>首先，在屏幕上边缘附近添加一个外星人，然后生成一群外星人。</li><li>让这群外星人向两边和下面移动，并删除被子弹击中的外星人。</li><li>最后，将显示玩家拥有的飞船数量，并在玩家的飞船用完后结束游戏。</li></ul><p>通过本项目，将更深入地了解 Pygame 和大型项目的管理，还将学习如何检测游戏对象之间的碰撞，如子弹和外星人之间的碰撞，检测碰撞有助于你定义游戏元素之间的交互：可以将角色限定在迷宫墙壁之内或在两个角色之间传球。<br>我们将时不时地查看游戏开发计划， 以确保编程工作不偏离轨道。</p><p>本项目开源地址在<a href="https://github.com/FLAGLEE/Python_Project/tree/master/%E5%A4%96%E6%98%9F%E4%BA%BA%E5%85%A5%E4%BE%B5" target="_blank" rel="noopener">https://github.com/FLAGLEE/Python_Project/tree/master/外星人入侵</a></p><h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h3><pre><code class="python">class Settings():    &quot;&quot;&quot;存储《外星人入侵》所有设置的类&quot;&quot;&quot;    def __init__(self):        &quot;&quot;&quot;初始化游戏的静态设置&quot;&quot;&quot;        # 屏幕设置        self.screen_width = 1200        self.screen_height = 800        self.bg_color = (230, 230, 230)        # 飞船的设置        self.ship_limit = 3        # 外星人设置        # 子弹的设置        self.bullet_width = 3        self.bullet_height = 15        self.bullet_color = 60, 60, 60        self.bullets_allowed = 3        # 以什么样的速度加快游戏节奏        self.speedup_scale = 1.1        # 外星人点数的提高速度        self.score_scale = 2        self.initialize_dynamic_settings()    def initialize_dynamic_settings(self):        &quot;&quot;&quot;初始化随游戏进行而变化的设置&quot;&quot;&quot;        self.ship_speed_factor = 1.5        self.alien_speed_factor = 1        self.bullet_speed_factor = 3        self.fleet_drop_speed = 10        # fleet_direction为1表示向右移， 为-1表示向左移        self.fleet_direction = 1        # 记分        self.alien_score = 50    def increase_speed(self):        &quot;&quot;&quot;提高速度设置和外星人点数&quot;&quot;&quot;        self.ship_speed_factor *= self.speedup_scale        self.alien_speed_factor *= self.speedup_scale        self.bullet_speed_factor *= self.speedup_scale        self.fleet_drop_speed *= self.speedup_scale        self.alien_score = int(self.alien_score * self.score_scale)</code></pre><h3 id="game-stats-py"><a href="#game-stats-py" class="headerlink" title="game_stats.py"></a>game_stats.py</h3><pre><code class="python">import pygameclass GameStats():    &quot;&quot;&quot;跟踪游戏的统计信息&quot;&quot;&quot;    def __init__(self, ai_settings):        &quot;&quot;&quot;初始化统计信息&quot;&quot;&quot;        self.ai_settings = ai_settings        self.reset_stats()        # 让游戏一开始处于非活动状态        self.game_active = False        # 在任何情况下都不应重置最高得分        self.high_score = 0    def reset_stats(self):        &quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot;        self.ships_left = self.ai_settings.ship_limit        self.score = 0        self.level = 1</code></pre><h3 id="score-board-py"><a href="#score-board-py" class="headerlink" title="score_board.py"></a>score_board.py</h3><pre><code class="python">import pygame.fontfrom pygame.sprite import Groupfrom ship import Shipclass Scoreboard():    &quot;&quot;&quot;显示得分信息的类&quot;&quot;&quot;    def __init__(self, ai_settings, screen, stats):        &quot;&quot;&quot;初始化显示得分涉及的属性&quot;&quot;&quot;        self.screen = screen        self.screen_rect = screen.get_rect()        self.ai_settings = ai_settings        self.stats = stats        # 显示得分信息时使用的字体设置        self.text_color = (30, 30, 30)        self.font = pygame.font.SysFont(None, 48)        # 准备包含最高得分和当前得分的图像        self.prep_score()        self.prep_high_score()        self.prep_level()        self.prep_ships()    def prep_score(self):        &quot;&quot;&quot;将得分转换为一幅渲染的图像&quot;&quot;&quot;        score_str = &quot;{:,}&quot;.format(self.stats.score)        self.score_image = self.font.render(score_str, True, self.text_color, self.ai_settings.bg_color)        # 将得分放在屏幕右上角        self.score_rect = self.score_image.get_rect()        self.score_rect.right = self.screen_rect.right - 20        self.score_rect.top = 20    def prep_high_score(self):        high_score_str = &quot;{:,}&quot;.format(self.stats.high_score)        self.high_score_image = self.font.render(high_score_str, True, self.text_color, self.ai_settings.bg_color)        # 将得分放在屏幕上中央        self.high_score_rect = self.high_score_image.get_rect()        self.high_score_rect.centerx = self.screen_rect.centerx        self.high_score_rect.top = 20    def prep_level(self):        &quot;&quot;&quot;将等级转换为渲染的图像&quot;&quot;&quot;        self.level_image = self.font.render(str(self.stats.level), True,                                            self.text_color, self.ai_settings.bg_color)        # 将等级放在得分下方        self.level_rect = self.level_image.get_rect()        self.level_rect.centerx = self.screen_rect.centerx        self.level_rect.top = 20    def prep_ships(self):        &quot;&quot;&quot;显示还余下多少艘飞船&quot;&quot;&quot;        self.ships = Group()        for ship_number in range(self.stats.ships_left):            ship = Ship(self.ai_settings, self.screen)            ship.rect.x = 10 + ship.rect.width * ship_number            ship.rect.y = 10            self.ships.add(ship)    def show_score(self):        &quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;        self.screen.blit(self.score_image, self.score_rect)        self.screen.blit(self.high_score_image, self.high_score_rect)        self.screen.blit(self.level_image, self.level_rect)        # 绘制飞船        self.ships.draw(self.screen)</code></pre><h3 id="button-py"><a href="#button-py" class="headerlink" title="button.py"></a>button.py</h3><pre><code class="python">import pygame.fontclass Button():    def __init__(self, ai_settings, screen, msg):        &quot;&quot;&quot;初始化按钮的属性&quot;&quot;&quot;        self.screen = screen        self.screen_rect = screen.get_rect()        # 设置按钮的尺寸和其他属性        self.width, self.height = 200, 50        self.button_color = (0, 250, 0)        self.text_color = (255, 255, 255)        self.font = pygame.font.SysFont(None, 48)        # 创建按钮的rect对象， 并使其居中        self.rect = pygame.Rect(0, 0, self.width, self.height)        self.rect.center = self.screen_rect.center        # 按钮的标签只需创建一次        self.prep_msg(msg)    def prep_msg(self, msg):        &quot;&quot;&quot;将msg渲染为图像， 并使其在按钮上居中&quot;&quot;&quot;        self.msg_image = self.font.render(msg, True, self.text_color, self.button_color)        self.msg_image_rect = self.msg_image.get_rect()        self.msg_image_rect.center = self.rect.center    def draw_button(self):        # 绘制一个用颜色填充的按钮， 再绘制文本        self.screen.fill(self.button_color, self.rect)        self.screen.blit(self.msg_image, self.msg_image_rect)</code></pre><h3 id="game-functions-py"><a href="#game-functions-py" class="headerlink" title="game_functions.py"></a>game_functions.py</h3><pre><code class="python">import sysfrom time import sleepimport pygamefrom bullet import Bulletfrom alien import Aliendef check_keydown_events(event, ai_settings, stats, play_button, screen, ship, bullets):    &quot;&quot;&quot;响应按键&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        # 向右移动飞船        ship.moving_right = True    elif event.key == pygame.K_LEFT:        # 向左移动飞船        ship.moving_left = True    elif event.key == pygame.K_SPACE:        # 创建一颗子弹， 并将其加入到编组bullets中        fire_bullet(ai_settings, screen, ship, bullets)    elif event.key == pygame.K_q:        sys.exit()def check_play_button(ai_settings, screen, stats, play_button, sb, ship, aliens,                      bullets, mouse_x, mouse_y):    &quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;    button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y)    if button_clicked and not stats.game_active:        # 重置游戏设置        ai_settings.initialize_dynamic_settings()        # 重置游戏统计信息        stats.reset_stats()        stats.game_active = True        # 隐藏光标        pygame.mouse.set_visible(False)        # 重置记分牌图像        sb.prep_score()        # sb.prep_high_score()        sb.prep_level()        sb.prep_ships()        # 清空外星人列表和子弹列表        aliens.empty()        bullets.empty()        # 创建一群新的外星人， 并让飞船居中        create_fleet(ai_settings, screen, ship, aliens)        ship.center_ship()def fire_bullet(ai_settings, screen, ship, bullets):    &quot;&quot;&quot;如果还没有到达限制， 就发射一颗子弹&quot;&quot;&quot;    # 创建新子弹， 并将其加入到编组bullets中    if len(bullets) &lt; ai_settings.bullets_allowed:        new_bullet = Bullet(ai_settings, screen, ship)        bullets.add(new_bullet)def check_keyup_events(event, ship):    &quot;&quot;&quot;响应按键&quot;&quot;&quot;    if event.key == pygame.K_RIGHT:        # 向右移动飞船        ship.moving_right = False    elif event.key == pygame.K_LEFT:        # 向左移动飞船        ship.moving_left = Falsedef check_event(ai_settings, stats, play_button, screen, sb, ship, aliens, bullets):    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;    for event in pygame.event.get():        if event.type == pygame.QUIT:            sys.exit()        elif event.type == pygame.MOUSEBUTTONDOWN:            mouse_x, mouse_y = pygame.mouse.get_pos()            check_play_button(ai_settings, screen, stats, play_button, sb, ship, aliens,                              bullets, mouse_x, mouse_y)        elif event.type == pygame.KEYDOWN:            check_keydown_events(event, ai_settings, stats, play_button, screen, ship, bullets)        elif event.type == pygame.KEYUP:            check_keyup_events(event, ship)def update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets, play_button):    &quot;&quot;&quot;更新屏幕上的图像， 并切换到新屏幕&quot;&quot;&quot;    # 设置背景色bg_color = (230, 230, 230)    screen.fill(ai_settings.bg_color)    # 在飞船和外星人后面重绘所有子弹    for bullet in bullets:        bullet.draw_bullet()    ship.blitme()    # alien.blitme()    aliens.draw(screen)    # 显示得分    sb.show_score()    # 如果游戏处于非活动状态， 就绘制Play按钮    if not stats.game_active:        play_button.draw_button()    # 让绘制的屏幕可见    pygame.display.flip()def get_number_aliens_x(ai_settings, alien_width):    &quot;&quot;&quot;创建一个外星人， 并计算一行可容纳多少个外星人&quot;&quot;&quot;    # 外星人间距为外星人宽度    available_space_x = ai_settings.screen_width - alien_width * 2    return int(available_space_x / (alien_width * 2))def get_number_aliens_y(ai_settings, ship_height, alien_height):    available_space_y = ai_settings.screen_height - alien_height * 3 - ship_height    return int(available_space_y / (2 * alien_height))def create_alien(ai_settings, screen, aliens, alien_number, alien_row):    &quot;&quot;&quot;创建一个外星人并将其放在当前行&quot;&quot;&quot;    alien = Alien(ai_settings, screen)    alien_width = alien.rect.width    alien.x = alien_width + 2 * alien_width * alien_number    alien.rect.x = alien.x    alien.rect.y = alien.rect.height + 2 * alien.rect.height * alien_row    aliens.add(alien)def create_fleet(ai_settings, screen, ship, aliens):    &quot;&quot;&quot;创建外星人群&quot;&quot;&quot;    # 创建一个外星人， 并计算一行可容纳多少个外星人    alien = Alien(ai_settings, screen)    alien_width = alien.rect.width    alien_height = alien.rect.height    ship_height = ship.rect.height    number_aliens_x = get_number_aliens_x(ai_settings, alien_width)    number_aliens_y = get_number_aliens_y(ai_settings, ship_height, alien_height)    # 创建n行外星人    for alien_row in range(number_aliens_y):        for alien_number in range(number_aliens_x):            create_alien(ai_settings, screen, aliens, alien_number, alien_row)def check_fleet_edges(ai_settings, aliens):    &quot;&quot;&quot;有外星人到达边缘时采取相应的措施&quot;&quot;&quot;    for alien in aliens.sprites():        if alien.check_edge():            change_directions(ai_settings, aliens)            breakdef change_directions(ai_settings, aliens):    &quot;&quot;&quot;将整群外星人下移， 并改变它们的方向&quot;&quot;&quot;    for alien in aliens.sprites():        alien.rect.y += ai_settings.fleet_drop_speed    ai_settings.fleet_direction *= -1def ship_hit(ai_settings, stats, screen, sb, ship, aliens, bullets):    &quot;&quot;&quot;响应被外星人撞到的飞船&quot;&quot;&quot;    if stats.ships_left &gt; 0:        # 将ships_left减1        stats.ships_left -= 1        # 清空外星人列表和子弹列表        aliens.empty()        bullets.empty()        # 更新记分牌        sb.prep_ships()        # 创建一群新的外星人， 并将飞船放到屏幕底端中央        create_fleet(ai_settings, screen, ship, aliens)        ship.center_ship()        # 暂停        sleep(0.5)    else:        stats.game_active = False        pygame.mouse.set_visible(True)def update_aliens(ai_settings, stats, screen, sb, ship, aliens, bullets):    &quot;&quot;&quot;检查是否有外星人位于屏幕边缘， 并更新整群外星人的位置&quot;&quot;&quot;    check_fleet_edges(ai_settings, aliens)    aliens.update()    # 检测外星人和飞船之间的碰撞    if pygame.sprite.spritecollideany(ship, aliens):        ship_hit(ai_settings, stats, screen, sb, ship, aliens, bullets)    # 检查是否有外星人到达屏幕底端    check_aliens_bottom(ai_settings, stats, screen, sb, ship, aliens, bullets)def update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets):    &quot;&quot;&quot;更新子弹的位置， 并删除已消失的子弹&quot;&quot;&quot;    # 更新子弹的位置    bullets.update()    # 删除已消失的子弹    for bullet in bullets.copy():        if bullet.rect.bottom &lt;= 0:            bullets.remove(bullet)    # 检查是否有子弹击中了外星人    check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, aliens, bullets)def check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, aliens, bullets):    &quot;&quot;&quot;如果有子弹击中了外星，就删除相应的子弹和外星人&quot;&quot;&quot;    collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)    if collisions:        for alien in collisions.values():            stats.score += ai_settings.alien_score * len(alien)            sb.prep_score()        # check_high_score(stats, sb)    if len(aliens) == 0:        # 删除现有的子弹， 加快游戏节奏， 并创建一群新的外星人        bullets.empty()        ai_settings.increase_speed()        # 提高等级        stats.level += 1        sb.prep_level()        create_fleet(ai_settings, screen, ship, aliens)def check_aliens_bottom(ai_settings, stats, screen, sb, ship, aliens, bullets):    &quot;&quot;&quot;检查是否有外星人到达了屏幕底端&quot;&quot;&quot;    screen_rect = screen.get_rect()    for alien in aliens.sprites():        if alien.rect.bottom &gt;= screen_rect.bottom:            # 像飞船被撞到一样进行处理            ship_hit(ai_settings, stats, screen, sb, ship, aliens, bullets)            breakdef check_high_score(stats, sb):    &quot;&quot;&quot;检查是否诞生了新的最高得分&quot;&quot;&quot;    if stats.score &gt; stats.high_score:        stats.high_score = stats.score        sb.prep_high_score()</code></pre><h3 id="ship-py"><a href="#ship-py" class="headerlink" title="ship.py"></a>ship.py</h3><pre><code class="python">import pygamefrom pygame.sprite import Spriteclass Ship(Sprite):    def __init__(self, ai_settings, screen):        &quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;        super().__init__()        self.screen = screen        self.ai_settings = ai_settings        # 加载飞船图像并获取其外接矩形        self.image = pygame.image.load(&#39;images/ship.bmp&#39;)        self.rect = self.image.get_rect()        self.screen_rect = screen.get_rect()        # 将每艘新飞船放到屏幕底部中央        self.rect.centerx = self.screen_rect.centerx        self.rect.bottom = self.screen_rect.bottom        # 在飞船的属性center中存储小数值        self.center = float(self.rect.centerx)        # 移动标志        self.moving_right = False        self.moving_left = False    def update(self):        &quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;        if self.moving_right and self.rect.right &lt; self.screen_rect.right:            self.center += self.ai_settings.ship_speed_factor        if self.moving_left and self.rect.left &gt; 0:            self.center -= self.ai_settings.ship_speed_factor        # 根据self.center更新rect对象        self.rect.centerx = self.center    def blitme(self):        &quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;        self.screen.blit(self.image, self.rect)    def center_ship(self):        &quot;&quot;&quot;让飞船在屏幕上居中&quot;&quot;&quot;        self.center = self.screen_rect.centerx</code></pre><h3 id="bullet-py"><a href="#bullet-py" class="headerlink" title="bullet.py"></a>bullet.py</h3><pre><code class="python">import pygamefrom pygame.sprite import Spriteclass Bullet(Sprite):    &quot;&quot;&quot;一个对飞船发射的子弹进行管理的类&quot;&quot;&quot;    def __init__(self, ai_settings, screen, ship):        &quot;&quot;&quot;在飞船所处的位置创建一个子弹对象&quot;&quot;&quot;        super().__init__()        self.screen = screen        # 在(0,0)处创建一个表示子弹的矩形，再设置正确的位置        self.rect = pygame.Rect(0, 0, ai_settings.bullet_width, ai_settings.bullet_height)        self.rect.centerx = ship.rect.centerx        self.rect.top = ship.rect.top        # 存储用小数表示的子弹位置        self.y = float(self.rect.y)        self.color = ai_settings.bullet_color        self.speed_factor = ai_settings.bullet_speed_factor    def update(self):        &quot;&quot;&quot;向上移动子弹&quot;&quot;&quot;        # 更新表示子弹位置的小数值        self.y -= self.speed_factor        # 更新表示子弹的rect的位置        self.rect.y = self.y    def draw_bullet(self):        &quot;&quot;&quot;绘制子弹&quot;&quot;&quot;        pygame.draw.rect(self.screen, self.color, self.rect)</code></pre><h3 id="alien-invasion-py"><a href="#alien-invasion-py" class="headerlink" title="alien_invasion.py"></a>alien_invasion.py</h3><pre><code class="python">import pygamefrom pygame.sprite import Groupfrom settings import Settingsfrom game_stats import GameStatsfrom ship import Shipfrom button import Buttonfrom scoreboard import Scoreboardimport game_functions as gfdef run_game():    # 初始化游戏并创建一个屏幕对象    pygame.init()    ai_settings = Settings()    screen = pygame.display.set_mode((ai_settings.screen_width, ai_settings.screen_height))    pygame.display.set_caption(&quot;Alien Invasion&quot;)    # 创建Play按钮    play_button = Button(ai_settings, screen, &quot;Play&quot;)    # 创建存储游戏统计信息的实例， 并创建记分牌    stats = GameStats(ai_settings)    sb = Scoreboard(ai_settings, screen, stats)    # 创建一艘飞船    ship = Ship(ai_settings, screen)    # 创建一个用于存储子弹的编组    bullets = Group()    # 创建一个外星人    # alien = Alien(ai_settings, screen)    # 创建一个外星人编组    aliens = Group()    # 创建外星人群    gf.create_fleet(ai_settings, screen, ship, aliens)    # 开始游戏主循环    while True:        # 监视键盘和鼠标事件        gf.check_event(ai_settings, stats, play_button, screen, sb, ship, aliens, bullets)        if stats.game_active:            # 更新飞船状态            ship.update()            # 更新子弹的位置， 并删除已消失的子弹            gf.update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets)            # 更新外星人位置            gf.update_aliens(ai_settings, stats, screen, sb, ship, aliens, bullets)        # 每次循环时都重绘屏幕        gf.update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets, play_button)if __name__ == &#39;__main__&#39;:    run_game()</code></pre><h3 id="游戏示例"><a href="#游戏示例" class="headerlink" title="游戏示例"></a>游戏示例</h3><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/alien_invasion_1.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/alien_invasion_2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 项目 </tag>
            
            <tag> pygame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中内存分区与内存管理详解</title>
      <link href="/2020/09/08/C%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/09/08/C%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>c 语言五大内存分区</p><ul><li>栈区（stack）:由编译器自动分配与释放，存放函数的参数值，局部变量，临时变量等等，它们获取的方式都是由编译器自动执行的</li><li>堆区（heap）:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。一般由程序员分配与释放，基程序员不释放，程序结束时可能由操作系统回收（C/C++没有此等回收机制，Java/C#有），注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li><li>全局/静态存储区：存放全局变量和静态变量（包括静态全局变量与静态局部变量），全局变量和静态变量的存储是放在一块儿的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</li><li>文字常量区：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。</li><li>程序代码区：存放程序的二进制代码，内存由系统管理</li></ul></blockquote><a id="more"></a><h2 id="c-语言五大内存分区"><a href="#c-语言五大内存分区" class="headerlink" title="c 语言五大内存分区"></a>c 语言五大内存分区</h2><p><strong>栈区：</strong></p><p>在函数中定义的变量存放的内存区域。</p><p>常见的 int、float、char 等变量均存放于栈区中，它的特点是由系统自动分配与释放，不需要程序员考虑资源回收的问题，方便简洁。</p><p>ps：栈区的地址分配是从内存的高地址开始向地地址分配。</p><p><strong>堆区：</strong></p><p>程序员通过指令自主向系统申请的内存区域，大小由程序员决定，它在使用完后同样需要程序员通过指令去释放该区域内存，否则将有可能出现内存的浪费与溢出。</p><p>C 语言中申请堆区指令为：</p><pre><code class="c">int *p = (int *) malloc( N * sizeof(int) );  //分配N个int型（4字节）的内存，即 4 * N 个字节</code></pre><p>ps：但指针 p 存放于栈区。</p><p>C 语言中释放堆区指令为：</p><pre><code class="c">free( p ); //注意此处参数为指针</code></pre><p>使用中应该注意，尽量不要去修改 p 指针对应的地址值，否则在内存释放时将出现错误。（编译可通过，运行出现问题）</p><p><strong>全局变量&amp;静态变量区：</strong></p><p>全局变量与静态变量本应是两个概念，但由于它们在内存中存放的区域相同，所以将他们放在一起讨论。</p><p>全局变量：</p><p>位于所有函数外部定义的变量，在整个工程中可见，可修改。</p><p>静态变量：</p><p>位于所有函数内部定义的由 static 修饰的变量，仅在定义的函数中可见，可修改。（这是它与全局变量的关键区别）</p><p>ps：静态变量仅在第一次创建时初始化一次，之后自动跳过初始化语句。</p><p>全局变量与静态变量均由系统分配和释放内存，若未对它们进行初始化操作，系统将自动将其值设置为 0。（堆区与栈区则不会）</p><p><strong>文字常量区：</strong></p><p>用于存放文字等不可修改的常量，由系统分配和释放内存。</p><p>常见的使用：</p><pre><code class="c">char *s = &quot;HelloWorld&quot;;//该字符串 HelloWorld 即存放于文字常量区，不可修改</code></pre><p>ps：但指针 s 存放于栈区。</p><p>pps：若在程序中尝试对其修改（例如尝试修改第一个字符 *s = ‘h’;），将出现编译可通过，运行报错的情况。</p><p>同时因注意它与 const 修饰的变量之间的区别：</p><pre><code class="c">char aa = &#39;A&#39;;//aa存放于栈区const char bb = &#39;B&#39;; //bb同样存放于栈区</code></pre><p>const 修饰的变量仅仅用于告诉编译器 bb 是一个常量，如果后续的程序中有出现尝试修改 bb 的操作时，编译将报错。</p><p>这种写法主要是为了防止程序员在后续的代码中误操作 bb 变量而添加的一个约束条件，并不会影响它存放的位置。</p><p><strong>程序代码区：</strong></p><p>用于存储程序编译连接后生成的二进制机器码指令的内存区域。该部分内容可通过反汇编操作将机器码转换为汇编语言。</p><p><strong>C 语言例子：</strong></p><pre><code class="c">#include &lt;stdio.h&gt;static unsigned int val1 = 1;        //val1存放在.data段unsigned int val2 = 1;               //初始化的全局变量存放在.data段unsigned int val3 ;                  //未初始化的全局变量存放在.bss段const unsigned int val4 = 1;         //val4存放在.rodata（只读数据段）unsigned char Demo(unsigned int num) //num 存放在栈区{  char var = &quot;123456&quot;;               //var存放在栈区，&quot;123456&quot;存放在常量区  unsigned int num1 = 1 ;            //num1存放在栈区  static unsigned int num2 = 0;      //num2存放在.data段  const unsigned int num3 = 7;       //num3存放在栈区  void *p;  p = malloc(8);                     //p存放在堆区  free(p);  return 1;}void main(){  unsigned int num = 0 ;  num = Demo(num);                   //Demo()函数的返回值存放在栈区。}</code></pre><h2 id="可执行程序程序三段"><a href="#可执行程序程序三段" class="headerlink" title="可执行程序程序三段"></a>可执行程序程序三段</h2><p>一个程序的 3 个基本段：text 段，dtae 段，bss 段 text 段在内存中被映射为只读，但 date 段与 bss 段是可写的</p><ul><li>text 段：代码段，就是放程序代码的，编译时确定，只读</li><li>date 段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域</li><li>bss 段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E4%B8%89%E6%AE%B5.gif" alt=""></p><p>可执行程序程序三段与五大分区两者之间区别是：</p><ul><li>代码段，数据段，堆栈段是 cpu 级别的概念</li><li>五大分区属于语言级别的概念，两者是不同的概念。</li></ul><h2 id="存储类型关键字定义变量与函数作用域与生命周期"><a href="#存储类型关键字定义变量与函数作用域与生命周期" class="headerlink" title="存储类型关键字定义变量与函数作用域与生命周期"></a>存储类型关键字定义变量与函数作用域与生命周期</h2><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p><ul><li>auto 变量：函数的局部变量，如果没有声明为 static,函数中定义的局部变量全部为 auto 类型，auto 变量包括未加 static 声明的局部变量和函数的形参。在函数调用时系统会给他们分配存储空间，在函数调用结束后会自动释放这些空间。属于动态存储方式。</li><li>static 变量：用 static 声明的局部变量在调用结束后不会消失而保存原来的值。static 局部变量定义使用后值会存储下来。所以使用 static 局部变量定义只需要一次赋值。静态局部变量的作用域仅限于所定义的函数。但函数结束后变量的值会保留。直到整个程序运行结束。全局变量从定义开始作用于整个文件直至程序运行结束。</li><li>register 寄存器变量：寄存器变量可以提高 c 语言的执行效率，即将局部变量的值存入 CPU 的寄存器中。需要注意的是！！！：1.只有动态存储的变量（自动局部变量和形参）才可以作为寄存器变量来存储，局部静态变量不可以定义为寄存器变量。2.计算机的寄存器数目是有限的，所以不能定义任意多个寄存器变量。</li><li>extern 外部变量：即全局变量的外部表现形式，是在函数外部定义的变量。全局变量的作用域为从定义开始到源文件结束。exten 对该变量作外部变量声明，扩展变量作用域。</li></ul><h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><ol><li><p>申请方式</p><ul><li>stack:栈;由系统自动分配，自动开辟空间</li><li>heap:由程序员自己申请并指明大小，c 中 malloc,c++中 new。如 p1=(char<em>)malloc(10);p2=(char</em>)new(10);但需要注意的是 p1,p2 本事是在栈中的</li></ul></li><li><p>申请后系统的响应</p><ul><li>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出</li><li>堆：首先操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外对于大部分系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 语句才能正确的释放本内存空间。另外由于找到的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li></ul></li><li><p>申请大小的限制</p><ul><li>栈：在 windows 下栈是向低地址扩展的数据结构，是一块连续的内存区域。所以栈的栈顶地址和最大容量是系统预先设定好的。在 windows 下栈的大小是 2M.因此能从栈获得的空间比较小。</li><li>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是是由于系统用链表来存储空闲内存地址的，所以是不连续的。而链表的遍历方向是由低地址到高地址。堆得大小受限于计算机系统中有效的虚拟内存大小。相比较而言堆获得的空间比较灵活，也比较大。</li></ul></li><li><p>申请效率的比较</p><ul><li>栈：由系统自动分配，速度较快，但程序员是无法控制的。</li><li>堆：由 new 分配的内存，一般速度比较慢，而且比较容易产生内存碎片，不过用起来最方便。</li></ul></li><li><p>堆和栈中的存储内容</p><ul><li>栈：在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数。在大多数 c 编译器中，参数是由右往左压栈的，然后是函数中的局部变量。静态变量是不入栈的。当函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，，也就是主函数的下一条指令，程序由该点继续执行。</li><li>堆：一般是在堆的头部用一个字节存放堆得大小，其他内容自己安排。</li></ul></li><li><p>存取效率的比较</p></li></ol><pre><code class="c">1 char str1[]=&quot;aaaaaa&quot;;2 char \*str2=&quot;cccccc&quot;;</code></pre><ul><li>第一行是在运行时刻赋值的，第二行是在编译时就已经确定的，但在以后的存取过程中，在栈上的数组比指针指向的字符串快。</li></ul><h2 id="堆内存管理函数"><a href="#堆内存管理函数" class="headerlink" title="堆内存管理函数"></a>堆内存管理函数</h2><p>C 标准函数库提供了许多函数来实现对堆上内存管理，其中包括：malloc()函数，free()函数，calloc()函数和 realloc()函数。使用这些函数需要包含头文件 stdlib.h。它们的声明如下：</p><pre><code class="c">void _malloc(size_t n);void free(void _ p);void _calloc(size_t n, size_t size);void _realloc(void \* p, size_t n);</code></pre><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc()函数可以从堆上获得指定字节的内存空间，其函数声明如下：</p><pre><code class="c">void \* malloc(size_t n);</code></pre><p>其中，形参 n 为要求 分配的字节数。如果函数执行成功，malloc()返回获得内存空间的首地址；如果函数执行失败，那么返回值为 NULL。由于 malloc()函数值的类型为 void 型指针，因此，可以将其值类型转换后赋给任意类型指针，这样就可以通过操作该类型指针来操作从堆上获得的内存空间。</p><p>需要注意的是，malloc()函数分配得到的内存空间是未初始化的。因此，一般在使用该内存空间时，要调用另一个函数 memset 来将其初始化为全 0。memset 函数的声明如下：</p><pre><code class="c">void _ memset (void _ p, int c, size_t n);</code></pre><p>该函数可以将指定的内存空间按字节单位置为指定的字符 c。其中，p 为要清零的内存空间的首地址，c 为要设定的值，n 为被操作的内存空间的字节长度。如果要用 memset 清 0，变量 c 实参要为 0。malloc()函数和 memset 函数的操作语句一般如下：</p><pre><code class="c">int _p = NULL;p = (int _) malloc(sizeof(int));if (p == NULL){    printf(&quot;Can’t get memory!\n&quot;);}memset(p, 0, sizeof(int));</code></pre><p>注意：通过 malloc()函数得到的堆内存必须使用 memset()函数来初始化。</p><p>示例代码：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(){    int _p = NULL;    p = (int _) malloc(sizeof(int));    if (NULL == p){        printf(&quot;Can&#39;t get memory!\n&quot;);        return -1;    }    printf(&quot;%d\n&quot;, *p);             // 输出分配的空间上的值    memset(p, 0, sizeof(int));      // 将p指向的空间清0    printf(&quot;%d\n&quot;, *p);             // 输出调用memset函数后的结果    *p = 2;    printf(&quot;%d\n&quot;, *p);    return 0;}</code></pre><hr><p><a href="https://zhuanlan.zhihu.com/p/105090421" target="_blank" rel="noopener">C 语言- 5 分钟看懂什么是 malloc</a></p><h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>从堆上获得的内存空间在程序结束以后，系统不会将其自动释放，需要程序员来自己管理。一个程序结束时，必须保证所有从堆上获得的内存空间已被安全释放，否则，会导致内存泄露。例如上面的 demo 就会发生内存泄露。</p><p>free()函数可以实现释放内存的功能。其函数声明为：</p><pre><code class="c">void free(void * p);</code></pre><p>由于形参为 void 指针，free()函数可以接受任意类型的指针实参。</p><p>但是，free()函数只是释放指针指向的内容，而该指针仍然指向原来指向的地方，此时，指针为野指针，如果此时操作该指针会导致不可预期的错误。安全做法 是：在使用 free()函数释放指针指向的空间之后，将指针的值置为 NULL。因此，对于上面的 demo，需要在 return</p><p>语句前加入以下两行语句：</p><pre><code class="c">free(p);p = NULL;</code></pre><p>注意：使用 malloc()函数分配的堆空间在程序结束之前必须释放。</p><h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><p>calloc()函数的功能与 malloc()函数的功能相似，都是从堆分配内存。其函数声明如下：</p><pre><code class="c">void *calloc(size_t n, size_t size);</code></pre><p>函数返回值为 void 型指针。如果执行成功，函数从堆上获得 size X n 的字节空间，并返回该空间的首地址。如果执行失败，函数返回 NULL。该函数与 malloc()函数的一个显著不同时是，calloc()函数得到的内存空间是经过初始化的，其内容全为 0。calloc()函数适合为数组申请空间，可以将 size 设置为数组元素的空间长度，将 n 设置为数组的容量。</p><p>示例代码：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SIZE 5int main(){    int *p = NULL;    int i = 0;    // 为p从堆上分配SIZE个int型空间    p = (int *) calloc(SIZE, sizeof(int));    if (NULL == p)    {        printf(&quot;Error in calloc.\n&quot;);        return -1;    }    // 为p指向的SIZE个int型空间赋值    for (i = 0; i &lt; SIZE; i++)    {        p[i] = i;    }    // 输出各个空间的值    for (i = 0; i &lt; SIZE; i++)    {        printf(&quot;p[%d]=%d\n&quot;, i, p[i]);    }    free(p);    p = NULL;    return 0;}</code></pre><p>提示：calloc()函数的分配的内存也需要自行释放。</p><h3 id="realloc"><a href="#realloc" class="headerlink" title="realloc()"></a>realloc()</h3><p>realloc()函数的功能比 malloc()函数和 calloc()函数的功能更为丰富，可以实现内存分配和内存释放的功能，其函数声明如下：</p><pre><code class="c">void * realloc(void * p, size_t n);</code></pre><p>其中，指针 p 必须为指向堆内存空间的指针，即由 malloc()函数、calloc()函数或 realloc()函数分配空间的指针。realloc()函数将指针 p 指向的内存块的大小改变为 n 字节。如果 n 小于或等于 p 之前指向的空间大小，那么。保持原有状态不变。如果 n 大于原来 p 之前指向的空间大小，那么，系统将 重新为 p 从堆上分配一块大小为 n 的内存空间，同时，将原来指向空间的内容依次复制到新的内存空间上，p 之前指向的空间被释放。realloc()函数分配的空间也是未初始化的。</p><p>注意：使用 malloc()函数，calloc()函数和 realloc()函数分配的内存空间都要使用 free()函数或指针参数为 NULL 的 realloc()函数来释放。</p><p>示例代码：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    int *p = NULL;    p = (int *) malloc(sizeof(int));    *p = 3;    printf(&quot;p=%p\n&quot;, p);    printf(&quot;*p=%d\n&quot;, *p);    p = (int *) realloc(p, sizeof(int));    printf(&quot;p=%p\n&quot;, p);    printf(&quot;*p=%d\n&quot;, *p);    p = (int *) realloc(p, 3 * sizeof(int));    printf(&quot;p=%p\n&quot;, p);    printf(&quot;*p=%d&quot;, *p);    // 释放p指向的空间    realloc(p, 0);    p = NULL;    return 0;}</code></pre><p>下面要注意的几点是：</p><ol><li>函数 malloc()和 calloc()都可以用来动态分配内存空间。 malloc()函数有一个参数，即分配的内存空间的大小，malloc()在分配内存的时候会保留一定的空间用来记录分配情况，分配的次数越多，这些记录占用的空间就越多。 另外，根据 malloc()实现策略的不同，malloc()每次在分配的时候，可能分配的空间比实际要求的多些，多次分配会导致更多的这种浪费，当然，这些都跟 malloc()的实现有关； calloc()函数有两个参数，分别为元素的个数和每个元素的大小，这两个参数的乘积就是要分配的内存空间的大小。如果调用成功，它们都将返回所分配内存空间的首地址。</li><li>函数 malloc()和 calloc()的主要区别是前者不能初始化所分配的内存空间，而后者可以。</li><li>realloc()可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或者缩小，原有内存中的内容将保持不变。当然，对于缩小，则被缩小的那一部分的内容会丢失。</li><li>realloc()并不保证调整后的内存空间和原来的内存空间保持同一内存地址，相反，realloc()返回的指针很可能指向一个新地址。所以在代码 中，我们必须将 realloc()的返回值，重新赋值给 p ： p = (int _) realloc (p, sizeof(int) _ 15);</li></ol><hr><p><strong>realloc()函数，另外一个注意点：</strong></p><p>realloc()有可能操作失败，返回 NULL，所以不要把它的返回值直接赋值给原来的指针变量，以免原值丢失：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    char *str = NULL;    str = (char *)malloc(sizeof(char));    *str = &#39;a&#39;;    char *p = (char *)realloc(str, sizeof(char) * 10);    if (p != NULL)    {        str = p;    }    printf(&quot;%s\n&quot;, str);    return 0;}</code></pre><p><a href="http://c.biancheng.net/cpp/html/2536.html" target="_blank" rel="noopener">安全起见，小心使用 C 语言 realloc()函数</a></p><h3 id="malloc-calloc-realloc-区别"><a href="#malloc-calloc-realloc-区别" class="headerlink" title="malloc\calloc\realloc 区别"></a>malloc\calloc\realloc 区别</h3><p>三个函数的申明分别是:</p><pre><code class="c">void* realloc(void* ptr, unsigned newsize);void* malloc(unsigned size);void* calloc(size_t numElements, size_t sizeOfElement);</code></pre><p>都在 stdlib.h 函数库内<br>它们的返回值都是请求系统分配的地址,如果请求失败就返回 NULL</p><p>malloc 用于申请一段新的地址,参数 size 为需要内存空间的长度,如:</p><pre><code class="c">char* p;p=(char*)malloc(20);</code></pre><p>calloc 与 malloc 相似,参数 sizeOfElement 为申请地址的单位元素长度,numElements 为元素个数,如:</p><pre><code class="c">char* p;p=(char*)calloc(20,sizeof(char));</code></pre><p>这个例子与上一个效果相同</p><p>realloc 是给一个已经分配了地址的指针重新分配空间,参数 ptr 为原有的空间地址,newsize 是重新申请的地址长度<br>如:</p><pre><code class="c">char* p;p=(char*)malloc(sizeof(char)_20);p=(char_)realloc(p,sizeof(char)\*40);</code></pre><p>注意，这里的空间长度都是以字节为单位。</p><p>C 语言的标准内存分配函数：malloc，calloc，realloc，free 等。</p><ul><li>malloc 与 calloc 的区别为 1 块与 n 块的区别：<ul><li>malloc 调用形式为(类型*)malloc(size)：在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址。</li><li>calloc 调用形式为(类型*)calloc(n，size)：在内存的动态存储区中分配 n 块长度为“size”字节的连续区域，返回首地址。</li></ul></li><li>realloc 调用形式为(类型<em>)realloc(</em>ptr，size)：将 ptr 内存大小增大到 size。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 内存分区 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多任务编程：进程和线程</title>
      <link href="/2020/09/04/Python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/09/04/Python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一般写的程序都是单任务的，也就是说一个函数或者方法执行完成之后另外一个函数或者方法才能执行，要想实现多个任务同时执行的操作就需要使用多任务。<br>多任务的最大好处是充分利用 CPU 资源，提高程序的执行效率。</p></blockquote><a id="more"></a><h2 id="多任务的概念"><a href="#多任务的概念" class="headerlink" title="多任务的概念"></a>多任务的概念</h2><p>多任务是指在同一时间内执行多个任务。多任务能充分利用 CPU 资源，提高程序的执行效率，让程序具备处理多个任务的能力。</p><p>多任务的执行方式：</p><ul><li>并发</li><li>并行</li></ul><p><strong>并发</strong></p><pre><code>任务数 &gt; CPU核心数，在一段时间内交替去执行任务。对于单核cpu处理多任务,操作系统轮流让各个软件交替执行。假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。</code></pre><p><strong>并行</strong></p><pre><code>任务数 &lt; CPU核心数，对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。并行才是多个任务真正意义一起执行。</code></pre><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>一个正在运行的程序或者软件就是一个进程，它是操作系统进行资源分配的基本单位，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。</p><p>比如:现实生活中的公司可以理解成是一个进程，公司提供办公资源(电脑、办公桌椅等)，真正干活的是员工，员工可以理解成线程。</p><p><strong>一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。</strong></p><h3 id="多进程的使用"><a href="#多进程的使用" class="headerlink" title="多进程的使用"></a>多进程的使用</h3><p><strong>1.导入进程包</strong></p><pre><code class="python">#导入进程包import multiprocessing</code></pre><p><strong>2.Process 进程类的说明</strong><br>Process([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>group：指定进程组，目前只能使用 None</li><li>target：执行的目标任务名</li><li>name：进程名字</li><li>args：以元组方式给执行任务传参</li><li>kwargs：以字典方式给执行任务传参</li></ul><p>Process 创建的实例对象的常用方法:</p><ul><li>start()：启动子进程实例（创建子进程）</li><li>join()：等待子进程执行结束</li><li>terminate()：不管任务是否完成，立即终止子进程</li></ul><p>Process 创建的实例对象的步骤:</p><ul><li>导入进程包<ul><li>import multiprocessing</li></ul></li><li>创建子进程并指定执行的任务<ul><li>sub_process = multiprocessing.Process (target=任务名)</li></ul></li><li>启动进程执行任务<ul><li>sub_process.start()</li></ul></li></ul><p><strong>多进程完成多任务的代码</strong></p><pre><code class="python">import multiprocessingimport time# 跳舞任务def dance():    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)# 唱歌任务def sing():    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p>执行结果:</p><pre><code class="python">唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...</code></pre><h3 id="获取进程编号"><a href="#获取进程编号" class="headerlink" title="获取进程编号"></a>获取进程编号</h3><p><strong>1.获取进程编号的目的</strong></p><p>获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。</p><p>获取进程编号的两种操作</p><ul><li>获取当前进程编号</li><li>获取当前父进程编号</li></ul><p>获取当前进程编号方法</p><ul><li>os.getpid()<ul><li>获取当前父进程编号</li></ul></li><li>os.getppid()<ul><li>获取进程编号可以查看父子进程的关系</li></ul></li></ul><p><strong>2.获取当前进程编号</strong></p><p>os.getpid() 表示获取当前进程编号</p><p>示例代码:</p><pre><code class="python">import multiprocessingimport timeimport os# 跳舞任务def dance():    # 获取当前进程的编号    print(&quot;dance:&quot;, os.getpid())    # 获取当前进程    print(&quot;dance:&quot;, multiprocessing.current_process())    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)        # 扩展:根据进程编号杀死指定进程        os.kill(os.getpid(), 9)# 唱歌任务def sing():    # 获取当前进程的编号    print(&quot;sing:&quot;, os.getpid())    # 获取当前进程    print(&quot;sing:&quot;, multiprocessing.current_process())    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 获取当前进程的编号    print(&quot;main:&quot;, os.getpid())    # 获取当前进程    print(&quot;main:&quot;, multiprocessing.current_process())    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p>执行结果:</p><pre><code class="python">main: 70763main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70768dance: &lt;Process(myprocess1, started)&gt;跳舞中...sing: 70769sing: &lt;Process(Process-2, started)&gt;唱歌中...唱歌中...唱歌中...唱歌中...唱歌中...</code></pre><p>**3.获取当前父进程编号</p><p>os.getppid() 表示获取当前父进程编号</p><p>示例代码:</p><pre><code class="python">import multiprocessingimport timeimport os# 跳舞任务def dance():    # 获取当前进程的编号    print(&quot;dance:&quot;, os.getpid())    # 获取当前进程    print(&quot;dance:&quot;, multiprocessing.current_process())    # 获取父进程的编号    print(&quot;dance的父进程编号:&quot;, os.getppid())    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)        # 扩展:根据进程编号杀死指定进程        os.kill(os.getpid(), 9)# 唱歌任务def sing():    # 获取当前进程的编号    print(&quot;sing:&quot;, os.getpid())    # 获取当前进程    print(&quot;sing:&quot;, multiprocessing.current_process())    # 获取父进程的编号    print(&quot;sing的父进程编号:&quot;, os.getppid())    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 获取当前进程的编号    print(&quot;main:&quot;, os.getpid())    # 获取当前进程    print(&quot;main:&quot;, multiprocessing.current_process())    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p>执行结果：</p><pre><code class="python">main: 70860main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70861dance: &lt;Process(myprocess1, started)&gt;dance的父进程编号: 70860跳舞中...sing: 70862sing: &lt;Process(Process-2, started)&gt;sing的父进程编号: 70860唱歌中...唱歌中...唱歌中...唱歌中...唱歌中...</code></pre><h3 id="进程执行带有参数的任务"><a href="#进程执行带有参数的任务" class="headerlink" title="进程执行带有参数的任务"></a>进程执行带有参数的任务</h3><p><strong>1. 进程执行带有参数的任务的介绍</strong></p><p>前面使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢?</p><p>Process 类执行任务并给任务传参数有两种方式:</p><ul><li>元组方式传参(args): 元组方式传参一定要和参数的顺序保持一致。</li><li>字典方式传参(kwargs): 字典方式传参字典中的 key 一定要和参数名保持一致。</li></ul><p><strong>2. args 参数的使用</strong></p><p>示例代码:</p><pre><code class="python">import multiprocessingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子进程    # args: 以元组的方式给任务传入参数    sub_process = multiprocessing.Process(target=task, args=(5,))    sub_process.start()</code></pre><p>执行结果:</p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><p><strong>3. kwargs 参数的使用</strong></p><p>示例代码:</p><pre><code class="python">import multiprocessingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子进程    # kwargs: 表示以字典方式传入参数    sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3})    sub_process.start()</code></pre><p>执行结果:</p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h3 id="进程之间不共享全局变量"><a href="#进程之间不共享全局变量" class="headerlink" title="进程之间不共享全局变量"></a>进程之间不共享全局变量</h3><p>创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。</p><p>示例代码：</p><pre><code class="python">import multiprocessingimport time# 定义全局变量g_list = list()# 添加数据的任务def add_data():    for i in range(5):        g_list.append(i)        print(&quot;add:&quot;, i)        time.sleep(0.2)    # 代码执行到此，说明数据添加完成    print(&quot;add_data:&quot;, g_list)def read_data():    print(&quot;read_data&quot;, g_list)if __name__ == &#39;__main__&#39;:    # 创建添加数据的子进程    add_data_process = multiprocessing.Process(target=add_data)    # 创建读取数据的子进程    read_data_process = multiprocessing.Process(target=read_data)    # 启动子进程执行对应的任务    add_data_process.start()    # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据    add_data_process.join()    read_data_process.start()    print(&quot;main:&quot;, g_list)    # 总结: 多进程之间不共享全局变量</code></pre><p>执行结果:</p><pre><code class="python">add: 0add: 1add: 2add: 3add: 4add_data: [0, 1, 2, 3, 4]main: []read_data []</code></pre><p>进程之间不共享全局变量的解释效果图:</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt=""></p><h3 id="主进程会等待所有的子进程执行结束再结束"><a href="#主进程会等待所有的子进程执行结束再结束" class="headerlink" title="主进程会等待所有的子进程执行结束再结束"></a>主进程会等待所有的子进程执行结束再结束</h3><p>为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是主进程退出子进程销毁，不让主进程再等待子进程去执行。</p><p>设置守护主进程方式：</p><ul><li>子进程对象.daemon = True</li></ul><p>销毁子进程方式：</p><ul><li>子进程对象.terminate()</li></ul><p>假如我们现在创建一个子进程，这个子进程执行完大概需要 2 秒钟，现在让主进程执行 0.5 秒钟就退出程序，查看一下执行结果，示例代码如下:</p><pre><code class="python">import multiprocessingimport time# 定义进程所需要执行的任务def task():    for i in range(10):        print(&quot;任务执行中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建子进程    sub_process = multiprocessing.Process(target=task)    sub_process.start()    # 主进程延时0.5秒钟    time.sleep(0.5)    print(&quot;over&quot;)    exit()    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出</code></pre><p>执行结果:</p><pre><code class="python">任务执行中...任务执行中...任务执行中...over任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...</code></pre><p><strong>说明:</strong></p><p>通过上面代码的执行结果，我们可以得知: 主进程会等待所有的子进程执行结束再结束</p><p>假如我们就让主进程执行 0.5 秒钟，子进程就销毁不再执行，那怎么办呢?</p><p>我们可以设置守护主进程 或者 在主进程退出之前 让子进程销毁</p><p><strong>守护主进程:</strong></p><ul><li>守护主进程就是主进程退出子进程销毁不再执行</li></ul><p><strong>子进程销毁:</strong></p><ul><li>子进程执行结束</li></ul><p>保证主进程正常退出的示例代码:</p><pre><code class="python">import multiprocessingimport time# 定义进程所需要执行的任务def task():    for i in range(10):        print(&quot;任务执行中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建子进程    sub_process = multiprocessing.Process(target=task)    # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程    # sub_process.daemon = True    sub_process.start()    time.sleep(0.5)    print(&quot;over&quot;)    # 让子进程销毁    sub_process.terminate()    exit()    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出    # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁</code></pre><p>执行结果:</p><pre><code class="python">任务执行中...任务执行中...任务执行中...over</code></pre><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>在 Python 中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。</p><p>线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要 cpu 进行调度 ，也就是说线程是 cpu 调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。</p><h3 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h3><p><strong>1. 导入线程模块</strong></p><pre><code class="python">#导入线程模块import threading</code></pre><p><strong>2. 线程类 Thread 参数说明</strong></p><p>Thread([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>group: 线程组，目前只能使用 None</li><li>target: 执行的目标任务名</li><li>args: 以元组的方式给执行任务传参</li><li>kwargs: 以字典方式给执行任务传参</li><li>name: 线程名，一般不用设置</li></ul><p><strong>3. 启动线程</strong></p><ul><li><p>导入线程模块</p><ul><li>import threading</li></ul></li><li><p>创建子线程并指定执行的任务</p><ul><li>sub_thread = threading.Thread(target=任务名)</li></ul></li><li><p>启动线程执行任务</p><ul><li>sub_thread.start()</li></ul></li></ul><p>示例代码：</p><pre><code class="python">import threadingimport time# 唱歌任务def sing():    # 扩展： 获取当前线程    # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread())    for i in range(3):        print(&quot;正在唱歌...%d&quot; % i)        time.sleep(1)# 跳舞任务def dance():    # 扩展： 获取当前线程    # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread())    for i in range(3):        print(&quot;正在跳舞...%d&quot; % i)        time.sleep(1)if __name__ == &#39;__main__&#39;:    # 扩展： 获取当前线程    # print(&quot;当前执行的线程为：&quot;, threading.current_thread())    # 创建唱歌的线程    # target： 线程执行的函数名    sing_thread = threading.Thread(target=sing)    # 创建跳舞的线程    dance_thread = threading.Thread(target=dance)    # 开启线程    sing_thread.start()    dance_thread.start()</code></pre><p>执行结果：</p><pre><code class="python">正在唱歌...0正在跳舞...0正在唱歌...1正在跳舞...1正在唱歌...2正在跳舞...2</code></pre><h3 id="线程执行带有参数的任务"><a href="#线程执行带有参数的任务" class="headerlink" title="线程执行带有参数的任务"></a>线程执行带有参数的任务</h3><p><strong>1. 线程执行带有参数的任务的介绍</strong></p><p>前面使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢?</p><p>Thread 类执行任务并给任务传参数有两种方式:</p><ul><li>元组方式传参(args) ：元组方式传参一定要和参数的顺序保持一致。</li><li>字典方式传参(kwargs)：字典方式传参字典中的 key 一定要和参数名保持一致。</li></ul><p><strong>2. args 参数的使用</strong></p><p>示例代码:</p><pre><code class="python">import threadingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子线程    # args: 以元组的方式给任务传入参数    sub_thread = threading.Thread(target=task, args=(5,))    sub_thread.start()</code></pre><p>执行结果:</p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><p><strong>3. kwargs 参数的使用</strong></p><p>示例代码:</p><pre><code class="python">import threadingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子线程    # kwargs: 表示以字典方式传入参数    sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3})    sub_thread.start()</code></pre><p>执行结果:</p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h3 id="线程之间执行是无序的"><a href="#线程之间执行是无序的" class="headerlink" title="线程之间执行是无序的"></a>线程之间执行是无序的</h3><p>线程之间执行是无序的，它是由 cpu 调度决定的 ，cpu 调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。</p><p>进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。</p><p>示例代码：</p><pre><code class="python">import threadingimport timedef task():    time.sleep(1)    print(&quot;当前线程:&quot;, threading.current_thread().name)if __name__ == &#39;__main__&#39;:   for _ in range(5):       sub_thread = threading.Thread(target=task)       sub_thread.start()</code></pre><p>运行结果：</p><pre><code class="python">当前线程: Thread-1当前线程: Thread-2当前线程: Thread-4当前线程: Thread-5当前线程: Thread-3</code></pre><h3 id="主线程会等待所有的子线程执行结束再结束"><a href="#主线程会等待所有的子线程执行结束再结束" class="headerlink" title="主线程会等待所有的子线程执行结束再结束"></a>主线程会等待所有的子线程执行结束再结束</h3><p>主线程默认会等待所有子线程执行结束再结束，设置守护主线程的目的是主线程退出子线程销毁。</p><p>假如我们现在创建一个子线程，这个子线程执行完大概需要 2.5 秒钟，现在让主线程执行 1 秒钟就退出程序，查看一下执行结果，示例代码如下:</p><pre><code class="python">import threadingimport time# 测试主线程是否会等待子线程执行完成以后程序再退出def show_info():    for i in range(5):        print(&quot;test:&quot;, i)        time.sleep(0.5)if __name__ == &#39;__main__&#39;:    sub_thread = threading.Thread(target=show_info)    sub_thread.start()    # 主线程延时1秒    time.sleep(1)    print(&quot;over&quot;)</code></pre><p>执行结果：</p><pre><code class="python">test: 0test: 1overtest: 2test: 3test: 4</code></pre><p><strong>说明:</strong></p><p>通过上面代码的执行结果，我们可以得知: <strong>主线程会等待所有的子线程执行结束再结束</strong></p><p>假如我们就让主线程执行 1 秒钟，子线程就销毁不再执行，那怎么办呢?</p><p>我们可以设置<strong>守护主线程</strong></p><p>守护主线程:</p><p>守护主线程就是主线程退出子线程销毁不再执行</p><p>设置守护主线程有两种方式：</p><ul><li>threading.Thread(target=show_info, daemon=True)</li><li>线程对象.setDaemon(True)</li></ul><p>设置守护主线程的示例代码:</p><pre><code class="python">import threadingimport time# 测试主线程是否会等待子线程执行完成以后程序再退出def show_info():    for i in range(5):        print(&quot;test:&quot;, i)        time.sleep(0.5)if __name__ == &#39;__main__&#39;:    # 创建子线程守护主线程    # daemon=True 守护主线程    # 守护主线程方式1    sub_thread = threading.Thread(target=show_info, daemon=True)    # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码    # 守护主线程方式2    # sub_thread.setDaemon(True)    sub_thread.start()    # 主线程延时1秒    time.sleep(1)    print(&quot;over&quot;)</code></pre><p>执行结果:</p><pre><code class="python">test: 0test: 1over</code></pre><h3 id="线程之间共享全局变量"><a href="#线程之间共享全局变量" class="headerlink" title="线程之间共享全局变量"></a>线程之间共享全局变量</h3><p>线程之间共享全局变量，好处是可以对全局变量的数据进行共享。</p><p>需求:</p><p>定义一个列表类型的全局变量</p><p>创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务</p><p>查看线程之间是否共享全局变量数据</p><pre><code class="python">import threadingimport time# 定义全局变量my_list = list()# 写入数据任务def write_data():    for i in range(5):        my_list.append(i)        time.sleep(0.1)    print(&quot;write_data:&quot;, my_list)# 读取数据任务def read_data():    print(&quot;read_data:&quot;, my_list)if __name__ == &#39;__main__&#39;:    # 创建写入数据的线程    write_thread = threading.Thread(target=write_data)    # 创建读取数据的线程    read_thread = threading.Thread(target=read_data)    write_thread.start()    # 延时    # time.sleep(1)    # 主线程等待写入线程执行完成以后代码在继续往下执行    write_thread.join()    print(&quot;开始读取数据啦&quot;)    read_thread.start()</code></pre><p>执行结果:</p><pre><code class="python">write_data: [0, 1, 2, 3, 4]开始读取数据啦read_data: [0, 1, 2, 3, 4]</code></pre><h3 id="线程之间共享全局变量数据出现错误问题"><a href="#线程之间共享全局变量数据出现错误问题" class="headerlink" title="线程之间共享全局变量数据出现错误问题"></a>线程之间共享全局变量数据出现错误问题</h3><p>线程之间共享全局变量可能会导致数据出现错误问题，可以使用线程同步方式来解决这个问题。</p><p>需求:</p><p>定义两个函数，实现循环 100 万次，每循环一次给全局变量加 1</p><p>创建两个子线程执行对应的两个函数，查看计算后的结果</p><pre><code class="python">import threading# 定义全局变量g_num = 0# 循环一次给全局变量加1def sum_num1():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)# 循环一次给全局变量加1def sum_num2():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    # 启动线程    second_thread.start()</code></pre><p>执行结果:</p><pre><code class="python">sum1: 1210949sum2: 1496035</code></pre><p><strong>注意点:</strong></p><p><strong>多线程同时对全局变量操作数据发生了错误</strong></p><p><strong>错误分析:</strong></p><p>两个线程 first_thread 和 second_thread 都要对全局变量 g_num(默认是 0)进行加 1 运算，但是由于是多线程同时操作，有可能出现下面情况：</p><ol><li>在 g_num=0 时，first_thread 取得 g_num=0。此时系统把 first_thread 调度为”sleeping”状态，把 second_thread 转换为”running”状态，t2 也获得 g_num=0</li><li>然后 second_thread 对得到的值进行加 1 并赋给 g_num，使得 g_num=1</li><li>然后系统又把 second_thread 调度为”sleeping”，把 first_thread 转为”running”。线程 t1 又把它之前得到的 0 加 1 后赋值给 g_num。</li><li>这样导致虽然 first_thread 和 first_thread 都对 g_num 加 1，但结果仍然是 g_num=1</li></ol><p><strong>全局变量数据错误的解决办法:</strong></p><p><strong>线程同步</strong>: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机</p><p><strong>线程同步的方式</strong>:</p><ul><li><p><strong>线程等待(join)</strong></p></li><li><p><strong>互斥锁</strong></p></li></ul><p>线程等待的示例代码:</p><pre><code class="python">import threading# 定义全局变量g_num = 0# 循环1000000次每次给全局变量加1def sum_num1():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)# 循环1000000次每次给全局变量加1def sum_num2():    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程    # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行    first_thread.join()    # 启动线程    second_thread.start()</code></pre><p>执行结果:</p><pre><code class="python">sum1: 1000000sum2: 2000000</code></pre><h2 id="互斥锁与死锁"><a href="#互斥锁与死锁" class="headerlink" title="互斥锁与死锁"></a>互斥锁与死锁</h2><h3 id="互斥锁的概念"><a href="#互斥锁的概念" class="headerlink" title="互斥锁的概念"></a>互斥锁的概念</h3><p>互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。</p><ul><li>互斥锁的作用就是保证同一时刻只能有一个线程去操作共享数据，保证共享数据不会出现错误问题</li><li>使用互斥锁的好处确保某段关键代码只能由一个线程从头到尾完整地去执行</li><li>使用互斥锁会影响代码的执行效率，<strong>多任务改成了单任务执行</strong></li><li>互斥锁如果没有使用好容易出现<strong>死锁</strong>的情况</li></ul><p>注意:</p><p>互斥锁是<strong>多个线程一起去抢</strong>，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。</p><h3 id="互斥锁的使用"><a href="#互斥锁的使用" class="headerlink" title="互斥锁的使用"></a>互斥锁的使用</h3><p>threading 模块中定义了 Lock 变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。</p><p>互斥锁使用步骤:</p><pre><code class="python"># 创建锁mutex = threading.Lock()# 上锁mutex.acquire()...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定...# 释放锁mutex.release()</code></pre><p><strong>注意点:</strong></p><ul><li>acquire 和 release 方法之间的代码同一时刻只能有一个线程去操作</li><li>如果在调用 acquire 方法的时候 其他线程已经使用了这个互斥锁，那么此时 acquire 方法会堵塞，直到这个互斥锁释放后才能再次上锁。</li></ul><h3 id="互斥锁示例"><a href="#互斥锁示例" class="headerlink" title="互斥锁示例"></a>互斥锁示例</h3><p>使用互斥锁完成 2 个线程对同一个全局变量各加 100 万次的操作</p><pre><code class="python">import threading# 定义全局变量g_num = 0# 创建全局互斥锁lock = threading.Lock()# 循环一次给全局变量加1def sum_num1():    # 上锁    lock.acquire()    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum1:&quot;, g_num)    # 释放锁    lock.release()# 循环一次给全局变量加1def sum_num2():    # 上锁    lock.acquire()    for i in range(1000000):        global g_num        g_num += 1    print(&quot;sum2:&quot;, g_num)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 创建两个线程    first_thread = threading.Thread(target=sum_num1)    second_thread = threading.Thread(target=sum_num2)    # 启动线程    first_thread.start()    second_thread.start()    # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待    # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行</code></pre><p>执行结果:</p><pre><code class="python">sum1: 1000000sum2: 2000000</code></pre><p>说明:</p><p>通过执行结果可以地址互斥锁能够保证多个线程访问共享数据不会出现数据错误问题</p><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>死锁: 一直等待对方释放锁的情景就是死锁</p><ul><li>使用互斥锁的时候需要注意死锁的问题，要在合适的地方注意释放锁。</li><li>死锁一旦产生就会造成应用程序的停止响应，应用程序无法再继续往下执行了。</li></ul><p>死锁的结果</p><p>会造成应用程序的停止响应，不能再处理其它任务了。</p><p><strong>死锁示例</strong></p><p>需求:</p><p>根据下标在列表中取值, 保证同一时刻只能有一个线程去取值</p><pre><code class="python">import threadingimport time# 创建互斥锁lock = threading.Lock()# 根据下标去取值， 保证同一时刻只能有一个线程去取值def get_value(index):    # 上锁    lock.acquire()    print(threading.current_thread())    my_list = [3,6,8,1]    # 判断下标释放越界    if index &gt;= len(my_list):        print(&quot;下标越界:&quot;, index)        return    value = my_list[index]    print(value)    time.sleep(0.2)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 模拟大量线程去执行取值操作    for i in range(30):        sub_thread = threading.Thread(target=get_value, args=(i,))        sub_thread.start()</code></pre><p><strong>避免死锁</strong></p><p>在合适的地方释放锁</p><pre><code class="python">import threadingimport time# 创建互斥锁lock = threading.Lock()# 根据下标去取值， 保证同一时刻只能有一个线程去取值def get_value(index):    # 上锁    lock.acquire()    print(threading.current_thread())    my_list = [3,6,8,1]    if index &gt;= len(my_list):        print(&quot;下标越界:&quot;, index)        # 当下标越界需要释放锁，让后面的线程还可以取值        lock.release()        return    value = my_list[index]    print(value)    time.sleep(0.2)    # 释放锁    lock.release()if __name__ == &#39;__main__&#39;:    # 模拟大量线程去执行取值操作    for i in range(30):        sub_thread = threading.Thread(target=get_value, args=(i,))        sub_thread.start()</code></pre><h2 id="进程和线程的对比"><a href="#进程和线程的对比" class="headerlink" title="进程和线程的对比"></a>进程和线程的对比</h2><h3 id="关系对比"><a href="#关系对比" class="headerlink" title="关系对比"></a>关系对比</h3><ul><li>线程是依附在进程里面的，没有进程就没有线程。</li><li>一个进程默认提供一条线程，进程可以创建多个线程。</li></ul><h3 id="区别对比"><a href="#区别对比" class="headerlink" title="区别对比"></a>区别对比</h3><ul><li><p>进程之间不共享全局变量</p></li><li><p>线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步</p></li><li><p>创建进程的资源开销要比创建线程的资源开销要大</p></li><li><p><strong>进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位</strong></p></li><li><p>线程不能够独立执行，必须依存在进程中</p></li><li><p><strong>多进程开发比单进程多线程开发稳定性要强</strong></p></li></ul><h3 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h3><ul><li>进程优缺点:<ul><li>优点：可以用多核</li><li>缺点：资源开销大</li></ul></li><li>线程优缺点:<ul><li>优点：资源开销小</li><li>缺点：不能使用多核</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>进程和线程都是完成多任务的一种方式</li><li>多进程要比多线程消耗的资源多，但是多进程开发比单进程多线程开发稳定性要强，某个进程挂掉不会影响其它进程。</li><li>多进程可以使用 cpu 的多核运行，多线程可以共享全局变量。</li><li>线程不能单独执行必须依附在进程里面</li><li>计算密集型的应用使用多进程，有效利用多核提升运算效率；其他应用（文件写入、文件下载、IO 操作）使用多线程，更加节省资源并且可以完成多任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多任务 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用QT编译RTKLIB的GUI程序</title>
      <link href="/2020/08/10/%E4%BD%BF%E7%94%A8QT%E7%BC%96%E8%AF%91RTKLIB-GUI%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/08/10/%E4%BD%BF%E7%94%A8QT%E7%BC%96%E8%AF%91RTKLIB-GUI%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近期在基于 RTKLIB 改了一些代码，但一直是基于源码运行的，于是便想着编译一个自己的图形用户界面。查阅 manual 2.4.2 手册上使用的是  Embarcadero C++ Builder XE2 or XE3，上网查了一下实在是太古老，无奈放弃。<br>之后使用 QT 编译成功，写下这篇博客记录一下方法和注意事项。</p></blockquote><a id="more"></a><h2 id="所用版本"><a href="#所用版本" class="headerlink" title="所用版本"></a>所用版本</h2><p>这篇博客基于的是 demo5 源码版本，链接见<a href="http://rtkexplorer.com/downloads/rtklib-code/" target="_blank" rel="noopener">http://rtkexplorer.com/downloads/rtklib-code/</a>。<br>QT 使用的是 5.14.2，国内镜像链接见<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.14/5.14.2/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.14/5.14.2/</a>。<br>本文只针对以上版本记录编译过程中遇到的问题。其实版本之间大同小异，博主之前也用别的版本编译成功过，希望大家举一反三。</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>首先使用 QT creator 打开源码根目录下的.pro 文件，创建工程。<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/1.png" alt=""></p><p>这里使用的是 MinGW 32 位，注意区分。<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/2.png" alt=""></p><p>以 rtkpost 软件为例，选择 Release 构建下的 rtkpost_qt。<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/3.png" alt=""></p><p>按绿色三角或 Ctrl+R 开始运行。</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><p>第一个问题发现提示</p><blockquote><p>:-1: error: No rule to make target ‘rcv/ss2.c’, needed by ‘release/ss2.o’. Stop.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/4.png" alt=""></p><p>这个问题是由于之前的代码中有这个文件，而最新的版本已经去掉，我们可以在 src.pro 中找到这一条将其注释掉。</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/5.png" alt=""></p><p>重新运行程序。</p><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><p>发现提示</p><blockquote><p>:-1: error: No rule to make target ‘../../src/debug/libRTKLib.a’, needed by ‘release/rtknavi_qt.exe’. Stop.<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/6.png" alt=""></p></blockquote><p>这是因为缺少库文件 libRTKLib.a，这个文件就是我们源代码生成的库文件，当你改了源码之后，这个也会随之改变，所以千万不要乱用。<br>这个文件可以在 Debug 模式下生成，我们切到 Debug 模式下重新运行。<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/7.png" alt=""></p><h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h2><p>发现一连串报错</p><blockquote><p>D:\Document\RTK\RTKLIB-demo5_for_QT\RTKLIB-demo5..\RTKLIB-demo5\app\rtkconv_qt\codeopt.cpp:333: error: ‘FREQTYPE_L7’ was not declared in this scope</p></blockquote><pre><code> E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7));</code></pre><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/8.png" alt=""></p><p>这是由于 demo5 版本在头文件改了一些配置，源码编译文件改了，但是 qt 编译文件还没有改，我们可以找到 app&gt;rtkconv&gt;codeopt.cpp 查看它是怎么使用的，我们 rtkconv_qt&gt;codeopt.cpp 只要随之改变就好</p><pre><code class="c++">    E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8));    E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8));    E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8));    改为    E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab));    E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab));    E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab));</code></pre><pre><code class="c++">    J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    改为    J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6));</code></pre><pre><code class="c++">    C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    改为    C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6));</code></pre><pre><code class="c++">    I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9));    I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9));    I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9));    I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9));    改为    I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S));    I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S));    I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S));    I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S));</code></pre><p>同样 convopt.cpp 下也有这个问题，也采用上面的方法改完，重新运行。<br>编译成功，我们已经可以看到 Debug 模式下的程序界面。</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/9.png" alt=""></p><p>之后我们在</p><blockquote><p>D:\Document\RTK\RTKLIB-demo5_for_QT\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Debug\src\debug</p></blockquote><p>路径下找到我们编译的 libRTKLib.a</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/10.png" alt=""></p><p>将其复制到</p><blockquote><p>D:\Document\RTK\RTKLIB-demo5_for_QT\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Release\src\debug</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/11.png" alt=""></p><p>且回到 Release 模式，重新运行，即可成功。</p><h2 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h2><p>这样直接生成的程序是不能直接运行的，需要进行打包。<br>打开 Qt 版本号 for Desktop (MinGW 版本号 32bit)命令行，注意与一开始选择的对应。</p><p>接着输入命令行，cd /d 路径(指的是需要打包的 exe 程序目录，就是刚才拷贝出来的 exe 程序所在的目录)，回车后，</p><p>输入如下命令行：windeployqt 程序名 敲击回车。这一步操作是将所需的库文件全都拷贝到 exe 程序的当前文件。</p><p>现在，便可以双击 exe 直接运行软件了！</p><p>若你要将程序给别人使用，一定要注意 dll 文件也要一起打包哦。</p>]]></content>
      
      
      <categories>
          
          <category> GNSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNSS </tag>
            
            <tag> RTKlib </tag>
            
            <tag> RTK </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTKlib源码解析-高精度GNSS定位处理过程</title>
      <link href="/2020/07/15/RTKlib-%E5%85%B3%E4%BA%8E%E9%AB%98%E7%B2%BE%E5%BA%A6GPS%E5%8A%A8%E6%80%81%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/07/15/RTKlib-%E5%85%B3%E4%BA%8E%E9%AB%98%E7%B2%BE%E5%BA%A6GPS%E5%8A%A8%E6%80%81%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>RTKLIB 是用于 GNSS（全球导航卫星系统）的标准和精确定位的开源程序包。二进制文件以及完整原始代码见<a href="http://www.rtklib.com/" target="_blank" rel="noopener">RTKlib.com</a>。<br>Demo5 是 RTKLIB 代码的修改版本，针对低成本的单频和双频接收器而定制，旨在提高性能。二进制文件以及完整原始代码见<a href="http://rtkexplorer.com/downloads/rtklib-code/" target="_blank" rel="noopener">http://rtkexplorer.com/downloads/rtklib-code/</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/RTKLIB.jpg" alt="RTKlib流程" title="RTKlib流程图"></p><a id="more"></a><p>本文主要介绍用 RTKLIB 实现精密动态定位的过程，该过程包括观测文件和导航文件的读取、基准站位置的计算、流动站位置的求解、运行结果的输出。</p><h2 id="主函数配置"><a href="#主函数配置" class="headerlink" title="主函数配置"></a>主函数配置</h2><h2 id="解算流程"><a href="#解算流程" class="headerlink" title="解算流程"></a>解算流程</h2><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><h2 id="求解基站参数"><a href="#求解基站参数" class="headerlink" title="求解基站参数"></a>求解基站参数</h2><h2 id="相对动态定位"><a href="#相对动态定位" class="headerlink" title="相对动态定位"></a>相对动态定位</h2>]]></content>
      
      
      <categories>
          
          <category> GNSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNSS </tag>
            
            <tag> GPS </tag>
            
            <tag> BDS </tag>
            
            <tag> RTKlib </tag>
            
            <tag> RTK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法汇总</title>
      <link href="/2020/05/26/Markdown%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2020/05/26/Markdown%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息，例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等。</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png" alt="Markdown"></p><a id="more"></a><h3 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h3><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加<kbd>#+space</kbd>号即可。<br>使用 <kbd>#</kbd> 号可表示 1-6 级标题，一级标题对应一个 <kbd>#</kbd> 号，二级标题对应两个 <kbd>#</kbd> 号，以此类推。</p><pre><code class="markdown"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><h3 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h3><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。</p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>Markdown 可以使用以下几种字体：</p><pre><code class="markdown">_斜体文本__斜体文本_**粗体文本****粗体文本****_粗斜体文本_****_粗斜体文本_**</code></pre><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code class="markdown">---------------</code></pre><hr><hr><hr><hr><hr><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <kbd>~~</kbd> 即可，实例如下：</p><pre><code class="markdown">GOOGLE.COM~~BAIDU.COM~~</code></pre><p>GOOGLE.COM<br><del>BAIDU.COM</del></p><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p>下划线可以通过 HTML 标签来实现：</p><pre><code class="markdown">&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p><u>带下划线文本</u></p><h3 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h3><p>Markdown 支持有序列表和无序列表。</p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>无序列表使用星号<kbd>*</kbd>、加号<kbd>+</kbd>或是减号<kbd>-</kbd>作为列表标记，这些标记后面要添加一个<kbd>space</kbd>，然后再填写内容：</p><pre><code class="markdown">- 第一项- 第二项- 第三项* 第一项* 第二项* 第三项- 第一项- 第二项- 第三项</code></pre><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表使用数字并加上<kbd>space</kbd>. 号来表示，如：</p><pre><code class="markdown">1. 第一项2. 第二项3. 第三项</code></pre><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h3><p>Markdown 区块引用是在段落开头使用 <kbd>></kbd>符号 ，然后后面紧跟一个<kbd>space</kbd>符号：</p><pre><code class="markdown">&gt; 区块引用</code></pre><blockquote><p>区块引用</p></blockquote><h3 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h3><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来<kbd>`</kbd>，例如：</p><pre><code class="markdown">`printf()` 函数</code></pre><p><code>printf()</code> 函数<br>代码区块使用 4 个空格或者一个制表符<kbd>Tab</kbd>。<br>也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）</p><h3 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h3><p>链接使用方法如下：</p><pre><code class="markdown">[链接名称](链接地址)或者&lt;链接地址&gt;[FLAG&#39;s blog](www.flaglee.cn)</code></pre><p><a href="www.flaglee.cn">FLAG’s blog</a></p><p>高级链接<br>可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code class="markdown">这个链接用 1 作为网址变量 [Google][1]然后在文档的结尾为变量赋值（网址）[1]: http://www.google.com/</code></pre><h3 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h3><p>Markdown 图片语法格式如下：</p><pre><code class="markdown">![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![Markdown](https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png &quot;markdown图标&quot;)</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png" alt="Markdown" title="markdown图标"></p><h3 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h3><p>Markdown 制作表格使用 <kbd>|</kbd> 来分隔不同的单元格，使用 <kbd>-</kbd> 来分隔表头和其他行。</p><p>语法格式如下：</p><pre><code class="markdown">| 表头   | 表头   || ------ | ------ || 单元格 | 单元格 || 单元格 | 单元格 |</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对齐方式</p><p>可以设置表格的对齐方式：</p><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。</p><pre><code class="markdown">| 左对齐 | 右对齐 | 居中对齐 || :----- | -----: | :------: || 单元格 | 单元格 |  单元格  || 单元格 | 单元格 |  单元格  |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h3 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h3><h4 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h4><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><pre><code class="markdown">目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等，如：使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code class="markdown">**文本加粗**\*\* 正常显示星号 \*\*</code></pre><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/26/hello-world/"/>
      <url>/2020/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Powered-Hexo-brightgreen.svg" alt="Markdown"></a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
