<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python多任务编程：进程和线程</title>
      <link href="/2020/09/04/Python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/09/04/Python%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一般写的程序都是单任务的，也就是说一个函数或者方法执行完成之后另外一个函数或者方法才能执行，要想实现多个任务同时执行的操作就需要使用多任务。<br>多任务的最大好处是充分利用 CPU 资源，提高程序的执行效率。</p></blockquote><a id="more"></a><h2 id="多任务的概念"><a href="#多任务的概念" class="headerlink" title="多任务的概念"></a>多任务的概念</h2><p>多任务是指在同一时间内执行多个任务。多任务能充分利用 CPU 资源，提高程序的执行效率，让程序具备处理多个任务的能力。</p><p>多任务的执行方式：</p><ul><li>并发</li><li>并行</li></ul><p><strong>并发</strong></p><pre><code>任务数 &gt; CPU核心数，在一段时间内交替去执行任务。对于单核cpu处理多任务,操作系统轮流让各个软件交替执行。假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。</code></pre><p><strong>并行</strong></p><pre><code>任务数 &lt; CPU核心数，对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。并行才是多个任务真正意义一起执行。</code></pre><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><p>一个正在运行的程序或者软件就是一个进程，它是操作系统进行资源分配的基本单位，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。</p><p>比如:现实生活中的公司可以理解成是一个进程，公司提供办公资源(电脑、办公桌椅等)，真正干活的是员工，员工可以理解成线程。</p><p><strong>一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。</strong></p><h3 id="多进程的使用"><a href="#多进程的使用" class="headerlink" title="多进程的使用"></a>多进程的使用</h3><p><strong>1.导入进程包</strong></p><pre><code class="python">#导入进程包import multiprocessing</code></pre><p><strong>2.Process 进程类的说明</strong><br>Process([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>group：指定进程组，目前只能使用 None</li><li>target：执行的目标任务名</li><li>name：进程名字</li><li>args：以元组方式给执行任务传参</li><li>kwargs：以字典方式给执行任务传参</li></ul><p>Process 创建的实例对象的常用方法:</p><ul><li>start()：启动子进程实例（创建子进程）</li><li>join()：等待子进程执行结束</li><li>terminate()：不管任务是否完成，立即终止子进程</li></ul><p>Process 创建的实例对象的步骤:</p><ul><li>导入进程包<ul><li>import multiprocessing</li></ul></li><li>创建子进程并指定执行的任务<ul><li>sub_process = multiprocessing.Process (target=任务名)</li></ul></li><li>启动进程执行任务<ul><li>sub_process.start()</li></ul></li></ul><p><strong>多进程完成多任务的代码</strong></p><pre><code class="python">import multiprocessingimport time# 跳舞任务def dance():    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)# 唱歌任务def sing():    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p>执行结果:</p><pre><code class="python">唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...唱歌中...跳舞中...</code></pre><h3 id="获取进程编号"><a href="#获取进程编号" class="headerlink" title="获取进程编号"></a>获取进程编号</h3><p><strong>1.获取进程编号的目的</strong></p><p>获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。</p><p>获取进程编号的两种操作</p><ul><li>获取当前进程编号</li><li>获取当前父进程编号</li></ul><p>获取当前进程编号方法</p><ul><li>os.getpid()<ul><li>获取当前父进程编号</li></ul></li><li>os.getppid()<ul><li>获取进程编号可以查看父子进程的关系</li></ul></li></ul><p><strong>2.获取当前进程编号</strong></p><p>os.getpid() 表示获取当前进程编号</p><p>示例代码:</p><pre><code class="python">import multiprocessingimport timeimport os# 跳舞任务def dance():    # 获取当前进程的编号    print(&quot;dance:&quot;, os.getpid())    # 获取当前进程    print(&quot;dance:&quot;, multiprocessing.current_process())    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)        # 扩展:根据进程编号杀死指定进程        os.kill(os.getpid(), 9)# 唱歌任务def sing():    # 获取当前进程的编号    print(&quot;sing:&quot;, os.getpid())    # 获取当前进程    print(&quot;sing:&quot;, multiprocessing.current_process())    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 获取当前进程的编号    print(&quot;main:&quot;, os.getpid())    # 获取当前进程    print(&quot;main:&quot;, multiprocessing.current_process())    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p>执行结果:</p><pre><code class="python">main: 70763main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70768dance: &lt;Process(myprocess1, started)&gt;跳舞中...sing: 70769sing: &lt;Process(Process-2, started)&gt;唱歌中...唱歌中...唱歌中...唱歌中...唱歌中...</code></pre><p>**3.获取当前父进程编号</p><p>os.getppid() 表示获取当前父进程编号</p><p>示例代码:</p><pre><code class="python">import multiprocessingimport timeimport os# 跳舞任务def dance():    # 获取当前进程的编号    print(&quot;dance:&quot;, os.getpid())    # 获取当前进程    print(&quot;dance:&quot;, multiprocessing.current_process())    # 获取父进程的编号    print(&quot;dance的父进程编号:&quot;, os.getppid())    for i in range(5):        print(&quot;跳舞中...&quot;)        time.sleep(0.2)        # 扩展:根据进程编号杀死指定进程        os.kill(os.getpid(), 9)# 唱歌任务def sing():    # 获取当前进程的编号    print(&quot;sing:&quot;, os.getpid())    # 获取当前进程    print(&quot;sing:&quot;, multiprocessing.current_process())    # 获取父进程的编号    print(&quot;sing的父进程编号:&quot;, os.getppid())    for i in range(5):        print(&quot;唱歌中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 获取当前进程的编号    print(&quot;main:&quot;, os.getpid())    # 获取当前进程    print(&quot;main:&quot;, multiprocessing.current_process())    # 创建跳舞的子进程    # group: 表示进程组，目前只能使用None    # target: 表示执行的目标任务名(函数名、方法名)    # name: 进程名称, 默认是Process-1, .....    dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;)    sing_process = multiprocessing.Process(target=sing)    # 启动子进程执行对应的任务    dance_process.start()    sing_process.start()</code></pre><p>执行结果：</p><pre><code class="python">main: 70860main: &lt;_MainProcess(MainProcess, started)&gt;dance: 70861dance: &lt;Process(myprocess1, started)&gt;dance的父进程编号: 70860跳舞中...sing: 70862sing: &lt;Process(Process-2, started)&gt;sing的父进程编号: 70860唱歌中...唱歌中...唱歌中...唱歌中...唱歌中...</code></pre><h3 id="进程执行带有参数的任务"><a href="#进程执行带有参数的任务" class="headerlink" title="进程执行带有参数的任务"></a>进程执行带有参数的任务</h3><p><strong>1. 进程执行带有参数的任务的介绍</strong></p><p>前面使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢?</p><p>Process 类执行任务并给任务传参数有两种方式:</p><ul><li>元组方式传参(args): 元组方式传参一定要和参数的顺序保持一致。</li><li>字典方式传参(kwargs): 字典方式传参字典中的 key 一定要和参数名保持一致。</li></ul><p><strong>2. args 参数的使用</strong></p><p>示例代码:</p><pre><code class="python">import multiprocessingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子进程    # args: 以元组的方式给任务传入参数    sub_process = multiprocessing.Process(target=task, args=(5,))    sub_process.start()</code></pre><p>执行结果:</p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><p><strong>3. kwargs 参数的使用</strong></p><p>示例代码:</p><pre><code class="python">import multiprocessingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子进程    # kwargs: 表示以字典方式传入参数    sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3})    sub_process.start()</code></pre><p>执行结果:</p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><h3 id="进程之间不共享全局变量"><a href="#进程之间不共享全局变量" class="headerlink" title="进程之间不共享全局变量"></a>进程之间不共享全局变量</h3><p>创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。</p><p>示例代码：</p><pre><code class="python">import multiprocessingimport time# 定义全局变量g_list = list()# 添加数据的任务def add_data():    for i in range(5):        g_list.append(i)        print(&quot;add:&quot;, i)        time.sleep(0.2)    # 代码执行到此，说明数据添加完成    print(&quot;add_data:&quot;, g_list)def read_data():    print(&quot;read_data&quot;, g_list)if __name__ == &#39;__main__&#39;:    # 创建添加数据的子进程    add_data_process = multiprocessing.Process(target=add_data)    # 创建读取数据的子进程    read_data_process = multiprocessing.Process(target=read_data)    # 启动子进程执行对应的任务    add_data_process.start()    # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据    add_data_process.join()    read_data_process.start()    print(&quot;main:&quot;, g_list)    # 总结: 多进程之间不共享全局变量</code></pre><p>执行结果:</p><pre><code class="python">add: 0add: 1add: 2add: 3add: 4add_data: [0, 1, 2, 3, 4]main: []read_data []</code></pre><p>进程之间不共享全局变量的解释效果图:</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png" alt=""></p><h3 id="主进程会等待所有的子进程执行结束再结束"><a href="#主进程会等待所有的子进程执行结束再结束" class="headerlink" title="主进程会等待所有的子进程执行结束再结束"></a>主进程会等待所有的子进程执行结束再结束</h3><p>为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是主进程退出子进程销毁，不让主进程再等待子进程去执行。</p><p>设置守护主进程方式：</p><ul><li>子进程对象.daemon = True</li></ul><p>销毁子进程方式：</p><ul><li>子进程对象.terminate()</li></ul><p>假如我们现在创建一个子进程，这个子进程执行完大概需要 2 秒钟，现在让主进程执行 0.5 秒钟就退出程序，查看一下执行结果，示例代码如下:</p><pre><code class="python">import multiprocessingimport time# 定义进程所需要执行的任务def task():    for i in range(10):        print(&quot;任务执行中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建子进程    sub_process = multiprocessing.Process(target=task)    sub_process.start()    # 主进程延时0.5秒钟    time.sleep(0.5)    print(&quot;over&quot;)    exit()    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出</code></pre><p>执行结果:</p><pre><code class="python">任务执行中...任务执行中...任务执行中...over任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...任务执行中...</code></pre><p><strong>说明:</strong></p><p>通过上面代码的执行结果，我们可以得知: 主进程会等待所有的子进程执行结束再结束</p><p>假如我们就让主进程执行 0.5 秒钟，子进程就销毁不再执行，那怎么办呢?</p><p>我们可以设置守护主进程 或者 在主进程退出之前 让子进程销毁</p><p><strong>守护主进程:</strong></p><ul><li>守护主进程就是主进程退出子进程销毁不再执行</li></ul><p><strong>子进程销毁:</strong></p><ul><li>子进程执行结束</li></ul><p>保证主进程正常退出的示例代码:</p><pre><code class="python">import multiprocessingimport time# 定义进程所需要执行的任务def task():    for i in range(10):        print(&quot;任务执行中...&quot;)        time.sleep(0.2)if __name__ == &#39;__main__&#39;:    # 创建子进程    sub_process = multiprocessing.Process(target=task)    # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程    # sub_process.daemon = True    sub_process.start()    time.sleep(0.5)    print(&quot;over&quot;)    # 让子进程销毁    sub_process.terminate()    exit()    # 总结： 主进程会等待所有的子进程执行完成以后程序再退出    # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁</code></pre><p>执行结果:</p><pre><code class="python">任务执行中...任务执行中...任务执行中...over</code></pre><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h3><p>在 Python 中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。</p><p>线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要 cpu 进行调度 ，也就是说线程是 cpu 调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。</p><h3 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h3><p><strong>1. 导入线程模块</strong></p><pre><code class="python">#导入线程模块import threading</code></pre><p><strong>2. 线程类 Thread 参数说明</strong></p><p>Thread([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>group: 线程组，目前只能使用 None</li><li>target: 执行的目标任务名</li><li>args: 以元组的方式给执行任务传参</li><li>kwargs: 以字典方式给执行任务传参</li><li>name: 线程名，一般不用设置</li></ul><p><strong>3. 启动线程</strong></p><ul><li><p>导入线程模块</p><ul><li>import threading</li></ul></li><li><p>创建子线程并指定执行的任务</p><ul><li>sub_thread = threading.Thread(target=任务名)</li></ul></li><li><p>启动线程执行任务</p><ul><li>sub_thread.start()</li></ul></li></ul><p>示例代码：</p><pre><code class="python">import threadingimport time# 唱歌任务def sing():    # 扩展： 获取当前线程    # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread())    for i in range(3):        print(&quot;正在唱歌...%d&quot; % i)        time.sleep(1)# 跳舞任务def dance():    # 扩展： 获取当前线程    # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread())    for i in range(3):        print(&quot;正在跳舞...%d&quot; % i)        time.sleep(1)if __name__ == &#39;__main__&#39;:    # 扩展： 获取当前线程    # print(&quot;当前执行的线程为：&quot;, threading.current_thread())    # 创建唱歌的线程    # target： 线程执行的函数名    sing_thread = threading.Thread(target=sing)    # 创建跳舞的线程    dance_thread = threading.Thread(target=dance)    # 开启线程    sing_thread.start()    dance_thread.start()</code></pre><p>执行结果：</p><pre><code class="python">正在唱歌...0正在跳舞...0正在唱歌...1正在跳舞...1正在唱歌...2正在跳舞...2</code></pre><h3 id="线程执行带有参数的任务"><a href="#线程执行带有参数的任务" class="headerlink" title="线程执行带有参数的任务"></a>线程执行带有参数的任务</h3><p><strong>1. 线程执行带有参数的任务的介绍</strong></p><p>前面使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢?</p><p>Thread 类执行任务并给任务传参数有两种方式:</p><ul><li>元组方式传参(args) ：元组方式传参一定要和参数的顺序保持一致。</li><li>字典方式传参(kwargs)：字典方式传参字典中的 key 一定要和参数名保持一致。</li></ul><p><strong>2. args 参数的使用</strong></p><p>示例代码:</p><pre><code class="python">import threadingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子线程    # args: 以元组的方式给任务传入参数    sub_thread = threading.Thread(target=task, args=(5,))    sub_thread.start()</code></pre><p>执行结果:</p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行中..任务执行中..任务执行完成</code></pre><p><strong>3. kwargs 参数的使用</strong></p><p>示例代码:</p><pre><code class="python">import threadingimport time# 带有参数的任务def task(count):    for i in range(count):        print(&quot;任务执行中..&quot;)        time.sleep(0.2)    else:        print(&quot;任务执行完成&quot;)if __name__ == &#39;__main__&#39;:    # 创建子线程    # kwargs: 表示以字典方式传入参数    sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3})    sub_thread.start()</code></pre><p>执行结果:</p><pre><code class="python">任务执行中..任务执行中..任务执行中..任务执行完成</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多任务 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用QT编译RTKLIB的GUI程序</title>
      <link href="/2020/08/10/%E4%BD%BF%E7%94%A8QT%E7%BC%96%E8%AF%91RTKLIB-GUI%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/08/10/%E4%BD%BF%E7%94%A8QT%E7%BC%96%E8%AF%91RTKLIB-GUI%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近期在基于 RTKLIB 改了一些代码，但一直是基于源码运行的，于是便想着编译一个自己的图形用户界面。查阅 manual 2.4.2 手册上使用的是  Embarcadero C++ Builder XE2 or XE3，上网查了一下实在是太古老，无奈放弃。<br>之后使用 QT 编译成功，写下这篇博客记录一下方法和注意事项。</p></blockquote><a id="more"></a><h2 id="所用版本"><a href="#所用版本" class="headerlink" title="所用版本"></a>所用版本</h2><p>这篇博客基于的是 demo5 源码版本，链接见<a href="http://rtkexplorer.com/downloads/rtklib-code/" target="_blank" rel="noopener">http://rtkexplorer.com/downloads/rtklib-code/</a>。<br>QT 使用的是 5.14.2，国内镜像链接见<a href="https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.14/5.14.2/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.14/5.14.2/</a>。<br>本文只针对以上版本记录编译过程中遇到的问题。其实版本之间大同小异，博主之前也用别的版本编译成功过，希望大家举一反三。</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>首先使用 QT creator 打开源码根目录下的.pro 文件，创建工程。<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/1.png" alt=""></p><p>这里使用的是 MinGW 32 位，注意区分。<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/2.png" alt=""></p><p>以 rtkpost 软件为例，选择 Release 构建下的 rtkpost_qt。<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/3.png" alt=""></p><p>按绿色三角或 Ctrl+R 开始运行。</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><p>第一个问题发现提示</p><blockquote><p>:-1: error: No rule to make target ‘rcv/ss2.c’, needed by ‘release/ss2.o’. Stop.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/4.png" alt=""></p><p>这个问题是由于之前的代码中有这个文件，而最新的版本已经去掉，我们可以在 src.pro 中找到这一条将其注释掉。</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/5.png" alt=""></p><p>重新运行程序。</p><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><p>发现提示</p><blockquote><p>:-1: error: No rule to make target ‘../../src/debug/libRTKLib.a’, needed by ‘release/rtknavi_qt.exe’. Stop.<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/6.png" alt=""></p></blockquote><p>这是因为缺少库文件 libRTKLib.a，这个文件就是我们源代码生成的库文件，当你改了源码之后，这个也会随之改变，所以千万不要乱用。<br>这个文件可以在 Debug 模式下生成，我们切到 Debug 模式下重新运行。<br><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/7.png" alt=""></p><h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h2><p>发现一连串报错</p><blockquote><p>D:\Document\RTK\RTKLIB-demo5_for_QT\RTKLIB-demo5..\RTKLIB-demo5\app\rtkconv_qt\codeopt.cpp:333: error: ‘FREQTYPE_L7’ was not declared in this scope</p></blockquote><pre><code> E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7));</code></pre><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/8.png" alt=""></p><p>这是由于 demo5 版本在头文件改了一些配置，源码编译文件改了，但是 qt 编译文件还没有改，我们可以找到 app&gt;rtkconv&gt;codeopt.cpp 查看它是怎么使用的，我们 rtkconv_qt&gt;codeopt.cpp 只要随之改变就好</p><pre><code class="c++">    E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8));    E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8));    E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8));    改为    E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab));    E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab));    E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab));</code></pre><pre><code class="c++">    J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    改为    J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6));</code></pre><pre><code class="c++">    C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7));    C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6));    改为    C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2));    C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6));    C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6));</code></pre><pre><code class="c++">    I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9));    I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9));    I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9));    I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9));    改为    I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S));    I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S));    I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S));    I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S));</code></pre><p>同样 convopt.cpp 下也有这个问题，也采用上面的方法改完，重新运行。<br>编译成功，我们已经可以看到 Debug 模式下的程序界面。</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/9.png" alt=""></p><p>之后我们在</p><blockquote><p>D:\Document\RTK\RTKLIB-demo5_for_QT\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Debug\src\debug</p></blockquote><p>路径下找到我们编译的 libRTKLib.a</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/10.png" alt=""></p><p>将其复制到</p><blockquote><p>D:\Document\RTK\RTKLIB-demo5_for_QT\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Release\src\debug</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/rtklib_QT/11.png" alt=""></p><p>且回到 Release 模式，重新运行，即可成功。</p><h2 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h2><p>这样直接生成的程序是不能直接运行的，需要进行打包。<br>打开 Qt 版本号 for Desktop (MinGW 版本号 32bit)命令行，注意与一开始选择的对应。</p><p>接着输入命令行，cd /d 路径(指的是需要打包的 exe 程序目录，就是刚才拷贝出来的 exe 程序所在的目录)，回车后，</p><p>输入如下命令行：windeployqt 程序名 敲击回车。这一步操作是将所需的库文件全都拷贝到 exe 程序的当前文件。</p><p>现在，便可以双击 exe 直接运行软件了！</p><p>若你要将程序给别人使用，一定要注意 dll 文件也要一起打包哦。</p>]]></content>
      
      
      <categories>
          
          <category> GNSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNSS </tag>
            
            <tag> RTKlib </tag>
            
            <tag> RTK </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RTKlib源码解析-高精度GNSS定位处理过程</title>
      <link href="/2020/07/15/RTKlib-%E5%85%B3%E4%BA%8E%E9%AB%98%E7%B2%BE%E5%BA%A6GPS%E5%8A%A8%E6%80%81%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/07/15/RTKlib-%E5%85%B3%E4%BA%8E%E9%AB%98%E7%B2%BE%E5%BA%A6GPS%E5%8A%A8%E6%80%81%E5%AE%9A%E4%BD%8D%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>RTKLIB 是用于 GNSS（全球导航卫星系统）的标准和精确定位的开源程序包。二进制文件以及完整原始代码见<a href="http://www.rtklib.com/" target="_blank" rel="noopener">RTKlib.com</a>。<br>Demo5 是 RTKLIB 代码的修改版本，针对低成本的单频和双频接收器而定制，旨在提高性能。二进制文件以及完整原始代码见<a href="http://rtkexplorer.com/downloads/rtklib-code/" target="_blank" rel="noopener">http://rtkexplorer.com/downloads/rtklib-code/</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/FLAGLEE/imgHost/image/RTKLIB.jpg" alt="RTKlib流程" title="RTKlib流程图"></p><a id="more"></a><p>本文主要介绍用 RTKLIB 实现精密动态定位的过程，该过程包括观测文件和导航文件的读取、基准站位置的计算、流动站位置的求解、运行结果的输出。</p><h2 id="主函数配置"><a href="#主函数配置" class="headerlink" title="主函数配置"></a>主函数配置</h2><h2 id="解算流程"><a href="#解算流程" class="headerlink" title="解算流程"></a>解算流程</h2><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><h2 id="求解基站参数"><a href="#求解基站参数" class="headerlink" title="求解基站参数"></a>求解基站参数</h2><h2 id="相对动态定位"><a href="#相对动态定位" class="headerlink" title="相对动态定位"></a>相对动态定位</h2>]]></content>
      
      
      <categories>
          
          <category> GNSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNSS </tag>
            
            <tag> GPS </tag>
            
            <tag> BDS </tag>
            
            <tag> RTKlib </tag>
            
            <tag> RTK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法汇总</title>
      <link href="/2020/05/26/Markdown%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2020/05/26/Markdown%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息，例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等。</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png" alt="Markdown"></p><a id="more"></a><h3 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h3><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加<kbd>#+space</kbd>号即可。<br>使用 <kbd>#</kbd> 号可表示 1-6 级标题，一级标题对应一个 <kbd>#</kbd> 号，二级标题对应两个 <kbd>#</kbd> 号，以此类推。</p><pre><code class="markdown"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题</code></pre><h3 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h3><h4 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h4><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。</p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>Markdown 可以使用以下几种字体：</p><pre><code class="markdown">_斜体文本__斜体文本_**粗体文本****粗体文本****_粗斜体文本_****_粗斜体文本_**</code></pre><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code class="markdown">---------------</code></pre><hr><hr><hr><hr><hr><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <kbd>~~</kbd> 即可，实例如下：</p><pre><code class="markdown">GOOGLE.COM~~BAIDU.COM~~</code></pre><p>GOOGLE.COM<br><del>BAIDU.COM</del></p><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p>下划线可以通过 HTML 标签来实现：</p><pre><code class="markdown">&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p><u>带下划线文本</u></p><h3 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h3><p>Markdown 支持有序列表和无序列表。</p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>无序列表使用星号<kbd>*</kbd>、加号<kbd>+</kbd>或是减号<kbd>-</kbd>作为列表标记，这些标记后面要添加一个<kbd>space</kbd>，然后再填写内容：</p><pre><code class="markdown">- 第一项- 第二项- 第三项* 第一项* 第二项* 第三项- 第一项- 第二项- 第三项</code></pre><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表使用数字并加上<kbd>space</kbd>. 号来表示，如：</p><pre><code class="markdown">1. 第一项2. 第二项3. 第三项</code></pre><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h3><p>Markdown 区块引用是在段落开头使用 <kbd>></kbd>符号 ，然后后面紧跟一个<kbd>space</kbd>符号：</p><pre><code class="markdown">&gt; 区块引用</code></pre><blockquote><p>区块引用</p></blockquote><h3 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h3><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来<kbd>`</kbd>，例如：</p><pre><code class="markdown">`printf()` 函数</code></pre><p><code>printf()</code> 函数<br>代码区块使用 4 个空格或者一个制表符<kbd>Tab</kbd>。<br>也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）</p><h3 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h3><p>链接使用方法如下：</p><pre><code class="markdown">[链接名称](链接地址)或者&lt;链接地址&gt;[FLAG&#39;s blog](www.flaglee.cn)</code></pre><p><a href="www.flaglee.cn">FLAG’s blog</a></p><p>高级链接<br>可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code class="markdown">这个链接用 1 作为网址变量 [Google][1]然后在文档的结尾为变量赋值（网址）[1]: http://www.google.com/</code></pre><h3 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h3><p>Markdown 图片语法格式如下：</p><pre><code class="markdown">![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)![Markdown](https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png &quot;markdown图标&quot;)</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png" alt="Markdown" title="markdown图标"></p><h3 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h3><p>Markdown 制作表格使用 <kbd>|</kbd> 来分隔不同的单元格，使用 <kbd>-</kbd> 来分隔表头和其他行。</p><p>语法格式如下：</p><pre><code class="markdown">| 表头   | 表头   || ------ | ------ || 单元格 | 单元格 || 单元格 | 单元格 |</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>对齐方式</p><p>可以设置表格的对齐方式：</p><p>-: 设置内容和标题栏居右对齐。<br>:- 设置内容和标题栏居左对齐。<br>:-: 设置内容和标题栏居中对齐。</p><pre><code class="markdown">| 左对齐 | 右对齐 | 居中对齐 || :----- | -----: | :------: || 单元格 | 单元格 |  单元格  || 单元格 | 单元格 |  单元格  |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h3 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h3><h4 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h4><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><pre><code class="markdown">目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等，如：使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code class="markdown">**文本加粗**\*\* 正常显示星号 \*\*</code></pre><p><strong>文本加粗</strong><br>** 正常显示星号 **</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/26/hello-world/"/>
      <url>/2020/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Powered-Hexo-brightgreen.svg" alt="Markdown"></a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
