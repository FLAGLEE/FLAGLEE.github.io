[{"title":"C语言中内存分区与内存管理详解","date":"2020-09-08T01:00:36.000Z","path":"2020/09/08/C中内存分区与内存管理详解/","text":"c 语言五大内存分区 栈区（stack）:由编译器自动分配与释放，存放函数的参数值，局部变量，临时变量等等，它们获取的方式都是由编译器自动执行的 堆区（heap）:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。一般由程序员分配与释放，基程序员不释放，程序结束时可能由操作系统回收（C/C++没有此等回收机制，Java/C#有），注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 全局/静态存储区：存放全局变量和静态变量（包括静态全局变量与静态局部变量），全局变量和静态变量的存储是放在一块儿的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。 文字常量区：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。 程序代码区：存放程序的二进制代码，内存由系统管理 c 语言五大内存分区栈区： 在函数中定义的变量存放的内存区域。 常见的 int、float、char 等变量均存放于栈区中，它的特点是由系统自动分配与释放，不需要程序员考虑资源回收的问题，方便简洁。 ps：栈区的地址分配是从内存的高地址开始向地地址分配。 堆区： 程序员通过指令自主向系统申请的内存区域，大小由程序员决定，它在使用完后同样需要程序员通过指令去释放该区域内存，否则将有可能出现内存的浪费与溢出。 C 语言中申请堆区指令为： int *p = (int *) malloc( N * sizeof(int) ); //分配N个int型（4字节） 的内存，即 4 * N 个字节 ps：但指针 p 存放于栈区。 C 语言中释放堆区指令为： free( p ); //注意此处参数为指针 使用中应该注意，尽量不要去修改 p 指针对应的地址值，否则在内存释放时将出现错误。（编译可通过，运行出现问题） 全局变量&amp;静态变量区： 全局变量与静态变量本应是两个概念，但由于它们在内存中存放的区域相同，所以将他们放在一起讨论。 全局变量： 位于所有函数外部定义的变量，在整个工程中可见，可修改。 静态变量： 位于所有函数内部定义的由 static 修饰的变量，仅在定义的函数中可见，可修改。（这是它与全局变量的关键区别） ps：静态变量仅在第一次创建时初始化一次，之后自动跳过初始化语句。 全局变量与静态变量均由系统分配和释放内存，若未对它们进行初始化操作，系统将自动将其值设置为 0。（堆区与栈区则不会） 文字常量区： 用于存放文字等不可修改的常量，由系统分配和释放内存。 常见的使用： char *s = &quot;HelloWorld&quot;;//该字符串 HelloWorld 即存放于文字常量区，不可修改 ps：但指针 s 存放于栈区。 pps：若在程序中尝试对其修改（例如尝试修改第一个字符 *s = ‘h’;），将出现编译可通过，运行报错的情况。 同时因注意它与 const 修饰的变量之间的区别： char aa = &#39;A&#39;;//aa存放于栈区 const char bb = &#39;B&#39;; //bb同样存放于栈区 const 修饰的变量仅仅用于告诉编译器 bb 是一个常量，如果后续的程序中有出现尝试修改 bb 的操作时，编译将报错。 这种写法主要是为了防止程序员在后续的代码中误操作 bb 变量而添加的一个约束条件，并不会影响它存放的位置。 程序代码区： 用于存储程序编译连接后生成的二进制机器码指令的内存区域。该部分内容可通过反汇编操作将机器码转换为汇编语言。 C 语言例子： #include &lt;stdio.h&gt; static unsigned int val1 = 1; //val1存放在.data段 unsigned int val2 = 1; //初始化的全局变量存放在.data段 unsigned int val3 ; //未初始化的全局变量存放在.bss段 const unsigned int val4 = 1; //val4存放在.rodata（只读数据段） unsigned char Demo(unsigned int num) //num 存放在栈区 { char var = &quot;123456&quot;; //var存放在栈区，&quot;123456&quot;存放在常量区 unsigned int num1 = 1 ; //num1存放在栈区 static unsigned int num2 = 0; //num2存放在.data段 const unsigned int num3 = 7; //num3存放在栈区 void *p; p = malloc(8); //p存放在堆区 free(p); return 1; } void main() { unsigned int num = 0 ; num = Demo(num); //Demo()函数的返回值存放在栈区。 } 可执行程序程序三段一个程序的 3 个基本段：text 段，dtae 段，bss 段 text 段在内存中被映射为只读，但 date 段与 bss 段是可写的 text 段：代码段，就是放程序代码的，编译时确定，只读 date 段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域 bss 段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。 可执行程序程序三段与五大分区两者之间区别是： 代码段，数据段，堆栈段是 cpu 级别的概念 五大分区属于语言级别的概念，两者是不同的概念。 存储类型关键字定义变量与函数作用域与生命周期 auto 变量：函数的局部变量，如果没有声明为 static,函数中定义的局部变量全部为 auto 类型，auto 变量包括未加 static 声明的局部变量和函数的形参。在函数调用时系统会给他们分配存储空间，在函数调用结束后会自动释放这些空间。属于动态存储方式。 static 变量：用 static 声明的局部变量在调用结束后不会消失而保存原来的值。static 局部变量定义使用后值会存储下来。所以使用 static 局部变量定义只需要一次赋值。静态局部变量的作用域仅限于所定义的函数。但函数结束后变量的值会保留。直到整个程序运行结束。全局变量从定义开始作用于整个文件直至程序运行结束。 register 寄存器变量：寄存器变量可以提高 c 语言的执行效率，即将局部变量的值存入 CPU 的寄存器中。需要注意的是！！！：1.只有动态存储的变量（自动局部变量和形参）才可以作为寄存器变量来存储，局部静态变量不可以定义为寄存器变量。2.计算机的寄存器数目是有限的，所以不能定义任意多个寄存器变量。 extern 外部变量：即全局变量的外部表现形式，是在函数外部定义的变量。全局变量的作用域为从定义开始到源文件结束。exten 对该变量作外部变量声明，扩展变量作用域。 堆与栈的区别 申请方式 stack:栈;由系统自动分配，自动开辟空间 heap:由程序员自己申请并指明大小，c 中 malloc,c++中 new。如 p1=(char)malloc(10);p2=(char)new(10);但需要注意的是 p1,p2 本事是在栈中的 申请后系统的响应 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 堆：首先操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外对于大部分系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 语句才能正确的释放本内存空间。另外由于找到的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 申请大小的限制 栈：在 windows 下栈是向低地址扩展的数据结构，是一块连续的内存区域。所以栈的栈顶地址和最大容量是系统预先设定好的。在 windows 下栈的大小是 2M.因此能从栈获得的空间比较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是是由于系统用链表来存储空闲内存地址的，所以是不连续的。而链表的遍历方向是由低地址到高地址。堆得大小受限于计算机系统中有效的虚拟内存大小。相比较而言堆获得的空间比较灵活，也比较大。 申请效率的比较 栈：由系统自动分配，速度较快，但程序员是无法控制的。 堆：由 new 分配的内存，一般速度比较慢，而且比较容易产生内存碎片，不过用起来最方便。 堆和栈中的存储内容 栈：在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数。在大多数 c 编译器中，参数是由右往左压栈的，然后是函数中的局部变量。静态变量是不入栈的。当函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，，也就是主函数的下一条指令，程序由该点继续执行。 堆：一般是在堆的头部用一个字节存放堆得大小，其他内容自己安排。 存取效率的比较 1 char str1[]=&quot;aaaaaa&quot;; 2 char \\*str2=&quot;cccccc&quot;; 第一行是在运行时刻赋值的，第二行是在编译时就已经确定的，但在以后的存取过程中，在栈上的数组比指针指向的字符串快。 堆内存管理函数C 标准函数库提供了许多函数来实现对堆上内存管理，其中包括：malloc()函数，free()函数，calloc()函数和 realloc()函数。使用这些函数需要包含头文件 stdlib.h。它们的声明如下： void _malloc(size_t n); void free(void _ p); void _calloc(size_t n, size_t size); void _realloc(void \\* p, size_t n); malloc()malloc()函数可以从堆上获得指定字节的内存空间，其函数声明如下： void \\* malloc(size_t n); 其中，形参 n 为要求 分配的字节数。如果函数执行成功，malloc()返回获得内存空间的首地址；如果函数执行失败，那么返回值为 NULL。由于 malloc()函数值的类型为 void 型指针，因此，可以将其值类型转换后赋给任意类型指针，这样就可以通过操作该类型指针来操作从堆上获得的内存空间。 需要注意的是，malloc()函数分配得到的内存空间是未初始化的。因此，一般在使用该内存空间时，要调用另一个函数 memset 来将其初始化为全 0。memset 函数的声明如下： void _ memset (void _ p, int c, size_t n); 该函数可以将指定的内存空间按字节单位置为指定的字符 c。其中，p 为要清零的内存空间的首地址，c 为要设定的值，n 为被操作的内存空间的字节长度。如果要用 memset 清 0，变量 c 实参要为 0。malloc()函数和 memset 函数的操作语句一般如下： int _p = NULL; p = (int _) malloc(sizeof(int)); if (p == NULL){ printf(&quot;Can’t get memory!\\n&quot;); } memset(p, 0, sizeof(int)); 注意：通过 malloc()函数得到的堆内存必须使用 memset()函数来初始化。 示例代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(){ int _p = NULL; p = (int _) malloc(sizeof(int)); if (NULL == p){ printf(&quot;Can&#39;t get memory!\\n&quot;); return -1; } printf(&quot;%d\\n&quot;, *p); // 输出分配的空间上的值 memset(p, 0, sizeof(int)); // 将p指向的空间清0 printf(&quot;%d\\n&quot;, *p); // 输出调用memset函数后的结果 *p = 2; printf(&quot;%d\\n&quot;, *p); return 0; } free()从堆上获得的内存空间在程序结束以后，系统不会将其自动释放，需要程序员来自己管理。一个程序结束时，必须保证所有从堆上获得的内存空间已被安全释放，否则，会导致内存泄露。例如上面的 demo 就会发生内存泄露。 free()函数可以实现释放内存的功能。其函数声明为： void free(void * p); 由于形参为 void 指针，free()函数可以接受任意类型的指针实参。 但是，free()函数只是释放指针指向的内容，而该指针仍然指向原来指向的地方，此时，指针为野指针，如果此时操作该指针会导致不可预期的错误。安全做法 是：在使用 free()函数释放指针指向的空间之后，将指针的值置为 NULL。因此，对于上面的 demo，需要在 return 语句前加入以下两行语句： free(p); p = NULL; 注意：使用 malloc()函数分配的堆空间在程序结束之前必须释放。 calloc()calloc()函数的功能与 malloc()函数的功能相似，都是从堆分配内存。其函数声明如下： void *calloc(size_t n, size_t size); 函数返回值为 void 型指针。如果执行成功，函数从堆上获得 size X n 的字节空间，并返回该空间的首地址。如果执行失败，函数返回 NULL。该函数与 malloc()函数的一个显著不同时是，calloc()函数得到的内存空间是经过初始化的，其内容全为 0。calloc()函数适合为数组申请空间，可以将 size 设置为数组元素的空间长度，将 n 设置为数组的容量。 示例代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define SIZE 5 int main() { int *p = NULL; int i = 0; // 为p从堆上分配SIZE个int型空间 p = (int *) calloc(SIZE, sizeof(int)); if (NULL == p) { printf(&quot;Error in calloc.\\n&quot;); return -1; } // 为p指向的SIZE个int型空间赋值 for (i = 0; i &lt; SIZE; i++) { p[i] = i; } // 输出各个空间的值 for (i = 0; i &lt; SIZE; i++) { printf(&quot;p[%d]=%d\\n&quot;, i, p[i]); } free(p); p = NULL; return 0; } 提示：calloc()函数的分配的内存也需要自行释放。 realloc()realloc()函数的功能比 malloc()函数和 calloc()函数的功能更为丰富，可以实现内存分配和内存释放的功能，其函数声明如下： void * realloc(void * p, size_t n); 其中，指针 p 必须为指向堆内存空间的指针，即由 malloc()函数、calloc()函数或 realloc()函数分配空间的指针。realloc()函数将指针 p 指向的内存块的大小改变为 n 字节。如果 n 小于或等于 p 之前指向的空间大小，那么。保持原有状态不变。如果 n 大于原来 p 之前指向的空间大小，那么，系统将 重新为 p 从堆上分配一块大小为 n 的内存空间，同时，将原来指向空间的内容依次复制到新的内存空间上，p 之前指向的空间被释放。realloc()函数分配的空间也是未初始化的。 注意：使用 malloc()函数，calloc()函数和 realloc()函数分配的内存空间都要使用 free()函数或指针参数为 NULL 的 realloc()函数来释放。 示例代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int *p = NULL; p = (int *) malloc(sizeof(int)); *p = 3; printf(&quot;p=%p\\n&quot;, p); printf(&quot;*p=%d\\n&quot;, *p); p = (int *) realloc(p, sizeof(int)); printf(&quot;p=%p\\n&quot;, p); printf(&quot;*p=%d\\n&quot;, *p); p = (int *) realloc(p, 3 * sizeof(int)); printf(&quot;p=%p\\n&quot;, p); printf(&quot;*p=%d&quot;, *p); // 释放p指向的空间 realloc(p, 0); p = NULL; return 0; } 下面要注意的几点是： 函数 malloc()和 calloc()都可以用来动态分配内存空间。 malloc()函数有一个参数，即分配的内存空间的大小，malloc()在分配内存的时候会保留一定的空间用来记录分配情况，分配的次数越多，这些记录占用的空间就越多。 另外，根据 malloc()实现策略的不同，malloc()每次在分配的时候，可能分配的空间比实际要求的多些，多次分配会导致更多的这种浪费，当然，这些都跟 malloc()的实现有关； calloc()函数有两个参数，分别为元素的个数和每个元素的大小，这两个参数的乘积就是要分配的内存空间的大小。如果调用成功，它们都将返回所分配内存空间的首地址。 函数 malloc()和 calloc()的主要区别是前者不能初始化所分配的内存空间，而后者可以。 realloc()可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或者缩小，原有内存中的内容将保持不变。当然，对于缩小，则被缩小的那一部分的内容会丢失。 realloc()并不保证调整后的内存空间和原来的内存空间保持同一内存地址，相反，realloc()返回的指针很可能指向一个新地址。所以在代码 中，我们必须将 realloc()的返回值，重新赋值给 p ： p = (int _) realloc (p, sizeof(int) _ 15); realloc()函数，另外一个注意点： realloc()有可能操作失败，返回 NULL，所以不要把它的返回值直接赋值给原来的指针变量，以免原值丢失： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { char *str = NULL; str = (char *)malloc(sizeof(char)); *str = &#39;a&#39;; char *p = (char *)realloc(str, sizeof(char) * 10); if (p != NULL) { str = p; } printf(&quot;%s\\n&quot;, str); return 0; }","tags":[{"name":"C","slug":"C","permalink":"https://www.flaglee.cn/tags/C/"},{"name":"内存分区","slug":"内存分区","permalink":"https://www.flaglee.cn/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"},{"name":"内存管理","slug":"内存管理","permalink":"https://www.flaglee.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"Python多任务编程：进程和线程","date":"2020-09-04T15:04:37.000Z","path":"2020/09/04/Python多任务编程：进程和线程/","text":"一般写的程序都是单任务的，也就是说一个函数或者方法执行完成之后另外一个函数或者方法才能执行，要想实现多个任务同时执行的操作就需要使用多任务。多任务的最大好处是充分利用 CPU 资源，提高程序的执行效率。 多任务的概念多任务是指在同一时间内执行多个任务。多任务能充分利用 CPU 资源，提高程序的执行效率，让程序具备处理多个任务的能力。 多任务的执行方式： 并发 并行 并发 任务数 &gt; CPU核心数，在一段时间内交替去执行任务。对于单核cpu处理多任务,操作系统轮流让各个软件交替执行。 假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。 表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。并行 任务数 &lt; CPU核心数，对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。 这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。并行才是多个任务真正意义一起执行。进程进程的概念一个正在运行的程序或者软件就是一个进程，它是操作系统进行资源分配的基本单位，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。 比如:现实生活中的公司可以理解成是一个进程，公司提供办公资源(电脑、办公桌椅等)，真正干活的是员工，员工可以理解成线程。 一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。 多进程的使用1.导入进程包 #导入进程包 import multiprocessing 2.Process 进程类的说明Process([group [, target [, name [, args [, kwargs]]]]]) group：指定进程组，目前只能使用 None target：执行的目标任务名 name：进程名字 args：以元组方式给执行任务传参 kwargs：以字典方式给执行任务传参 Process 创建的实例对象的常用方法: start()：启动子进程实例（创建子进程） join()：等待子进程执行结束 terminate()：不管任务是否完成，立即终止子进程 Process 创建的实例对象的步骤: 导入进程包 import multiprocessing 创建子进程并指定执行的任务 sub_process = multiprocessing.Process (target=任务名) 启动进程执行任务 sub_process.start() 多进程完成多任务的代码 import multiprocessing import time # 跳舞任务 def dance(): for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 唱歌任务 def sing(): for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果: 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 获取进程编号1.获取进程编号的目的 获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。 获取进程编号的两种操作 获取当前进程编号 获取当前父进程编号 获取当前进程编号方法 os.getpid() 获取当前父进程编号 os.getppid() 获取进程编号可以查看父子进程的关系 2.获取当前进程编号 os.getpid() 表示获取当前进程编号 示例代码: import multiprocessing import time import os # 跳舞任务 def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9) # 唱歌任务 def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果: main: 70763 main: &lt;_MainProcess(MainProcess, started)&gt; dance: 70768 dance: &lt;Process(myprocess1, started)&gt; 跳舞中... sing: 70769 sing: &lt;Process(Process-2, started)&gt; 唱歌中... 唱歌中... 唱歌中... 唱歌中... 唱歌中... **3.获取当前父进程编号 os.getppid() 表示获取当前父进程编号 示例代码: import multiprocessing import time import os # 跳舞任务 def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;dance的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9) # 唱歌任务 def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;sing的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果： main: 70860 main: &lt;_MainProcess(MainProcess, started)&gt; dance: 70861 dance: &lt;Process(myprocess1, started)&gt; dance的父进程编号: 70860 跳舞中... sing: 70862 sing: &lt;Process(Process-2, started)&gt; sing的父进程编号: 70860 唱歌中... 唱歌中... 唱歌中... 唱歌中... 唱歌中... 进程执行带有参数的任务1. 进程执行带有参数的任务的介绍 前面使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢? Process 类执行任务并给任务传参数有两种方式: 元组方式传参(args): 元组方式传参一定要和参数的顺序保持一致。 字典方式传参(kwargs): 字典方式传参字典中的 key 一定要和参数名保持一致。 2. args 参数的使用 示例代码: import multiprocessing import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子进程 # args: 以元组的方式给任务传入参数 sub_process = multiprocessing.Process(target=task, args=(5,)) sub_process.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 3. kwargs 参数的使用 示例代码: import multiprocessing import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子进程 # kwargs: 表示以字典方式传入参数 sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3}) sub_process.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 进程之间不共享全局变量创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。 示例代码： import multiprocessing import time # 定义全局变量 g_list = list() # 添加数据的任务 def add_data(): for i in range(5): g_list.append(i) print(&quot;add:&quot;, i) time.sleep(0.2) # 代码执行到此，说明数据添加完成 print(&quot;add_data:&quot;, g_list) def read_data(): print(&quot;read_data&quot;, g_list) if __name__ == &#39;__main__&#39;: # 创建添加数据的子进程 add_data_process = multiprocessing.Process(target=add_data) # 创建读取数据的子进程 read_data_process = multiprocessing.Process(target=read_data) # 启动子进程执行对应的任务 add_data_process.start() # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据 add_data_process.join() read_data_process.start() print(&quot;main:&quot;, g_list) # 总结: 多进程之间不共享全局变量 执行结果: add: 0 add: 1 add: 2 add: 3 add: 4 add_data: [0, 1, 2, 3, 4] main: [] read_data [] 进程之间不共享全局变量的解释效果图: 主进程会等待所有的子进程执行结束再结束为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是主进程退出子进程销毁，不让主进程再等待子进程去执行。 设置守护主进程方式： 子进程对象.daemon = True 销毁子进程方式： 子进程对象.terminate() 假如我们现在创建一个子进程，这个子进程执行完大概需要 2 秒钟，现在让主进程执行 0.5 秒钟就退出程序，查看一下执行结果，示例代码如下: import multiprocessing import time # 定义进程所需要执行的任务 def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建子进程 sub_process = multiprocessing.Process(target=task) sub_process.start() # 主进程延时0.5秒钟 time.sleep(0.5) print(&quot;over&quot;) exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 执行结果: 任务执行中... 任务执行中... 任务执行中... over 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 说明: 通过上面代码的执行结果，我们可以得知: 主进程会等待所有的子进程执行结束再结束 假如我们就让主进程执行 0.5 秒钟，子进程就销毁不再执行，那怎么办呢? 我们可以设置守护主进程 或者 在主进程退出之前 让子进程销毁 守护主进程: 守护主进程就是主进程退出子进程销毁不再执行 子进程销毁: 子进程执行结束 保证主进程正常退出的示例代码: import multiprocessing import time # 定义进程所需要执行的任务 def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建子进程 sub_process = multiprocessing.Process(target=task) # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程 # sub_process.daemon = True sub_process.start() time.sleep(0.5) print(&quot;over&quot;) # 让子进程销毁 sub_process.terminate() exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁 执行结果: 任务执行中... 任务执行中... 任务执行中... over 线程线程的概念在 Python 中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。 线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要 cpu 进行调度 ，也就是说线程是 cpu 调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。 多线程的使用1. 导入线程模块 #导入线程模块 import threading 2. 线程类 Thread 参数说明 Thread([group [, target [, name [, args [, kwargs]]]]]) group: 线程组，目前只能使用 None target: 执行的目标任务名 args: 以元组的方式给执行任务传参 kwargs: 以字典方式给执行任务传参 name: 线程名，一般不用设置 3. 启动线程 导入线程模块 import threading 创建子线程并指定执行的任务 sub_thread = threading.Thread(target=任务名) 启动线程执行任务 sub_thread.start() 示例代码： import threading import time # 唱歌任务 def sing(): # 扩展： 获取当前线程 # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在唱歌...%d&quot; % i) time.sleep(1) # 跳舞任务 def dance(): # 扩展： 获取当前线程 # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在跳舞...%d&quot; % i) time.sleep(1) if __name__ == &#39;__main__&#39;: # 扩展： 获取当前线程 # print(&quot;当前执行的线程为：&quot;, threading.current_thread()) # 创建唱歌的线程 # target： 线程执行的函数名 sing_thread = threading.Thread(target=sing) # 创建跳舞的线程 dance_thread = threading.Thread(target=dance) # 开启线程 sing_thread.start() dance_thread.start() 执行结果： 正在唱歌...0 正在跳舞...0 正在唱歌...1 正在跳舞...1 正在唱歌...2 正在跳舞...2 线程执行带有参数的任务1. 线程执行带有参数的任务的介绍 前面使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢? Thread 类执行任务并给任务传参数有两种方式: 元组方式传参(args) ：元组方式传参一定要和参数的顺序保持一致。 字典方式传参(kwargs)：字典方式传参字典中的 key 一定要和参数名保持一致。 2. args 参数的使用 示例代码: import threading import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子线程 # args: 以元组的方式给任务传入参数 sub_thread = threading.Thread(target=task, args=(5,)) sub_thread.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 3. kwargs 参数的使用 示例代码: import threading import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子线程 # kwargs: 表示以字典方式传入参数 sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3}) sub_thread.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 线程之间执行是无序的线程之间执行是无序的，它是由 cpu 调度决定的 ，cpu 调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。 进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。 示例代码： import threading import time def task(): time.sleep(1) print(&quot;当前线程:&quot;, threading.current_thread().name) if __name__ == &#39;__main__&#39;: for _ in range(5): sub_thread = threading.Thread(target=task) sub_thread.start() 运行结果： 当前线程: Thread-1 当前线程: Thread-2 当前线程: Thread-4 当前线程: Thread-5 当前线程: Thread-3 主线程会等待所有的子线程执行结束再结束主线程默认会等待所有子线程执行结束再结束，设置守护主线程的目的是主线程退出子线程销毁。 假如我们现在创建一个子线程，这个子线程执行完大概需要 2.5 秒钟，现在让主线程执行 1 秒钟就退出程序，查看一下执行结果，示例代码如下: import threading import time # 测试主线程是否会等待子线程执行完成以后程序再退出 def show_info(): for i in range(5): print(&quot;test:&quot;, i) time.sleep(0.5) if __name__ == &#39;__main__&#39;: sub_thread = threading.Thread(target=show_info) sub_thread.start() # 主线程延时1秒 time.sleep(1) print(&quot;over&quot;) 执行结果： test: 0 test: 1 over test: 2 test: 3 test: 4 说明: 通过上面代码的执行结果，我们可以得知: 主线程会等待所有的子线程执行结束再结束 假如我们就让主线程执行 1 秒钟，子线程就销毁不再执行，那怎么办呢? 我们可以设置守护主线程 守护主线程: 守护主线程就是主线程退出子线程销毁不再执行 设置守护主线程有两种方式： threading.Thread(target=show_info, daemon=True) 线程对象.setDaemon(True) 设置守护主线程的示例代码: import threading import time # 测试主线程是否会等待子线程执行完成以后程序再退出 def show_info(): for i in range(5): print(&quot;test:&quot;, i) time.sleep(0.5) if __name__ == &#39;__main__&#39;: # 创建子线程守护主线程 # daemon=True 守护主线程 # 守护主线程方式1 sub_thread = threading.Thread(target=show_info, daemon=True) # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码 # 守护主线程方式2 # sub_thread.setDaemon(True) sub_thread.start() # 主线程延时1秒 time.sleep(1) print(&quot;over&quot;) 执行结果: test: 0 test: 1 over 线程之间共享全局变量线程之间共享全局变量，好处是可以对全局变量的数据进行共享。 需求: 定义一个列表类型的全局变量 创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务 查看线程之间是否共享全局变量数据 import threading import time # 定义全局变量 my_list = list() # 写入数据任务 def write_data(): for i in range(5): my_list.append(i) time.sleep(0.1) print(&quot;write_data:&quot;, my_list) # 读取数据任务 def read_data(): print(&quot;read_data:&quot;, my_list) if __name__ == &#39;__main__&#39;: # 创建写入数据的线程 write_thread = threading.Thread(target=write_data) # 创建读取数据的线程 read_thread = threading.Thread(target=read_data) write_thread.start() # 延时 # time.sleep(1) # 主线程等待写入线程执行完成以后代码在继续往下执行 write_thread.join() print(&quot;开始读取数据啦&quot;) read_thread.start() 执行结果: write_data: [0, 1, 2, 3, 4] 开始读取数据啦 read_data: [0, 1, 2, 3, 4] 线程之间共享全局变量数据出现错误问题线程之间共享全局变量可能会导致数据出现错误问题，可以使用线程同步方式来解决这个问题。 需求: 定义两个函数，实现循环 100 万次，每循环一次给全局变量加 1 创建两个子线程执行对应的两个函数，查看计算后的结果 import threading # 定义全局变量 g_num = 0 # 循环一次给全局变量加1 def sum_num1(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 循环一次给全局变量加1 def sum_num2(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() # 启动线程 second_thread.start() 执行结果: sum1: 1210949 sum2: 1496035 注意点: 多线程同时对全局变量操作数据发生了错误 错误分析: 两个线程 first_thread 和 second_thread 都要对全局变量 g_num(默认是 0)进行加 1 运算，但是由于是多线程同时操作，有可能出现下面情况： 在 g_num=0 时，first_thread 取得 g_num=0。此时系统把 first_thread 调度为”sleeping”状态，把 second_thread 转换为”running”状态，t2 也获得 g_num=0 然后 second_thread 对得到的值进行加 1 并赋给 g_num，使得 g_num=1 然后系统又把 second_thread 调度为”sleeping”，把 first_thread 转为”running”。线程 t1 又把它之前得到的 0 加 1 后赋值给 g_num。 这样导致虽然 first_thread 和 first_thread 都对 g_num 加 1，但结果仍然是 g_num=1 全局变量数据错误的解决办法: 线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机 线程同步的方式: 线程等待(join) 互斥锁 线程等待的示例代码: import threading # 定义全局变量 g_num = 0 # 循环1000000次每次给全局变量加1 def sum_num1(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 循环1000000次每次给全局变量加1 def sum_num2(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程 # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行 first_thread.join() # 启动线程 second_thread.start() 执行结果: sum1: 1000000 sum2: 2000000 互斥锁与死锁互斥锁的概念互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。 互斥锁的作用就是保证同一时刻只能有一个线程去操作共享数据，保证共享数据不会出现错误问题 使用互斥锁的好处确保某段关键代码只能由一个线程从头到尾完整地去执行 使用互斥锁会影响代码的执行效率，多任务改成了单任务执行 互斥锁如果没有使用好容易出现死锁的情况 注意: 互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。 互斥锁的使用threading 模块中定义了 Lock 变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。 互斥锁使用步骤: # 创建锁 mutex = threading.Lock() # 上锁 mutex.acquire() ...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定... # 释放锁 mutex.release() 注意点: acquire 和 release 方法之间的代码同一时刻只能有一个线程去操作 如果在调用 acquire 方法的时候 其他线程已经使用了这个互斥锁，那么此时 acquire 方法会堵塞，直到这个互斥锁释放后才能再次上锁。 互斥锁示例使用互斥锁完成 2 个线程对同一个全局变量各加 100 万次的操作 import threading # 定义全局变量 g_num = 0 # 创建全局互斥锁 lock = threading.Lock() # 循环一次给全局变量加1 def sum_num1(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 释放锁 lock.release() # 循环一次给全局变量加1 def sum_num2(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() second_thread.start() # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待 # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行 执行结果: sum1: 1000000 sum2: 2000000 说明: 通过执行结果可以地址互斥锁能够保证多个线程访问共享数据不会出现数据错误问题 死锁的概念死锁: 一直等待对方释放锁的情景就是死锁 使用互斥锁的时候需要注意死锁的问题，要在合适的地方注意释放锁。 死锁一旦产生就会造成应用程序的停止响应，应用程序无法再继续往下执行了。 死锁的结果 会造成应用程序的停止响应，不能再处理其它任务了。 死锁示例 需求: 根据下标在列表中取值, 保证同一时刻只能有一个线程去取值 import threading import time # 创建互斥锁 lock = threading.Lock() # 根据下标去取值， 保证同一时刻只能有一个线程去取值 def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] # 判断下标释放越界 if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 避免死锁 在合适的地方释放锁 import threading import time # 创建互斥锁 lock = threading.Lock() # 根据下标去取值， 保证同一时刻只能有一个线程去取值 def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) # 当下标越界需要释放锁，让后面的线程还可以取值 lock.release() return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 进程和线程的对比关系对比 线程是依附在进程里面的，没有进程就没有线程。 一个进程默认提供一条线程，进程可以创建多个线程。 区别对比 进程之间不共享全局变量 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步 创建进程的资源开销要比创建线程的资源开销要大 进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位 线程不能够独立执行，必须依存在进程中 多进程开发比单进程多线程开发稳定性要强 优缺点对比 进程优缺点: 优点：可以用多核 缺点：资源开销大 线程优缺点: 优点：资源开销小 缺点：不能使用多核 小结 进程和线程都是完成多任务的一种方式 多进程要比多线程消耗的资源多，但是多进程开发比单进程多线程开发稳定性要强，某个进程挂掉不会影响其它进程。 多进程可以使用 cpu 的多核运行，多线程可以共享全局变量。 线程不能单独执行必须依附在进程里面 计算密集型的应用使用多进程，有效利用多核提升运算效率；其他应用（文件写入、文件下载、IO 操作）使用多线程，更加节省资源并且可以完成多任务。","tags":[{"name":"Python","slug":"Python","permalink":"https://www.flaglee.cn/tags/Python/"},{"name":"多任务","slug":"多任务","permalink":"https://www.flaglee.cn/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/"},{"name":"进程","slug":"进程","permalink":"https://www.flaglee.cn/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://www.flaglee.cn/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"使用QT编译RTKLIB的GUI程序","date":"2020-08-10T09:26:54.000Z","path":"2020/08/10/使用QT编译RTKLIB-GUI程序/","text":"近期在基于 RTKLIB 改了一些代码，但一直是基于源码运行的，于是便想着编译一个自己的图形用户界面。查阅 manual 2.4.2 手册上使用的是 Embarcadero C++ Builder XE2 or XE3，上网查了一下实在是太古老，无奈放弃。之后使用 QT 编译成功，写下这篇博客记录一下方法和注意事项。 所用版本这篇博客基于的是 demo5 源码版本，链接见http://rtkexplorer.com/downloads/rtklib-code/。QT 使用的是 5.14.2，国内镜像链接见https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.14/5.14.2/。本文只针对以上版本记录编译过程中遇到的问题。其实版本之间大同小异，博主之前也用别的版本编译成功过，希望大家举一反三。 编译流程首先使用 QT creator 打开源码根目录下的.pro 文件，创建工程。 这里使用的是 MinGW 32 位，注意区分。 以 rtkpost 软件为例，选择 Release 构建下的 rtkpost_qt。 按绿色三角或 Ctrl+R 开始运行。 问题 1第一个问题发现提示 :-1: error: No rule to make target ‘rcv/ss2.c’, needed by ‘release/ss2.o’. Stop. 这个问题是由于之前的代码中有这个文件，而最新的版本已经去掉，我们可以在 src.pro 中找到这一条将其注释掉。 重新运行程序。 问题 2发现提示 :-1: error: No rule to make target ‘../../src/debug/libRTKLib.a’, needed by ‘release/rtknavi_qt.exe’. Stop. 这是因为缺少库文件 libRTKLib.a，这个文件就是我们源代码生成的库文件，当你改了源码之后，这个也会随之改变，所以千万不要乱用。这个文件可以在 Debug 模式下生成，我们切到 Debug 模式下重新运行。 问题 3发现一连串报错 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\RTKLIB-demo5..\\RTKLIB-demo5\\app\\rtkconv_qt\\codeopt.cpp:333: error: ‘FREQTYPE_L7’ was not declared in this scope E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); 这是由于 demo5 版本在头文件改了一些配置，源码编译文件改了，但是 qt 编译文件还没有改，我们可以找到 app&gt;rtkconv&gt;codeopt.cpp 查看它是怎么使用的，我们 rtkconv_qt&gt;codeopt.cpp 只要随之改变就好 E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); 改为 E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); 改为 J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); 改为 C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); 改为 I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); 同样 convopt.cpp 下也有这个问题，也采用上面的方法改完，重新运行。编译成功，我们已经可以看到 Debug 模式下的程序界面。 之后我们在 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Debug\\src\\debug 路径下找到我们编译的 libRTKLib.a 将其复制到 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Release\\src\\debug 且回到 Release 模式，重新运行，即可成功。 程序打包这样直接生成的程序是不能直接运行的，需要进行打包。打开 Qt 版本号 for Desktop (MinGW 版本号 32bit)命令行，注意与一开始选择的对应。 接着输入命令行，cd /d 路径(指的是需要打包的 exe 程序目录，就是刚才拷贝出来的 exe 程序所在的目录)，回车后， 输入如下命令行：windeployqt 程序名 敲击回车。这一步操作是将所需的库文件全都拷贝到 exe 程序的当前文件。 现在，便可以双击 exe 直接运行软件了！ 若你要将程序给别人使用，一定要注意 dll 文件也要一起打包哦。","tags":[{"name":"QT","slug":"QT","permalink":"https://www.flaglee.cn/tags/QT/"},{"name":"GNSS","slug":"GNSS","permalink":"https://www.flaglee.cn/tags/GNSS/"},{"name":"RTKlib","slug":"RTKlib","permalink":"https://www.flaglee.cn/tags/RTKlib/"},{"name":"RTK","slug":"RTK","permalink":"https://www.flaglee.cn/tags/RTK/"}]},{"title":"RTKlib源码解析-高精度GNSS定位处理过程","date":"2020-07-15T14:17:30.000Z","path":"2020/07/15/RTKlib-关于高精度GPS动态定位处理过程/","text":"RTKLIB 是用于 GNSS（全球导航卫星系统）的标准和精确定位的开源程序包。二进制文件以及完整原始代码见RTKlib.com。Demo5 是 RTKLIB 代码的修改版本，针对低成本的单频和双频接收器而定制，旨在提高性能。二进制文件以及完整原始代码见http://rtkexplorer.com/downloads/rtklib-code/。 本文主要介绍用 RTKLIB 实现精密动态定位的过程，该过程包括观测文件和导航文件的读取、基准站位置的计算、流动站位置的求解、运行结果的输出。 主函数配置解算流程文件读取求解基站参数相对动态定位","tags":[{"name":"GNSS","slug":"GNSS","permalink":"https://www.flaglee.cn/tags/GNSS/"},{"name":"RTKlib","slug":"RTKlib","permalink":"https://www.flaglee.cn/tags/RTKlib/"},{"name":"RTK","slug":"RTK","permalink":"https://www.flaglee.cn/tags/RTK/"},{"name":"GPS","slug":"GPS","permalink":"https://www.flaglee.cn/tags/GPS/"},{"name":"BDS","slug":"BDS","permalink":"https://www.flaglee.cn/tags/BDS/"}]},{"title":"Markdown语法汇总","date":"2020-05-26T02:58:53.000Z","path":"2020/05/26/Markdown语法汇总/","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息，例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等。 Markdown 标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加#+space号即可。使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 Markdown 段落段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 字体Markdown 可以使用以下几种字体： _斜体文本_ _斜体文本_ **粗体文本** **粗体文本** **_粗斜体文本_** **_粗斜体文本_** 斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： --- --- --- --- --- 删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： GOOGLE.COM ~~BAIDU.COM~~ GOOGLE.COMBAIDU.COM 下划线下划线可以通过 HTML 标签来实现： &lt;u&gt;带下划线文本&lt;/u&gt; 带下划线文本 Markdown 列表Markdown 支持有序列表和无序列表。 无序列表无序列表使用星号*、加号+或是减号-作为列表标记，这些标记后面要添加一个space，然后再填写内容： - 第一项 - 第二项 - 第三项 * 第一项 * 第二项 * 第三项 - 第一项 - 第二项 - 第三项 第一项 第二项 第三项 有序列表有序列表使用数字并加上space. 号来表示，如： 1. 第一项 2. 第二项 3. 第三项 第一项 第二项 第三项 Markdown 区块Markdown 区块引用是在段落开头使用 >符号 ，然后后面紧跟一个space符号： &gt; 区块引用 区块引用 Markdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来`，例如： `printf()` 函数 printf() 函数代码区块使用 4 个空格或者一个制表符Tab。也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定） Markdown 链接链接使用方法如下： [链接名称](链接地址) 或者 &lt;链接地址&gt; [FLAG&#39;s blog](www.flaglee.cn) FLAG’s blog 高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行： 这个链接用 1 作为网址变量 [Google][1] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ Markdown 图片Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) ![Markdown](https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png &quot;markdown图标&quot;) Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ------ | ------ | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 对齐方式 可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 | 左对齐 | 右对齐 | 居中对齐 | | :----- | -----: | :------: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 Markdown 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等，如： 使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 使用 Ctrl+Alt+Del 重启电脑 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： **文本加粗** \\*\\* 正常显示星号 \\*\\* 文本加粗** 正常显示星号 ** 公式当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。","tags":[{"name":"blog","slug":"blog","permalink":"https://www.flaglee.cn/tags/blog/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.flaglee.cn/tags/Markdown/"}]},{"title":"Hello World","date":"2020-05-26T02:53:03.254Z","path":"2020/05/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.flaglee.cn/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"https://www.flaglee.cn/tags/blog/"}]}]