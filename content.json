[{"title":"机器学习基础知识(四)：Pandas高级处理","date":"2020-10-08T04:20:15.000Z","path":"2020/10/08/机器学习基础知识-四-：Pandas高级处理/","text":"本文主要介绍 Pandas 的缺失值处理、数据离散化、合并、交叉表与透视表、分组与聚合等操作，并进行实例操作。 缺失值处理 目标 应用 isnull 判断是否有缺失数据 NaN - isnull、notnull 判断是否存在缺失值【知道】 - np.any(pd.isnull(movie)) # 里面如果有一个缺失值,就返回 True - np.all(pd.notnull(movie)) # 里面如果有一个缺失值,就返回 False 应用 fillna 实现缺失值的填充 应用 dropna 实现缺失值的删除 应用 replace 实现数据的替换 dropna 删除 np.nan 标记的缺失值【知道】movie.dropna()fillna 填充缺失值【知道】movie[i].fillna(value=movie[i].mean(), inplace=True)replace 替换具体某些值【知道】wis.replace(to_replace=”?”, value=np.NaN) 如何处理 nan 获取缺失值的标记方式(NaN 或者其他标记方式) 如果缺失值的标记方式是 NaN 判断数据中是否包含 NaN： pd.isnull(df), pd.notnull(df) 存在缺失值 nan: 1、删除存在缺失值的:dropna(axis=’rows’) 注：不会修改原数据，需要接受返回值 2、替换缺失值:fillna(value, inplace=True) value:替换成的值 inplace:True:会修改原数据，False:不替换修改原数据，生成新的对象 如果缺失值没有使用 NaN 标记，比如使用”？” 先替换‘?’为 np.nan，然后继续处理 电影数据的缺失值处理 电影数据文件获取 # 读取电影数据 movie = pd.read_csv(&quot;./data/IMDB-Movie-Data.csv&quot;) 判断缺失值是否存在 pd.notnull() pd.notnull(movie) Rank Title Genre Description Director Actors Year Runtime (Minutes) Rating Votes Revenue (Millions) Metascore 0 True True True True True True True True True True True True 1 True True True True True True True True True True True True 2 True True True True True True True True True True True True 3 True True True True True True True True True True True True 4 True True True True True True True True True True True True 5 True True True True True True True True True True True True 6 True True True True True True True True True True True True 7 True True True True True True True True True True False True np.all(pd.notnull(movie)) pd.isnull() 存在缺失值 nan,并且是 np.nan 1、删除pandas 删除缺失值，使用 dropna 的前提是，缺失值的类型必须是 np.nan # 不修改原数据 movie.dropna() # 可以定义新的变量接受或者用原来的变量名 data = movie.dropna() 2、替换缺失值 # 替换存在缺失值的样本的两列 # 替换填充平均值，中位数 # movie[&#39;Revenue (Millions)&#39;].fillna(movie[&#39;Revenue (Millions)&#39;].mean(), inplace=True) 替换所有缺失值： for i in movie.columns: if np.all(pd.notnull(movie[i])) == False: print(i) movie[i].fillna(movie[i].mean(), inplace=True) 不是缺失值 nan，有默认标记的 wis = pd.read_csv(&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&quot;) 以上数据在读取时，可能会报如下错误： URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:833)&gt; 解决办法： # 全局取消证书验证 import ssl ssl._create_default_https_context = ssl._create_unverified_context 处理思路分析： 1、先替换‘?’为 np.nan df.replace(to_replace=, value=) to_replace:替换前的值 value:替换后的值 # 把一些其它值标记的缺失值，替换成np.nan wis = wis.replace(to_replace=&#39;?&#39;, value=np.nan) 2、在进行缺失值的处理 # 删除 wis = wis.dropna() 数据离散化 应⽤ cut、 qcut 实现数据的区间分组 应⽤ get_dummies 实现数据的 one-hot 编码 为什么要离散化连续属性离散化的⽬ 的是为了简化数据结构，数据离散化技术可以⽤来减少给定连续属性值的个数。 离散化⽅法经常作为数据挖掘的⼯具。 什么是数据的离散化连续属性的离散化就是在连续属性的值域上， 将值域划分为若⼲个离散的区间， 最后⽤不同的符号或整数 值代表落在每个⼦区间中的属性值。 离散化有很多种⽅法， 这使⽤⼀种最简单的⽅式去操作 原始⼈的身⾼数据： 165， 174， 160， 180， 159， 163， 192， 184 假设按照身⾼分⼏个区间段： 150165, 165180,180~195 这样我们将数据分到了三个区间段， 我可以对应的标记为矮、 中、 ⾼三个类别， 最终要处理成⼀个”哑变量”矩阵 案例：股票的涨跌幅离散化我们对股票每日的”p_change”进行离散化 读取股票的数据先读取股票的数据， 筛选出 p_change 数据 data = pd.read_csv(&quot;./data/stock_day.csv&quot;) p_change= data[&#39;p_change&#39;] 将股票涨跌幅数据进⾏分组 使⽤的⼯具： pd.qcut(data, q)： 对数据进⾏分组将数据分组 ⼀般会与 value_counts 搭配使⽤， 统计每组的个数 series.value_counts()： 统计分组次数 # ⾃⾏分组 qcut = pd.qcut(p_change, 10) # 计算分到每个组数据个数 qcut.value_counts() ⾃定义区间分组： pd.cut(data, bins) # ⾃⼰指定分组区间 bins = [-100, -7, -5, -3, 0, 3, 5, 7, 100] p_counts = pd.cut(p_change, bins) 股票涨跌幅分组数据变成 one-hot 编码 什么是 one-hot 编码 把每个类别⽣成⼀个布尔列， 这些列中只有⼀列可以为这个样本取值为 1.其⼜被称热编码。把下图中左边的表格转化为使⽤右边形式进⾏表示： pandas.get_dummies(data, prefix=None) data:array-like, Series, or DataFrame prefix:分组名字 # 得出one-hot编码矩阵 dummies = pd.get_dummies(p_counts, prefix=&quot;rise&quot;) 合并 应⽤ pd.concat 实现数据的合并 应⽤ pd.merge 实现数据的合并 如果你的数据由多张表组成， 那么有时候需要将不同的内容合并在⼀起分析 pd.concat 实现数据合并 pd.concat([data1, data2], axis=1) 按照⾏或列进⾏合并,axis=0 为列索引， axis=1 为⾏索引 ⽐如我们将刚才处理好的 one-hot 编码与原数据合并 # 按照⾏索引进⾏ pd.concat([data, dummies], axis=1) pd.merge pd.merge(left, right, how=’inner’, on=None, left_on=None, right_on=None) 可以指定按照两组数据的共同键值对合并或者左右各⾃ left : A DataFrame object right : Another DataFrame object on : Columns (names) to join on. Must be found in both the left and right DataFrame objects. left_on=None, right_on=None： 指定左右键 pd.merge 合并 left = pd.DataFrame({&#39;key1&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;], &#39;key2&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K0&#39;, &#39;K1&#39;], &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;], &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]}) right = pd.DataFrame({&#39;key1&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K1&#39;, &#39;K2&#39;], &#39;key2&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K0&#39;, &#39;K0&#39;], &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;], &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]}) # 默认内连接 result = pd.merge(left, right, on=[&#39;key1&#39;, &#39;key2&#39;]) 左连接 result = pd.merge(left, right, how=&#39;left&#39;, on=[&#39;key1&#39;, &#39;key2&#39;]) - 右连接 result = pd.merge(left, right, how=&#39;right&#39;, on=[&#39;key1&#39;, &#39;key2&#39;]) 外链接 result = pd.merge(left, right, how=&#39;outer&#39;, on=[&#39;key1&#39;, &#39;key2&#39;]) 交叉表与透视表以下图当中表示， week 代表星期⼏， 1,0 代表这⼀天股票的涨跌幅是好还是坏， ⾥⾯的数据代表⽐例可以理解为所有时间为星期⼀等等的数据当中涨跌幅好坏的⽐例 crosstab(交叉表) 交叉表： 交叉表⽤于计算⼀列数据对于另外⼀列数据的分组个数(寻找两个列之间的关系) pd.crosstab(value1, value2) DataFrame.pivot_table([], index=[]) 数据准备 准备两列数据， 星期数据以及涨跌幅是好是坏数据 进⾏交叉表计算 # 1、 先把对应的⽇ 期找到星期⼏ date = pd.to_datetime(data.index).weekday data[&#39;week&#39;] = date # 2、 假如把p_change按照⼤⼩去分个类0为界限 data[&#39;posi_neg&#39;] = np.where(data[&#39;p_change&#39;] &gt; 0, 1, 0) # 通过交叉表找寻两列数据的关系 count = pd.crosstab(data[&#39;week&#39;], data[&#39;posi_neg&#39;]) 但是我们看到 count 只是每个星期⽇ ⼦的好坏天数， 并没有得到⽐例， 该怎么去做？ 对于每个星期⼀等的总天数求和， 运⽤除法运算求出⽐例 # 算数运算， 先求和 sum = count.sum(axis=1).astype(np.float32) # 进⾏相除操作， 得出⽐例 pro = count.div(sum, axis=0) 查看效果 使⽤ plot 画出这个⽐例， 使⽤ stacked 的柱状图 pro.plot(kind=&#39;bar&#39;, stacked=True) plt.show() pivot_table(透视表)使⽤透视表， 刚才的过程更加简单 # 通过透视表， 将整个过程变成更简单⼀些 data.pivot_table([&#39;posi_neg&#39;], index=&#39;week&#39;) 分组与聚合分组与聚合通常是分析数据的⼀种⽅式， 通常与⼀些统计函数⼀起使⽤， 查看数据的分组情况 想⼀想其实刚才的交叉表与透视表也有分组的功能， 所以算是分组的⼀种形式， 只不过他们主要是计算次数或者计算⽐例！ 看其中的效果： 什么分组与聚合 分组 API DataFrame.groupby(key, as_index=False) key:分组的列数据， 可以多个 案例:不同颜⾊的不同笔的价格数据 col =pd.DataFrame({&#39;color&#39;: [&#39;white&#39;,&#39;red&#39;,&#39;green&#39;,&#39;red&#39;,&#39;green&#39;], &#39;object&#39;: [&#39;pen&#39;,&#39;pencil&#39;,&#39;pencil&#39;,&#39;ashtray&#39;, &#39;pen&#39;],&#39;price1&#39;:[5.56,4.20,1.30,0.56,2.75],&#39;price2&#39;:[4.75,4.12,1.60,0.75,3.15]}) color object price1 price2 0 white pen 5.56 4.75 1 red pencil 4.20 4.12 2 green pencil 1.30 1.60 3 red ashtray 0.56 0.75 4 green pen 2.75 3.15 进⾏分组， 对颜⾊分组， price 进⾏聚合 # 分组， 求平均值 col.groupby([&#39;color&#39;])[&#39;price1&#39;].mean() col[&#39;price1&#39;].groupby(col[&#39;color&#39;]).mean() color green 2.025 red 2.380 white 5.560 Name: price1, dtype: float64 # 分组， 数据的结构不变 col.groupby([&#39;color&#39;], as_index=False)[&#39;price1&#39;].mean() color price1 0 green 2.025 1 red 2.380 2 white 5.560 案例 星巴克零售店铺数据现在我们有⼀组关于全球星巴克店铺的统计数据，如果我想知道美国的星巴克数量和中国的哪个多，或者我想知道中国每个省份星巴克的数量的情况，那么应该怎么办？ 数据来源： https://www.kaggle.com/starbucks/store-locations/data 数据获取 从⽂件中读取星巴克店铺数据 # 导⼊星巴克店的数据 starbucks = pd.read_csv(&quot;./data/starbucks/directory.csv&quot;) 进⾏分组聚合 # 按照国家分组， 求出每个国家的星巴克零售店数量 count = starbucks.groupby([&#39;Country&#39;]).count() 画图显示结果 count[&#39;Brand&#39;].plot(kind=&#39;bar&#39;, figsize=(20, 8)) plt.show() 假设我们加⼊省市⼀起进⾏分组 # 设置多个索引， set_index() starbucks.groupby([&#39;Country&#39;, &#39;State/Province&#39;]).count() 仔细观察这个结构，与前⾯的 MultiIndex 结构类似 案例 利用 Pandas 进行电影数据的分析需求现在我们有⼀组从 2006 年到 2016 年 1000 部最流⾏的电影数据， 数据来源： https://www.kaggle.com/damianpanek/sunday-eda/data 问题 1： 我们想知道这些电影数据中评分的平均分， 导演的⼈数等信息， 我们应该怎么获取？ 问题 2： 对于这⼀组电影数据， 如果我们想 rating， runtime 的分布情况， 应该如何呈现数据？ 问题 3： 对于这⼀组电影数据， 如果我们希望统计电影分类(genre)的情况， 应该如何处理数据？ 实现⾸先获取导⼊包， 获取数据 %matplotlib inline import pandas as pd import numpy as np from matplotlib import pyplot as plt #⽂件的路径 path = &quot;./data/IMDB-Movie-Data.csv&quot; #读取⽂件 df = pd.read_csv(path) 问题⼀我们想知道这些电影数据中评分的平均分，导演的⼈数等信息，我们应该怎么获取？ 得出评分的平均分 使⽤ mean 函数 df[&quot;Rating&quot;].mean() 得出导演⼈数信息 求出唯⼀值， 然后进⾏形状获取 ## 导演的⼈数 # df[&quot;Director&quot;].unique().shape[0] np.unique(df[&quot;Director&quot;]).shape[0] 644 问题⼆对于这⼀组电影数据， 如果我们想 Rating， Runtime (Minutes)的分布情况，应该如何呈现数据？ 直接呈现，以直⽅图的形式 选择分数列数据， 进⾏ plot df[&quot;Rating&quot;].plot(kind=&#39;hist&#39;,figsize=(20,8)) Rating 进⾏分布展示 进⾏绘制直⽅图 plt.figure(figsize=(20,8),dpi=80) plt.hist(df[&quot;Rating&quot;].values,bins=20) plt.show() 修改刻度的间隔 # 求出最⼤最⼩值 max_ = df[&quot;Rating&quot;].max() min_ = df[&quot;Rating&quot;].min() # ⽣成刻度列表 t1 = np.linspace(min_,max_,num=21) # [ 1.9 2.255 2.61 2.965 3.32 3.675 4.03 4.385 4.74 5.095 5.45 5.805 6.16 6.515 6.87 7. 225 7.58 7.935 8.29 8.645 9. ] # 修改刻度 plt.xticks(t1) # 添加⽹格 plt.grid() Runtime (Minutes)进⾏分布展示 进⾏绘制直⽅图 plt.figure(figsize=(20,8),dpi=80) plt.hist(df[&quot;Runtime (Minutes)&quot;].values,bins=20) plt.show() 修改间隔 # 求出最⼤最⼩值 max_ = df[&quot;Runtime (Minutes)&quot;].max() min_ = df[&quot;Runtime (Minutes)&quot;].min() # # ⽣成刻度列表 t1 = np.linspace(min_,max_,num=21) # 修改刻度 plt.xticks(np.linspace(min_,max_,num=21)) # 添加⽹格 plt.grid() 问题三对于这⼀组电影数据， 如果我们希望统计电影分类(genre)的情况， 应该如何处理数据？ 思路分析 思路 1、 创建⼀个全为 0 的 dataframe， 列索引置为电影的分类， temp_df 2、 遍历每⼀部电影， temp_df 中把分类出现的列的值置为 1 3、 求和 1、 创建⼀个全为 0 的 dataframe， 列索引置为电影的分类， temp_df # 进⾏字符串分割 temp_list = [i.split(&quot;,&quot;) for i in df[&quot;Genre&quot;]] # 获取电影的分类 genre_list = np.unique([i for j in temp_list for i in j]) # 增加新的列 temp_df = pd.DataFrame(np.zeros([df.shape[0],genre_list.shape[0]]),columns=genre_list) 2、 遍历每⼀部电影， temp_df 中把分类出现的列的值置为 1 for i in range(1000): #temp_list[i] [&#39;Action&#39;,&#39;Adventure&#39;,&#39;Animation&#39;] temp_df.ix[i,temp_list[i]]=1 print(temp_df.sum().sort_values()) 3、 求和,绘图 temp_df.sum().sort_values(ascending=False).plot(kind=&quot;bar&quot;,figsize=(20,8),fontsize=20,colormap=&quot;cool&quot;) Musical 5.0 Western 7.0 War 13.0 Music 16.0 Sport 18.0 History 29.0 Animation 49.0 Family 51.0 Biography 81.0 Fantasy 101.0 Mystery 106.0 Horror 119.0 Sci-Fi 120.0 Romance 141.0 Crime 150.0 Thriller 195.0 Adventure 259.0 Comedy 279.0 Action 303.0 Drama 513.0 dtype: float64","tags":[{"name":"Python","slug":"Python","permalink":"https://www.flaglee.cn/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.flaglee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://www.flaglee.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://www.flaglee.cn/tags/Matplotlib/"},{"name":"Numpy","slug":"Numpy","permalink":"https://www.flaglee.cn/tags/Numpy/"},{"name":"Pandas","slug":"Pandas","permalink":"https://www.flaglee.cn/tags/Pandas/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","permalink":"https://www.flaglee.cn/tags/Jupyter-Notebook/"}]},{"title":"机器学习基础知识(三)：Pandas的使用","date":"2020-10-02T02:12:34.000Z","path":"2020/10/02/机器学习基础知识-三-：Pandas的使用/","text":"2008 年 WesMcKinney 开发出的库 专门用于数据挖掘的开源 python 库 以 Numpy 为基础，借力 Numpy 模块在计算方面性能高的优势 基于 matplotlib，能够简便的画图 独特的数据结构 Pandas 简介Numpy 已经能够帮助我们处理数据，能够结合 matplotlib 解决部分数据展示等问题，那么 pandas 学习的目的在什么地方呢？ 增强图表可读性 回忆我们在 numpy 当中创建学生成绩表样式： 返回结果： array([[92, 55, 78, 50, 50], [71, 76, 50, 48, 96], [45, 84, 78, 51, 68], [81, 91, 56, 54, 76], [86, 66, 77, 67, 95], [46, 86, 56, 61, 99], [46, 95, 44, 46, 56], [80, 50, 45, 65, 57], [41, 93, 90, 41, 97], [65, 83, 57, 57, 40]])如果数据展示为这样，可读性就会更友好： 便捷的数据处理能力 读取文件方便 封装了 Matplotlib、Numpy 的画图和计算 Pandas 数据结构Pandas 中一共有三种数据结构，分别为：Series、DataFrame 和 MultiIndex。 其中 Series 是一维数据结构，DataFrame 是二维的表格型数据结构，MultiIndex 是三维的数据结构。 SeriesSeries 是一个类似于一维数组的数据结构，它能够保存任何类型的数据，比如整数、字符串、浮点数等，主要由一组数据和与之相关的索引两部分构成。 series 的创建 # 导入pandas import pandas as pd pd.Series(data=None, index=None, dtype=None) 参数： data：传入的数据，可以是 ndarray、list 等 index：索引，必须是唯一的，且与数据的长度相等。如果没有传入索引参数，则默认会自动创建一个从 0-N 的整数索引。 dtype：数据的类型 通过已有数据创建 指定内容，默认索引 pd.Series(np.arange(10)) # 运行结果 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 dtype: int64 指定索引 pd.Series([6.7,5.6,3,10,2], index=[1,2,3,4,5]) # 运行结果 1 6.7 2 5.6 3 3.0 4 10.0 5 2.0 dtype: float64 通过字典数据创建 color_count = pd.Series({&#39;red&#39;:100, &#39;blue&#39;:200, &#39;green&#39;: 500, &#39;yellow&#39;:1000}) color_count # 运行结果 blue 200 green 500 red 100 yellow 1000 dtype: int64 Series 的属性 为了更方便地操作 Series 对象中的索引和数据，Series 中提供了两个属性 index 和 values index color_count.index # 结果 Index([&#39;blue&#39;, &#39;green&#39;, &#39;red&#39;, &#39;yellow&#39;], dtype=&#39;object&#39;) values color_count.values # 结果 array([ 200, 500, 100, 1000]) 也可以使用索引来获取数据： color_count[2] # 结果 100 DataFrameDataFrame 是一个类似于二维数组或表格(如 excel)的对象，既有行索引，又有列索引 行索引，表明不同行，横向索引，叫 index，0 轴，axis=0 列索引，表名不同列，纵向索引，叫 columns，1 轴，axis=1 DataFrame 的创建 # 导入pandas import pandas as pd pd.DataFrame(data=None, index=None, columns=None) 参数： index：行标签。如果没有传入索引参数，则默认会自动创建一个从 0-N 的整数索引。 columns：列标签。如果没有传入索引参数，则默认会自动创建一个从 0-N 的整数索引。 通过已有数据创建 举例一：python pd.DataFrame(np.random.randn(2,3)) 回忆在前面直接使用 np 创建的数组显示方式，比较两者的区别。 举例二：创建学生成绩表 # 生成10名同学，5门功课的数据 score = np.random.randint(40, 100, (10, 5)) # 结果 array([[92, 55, 78, 50, 50], [71, 76, 50, 48, 96], [45, 84, 78, 51, 68], [81, 91, 56, 54, 76], [86, 66, 77, 67, 95], [46, 86, 56, 61, 99], [46, 95, 44, 46, 56], [80, 50, 45, 65, 57], [41, 93, 90, 41, 97], [65, 83, 57, 57, 40]]) 但是这样的数据形式很难看到存储的是什么的样的数据，可读性比较差！！ 问题：如何让数据更有意义的显示？ # 使用Pandas中的数据结构 score_df = pd.DataFrame(score) 给分数数据增加行列索引,显示效果更佳 增加行、列索引 # 构造行索引序列 subjects = [&quot;语文&quot;, &quot;数学&quot;, &quot;英语&quot;, &quot;政治&quot;, &quot;体育&quot;] # 构造列索引序列 stu = [&#39;同学&#39; + str(i) for i in range(score_df.shape[0])] # 添加行索引 data = pd.DataFrame(score, columns=subjects, index=stu) DataFrame 的属性 shape data.shape # 结果 (10, 5) index DataFrame 的行索引列表 data.index # 结果 Index([&#39;同学0&#39;, &#39;同学1&#39;, &#39;同学2&#39;, &#39;同学3&#39;, &#39;同学4&#39;, &#39;同学5&#39;, &#39;同学6&#39;, &#39;同学7&#39;, &#39;同学8&#39;, &#39;同学9&#39;], dtype=&#39;object&#39;) columnsDataFrame 的列索引列表 data.columns # 结果 Index([&#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;, &#39;政治&#39;, &#39;体育&#39;], dtype=&#39;object&#39;) values 直接获取其中array的值 data.values array([[92, 55, 78, 50, 50], [71, 76, 50, 48, 96], [45, 84, 78, 51, 68], [81, 91, 56, 54, 76], [86, 66, 77, 67, 95], [46, 86, 56, 61, 99], [46, 95, 44, 46, 56], [80, 50, 45, 65, 57], [41, 93, 90, 41, 97], [65, 83, 57, 57, 40]]) T转置 data.T 结果 head(5)：显示前 5 行内容 如果不补充参数，默认 5 行。填入参数 N 则显示前 N 行 data.head(5) tail(5):显示后 5 行内容 如果不补充参数，默认 5 行。填入参数 N 则显示后 N 行 data.tail(5) DatatFrame 索引的设置 修改行列索引值 stu = [&quot;学生_&quot; + str(i) for i in range(score_df.shape[0])] # 必须整体全部修改 data.index = stu 注意：以下修改方式是错误的 # 错误修改方式 data.index[3] = &#39;学生_3&#39; 重设索引 reset_index(drop=False) 设置新的下标索引 drop:默认为 False，不删除原来索引，如果为 True,删除原来的索引值 # 重置索引,drop=False data.reset_index() # 重置索引,drop=True data.reset_index(drop=True) 以某列值设置为新的索引 set_index(keys, drop=True) keys : 列索引名成或者列索引名称的列表 drop : boolean, default True.当做新的索引，删除原来的列 设置新索引案例 1、创建 df = pd.DataFrame({&#39;month&#39;: [1, 4, 7, 10], &#39;year&#39;: [2012, 2014, 2013, 2014], &#39;sale&#39;:[55, 40, 84, 31]}) month sale year 0 1 55 2012 1 4 40 2014 2 7 84 2013 3 10 31 2014 2、以月份设置新的索引 df.set_index(&#39;month&#39;) sale year month 1 55 2012 4 40 2014 7 84 2013 10 31 2014 3、设置多个索引，以年和月份 df = df.set_index([&#39;year&#39;, &#39;month&#39;]) df sale year month 2012 1 55 2014 4 40 2013 7 84 2014 10 31 注：通过刚才的设置，这样 DataFrame 就变成了一个具有 MultiIndex 的 DataFrame。 MultiIndexMultiIndex 是三维的数据结构; 多级索引（也称层次化索引）是 pandas 的重要功能，可以在 Series、DataFrame 对象上拥有 2 个以及 2 个以上的索引。 multiIndex 的特性 打印刚才的 df 的行索引结果 df.index MultiIndex(levels=[[2012, 2013, 2014], [1, 4, 7, 10]], labels=[[0, 2, 1, 2], [0, 1, 2, 3]], names=[&#39;year&#39;, &#39;month&#39;]) 多级或分层索引对象。 index 属性 names:levels 的名称 levels：每个 level 的元组值 df.index.names # FrozenList([&#39;year&#39;, &#39;month&#39;]) df.index.levels # FrozenList([[1, 2], [1, 4, 7, 10]]) multiIndex 的创建 arrays = [[1, 1, 2, 2], [&#39;red&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;blue&#39;]] pd.MultiIndex.from_arrays(arrays, names=(&#39;number&#39;, &#39;color&#39;)) # 结果 MultiIndex(levels=[[1, 2], [&#39;blue&#39;, &#39;red&#39;]], codes=[[0, 0, 1, 1], [1, 0, 1, 0]], names=[&#39;number&#39;, &#39;color&#39;]) 基本数据操作索引操作Numpy 当中我们已经讲过使用索引选取序列和切片选择，pandas 也支持类似的操作，也可以直接使用列名、行名称，甚至组合使用。 直接使用行列索引(先列后行) 获取’2018-02-27’这天的’close’的结果 # 直接使用行列索引名字的方式（先列后行） data[&#39;open&#39;][&#39;2018-02-27&#39;] 23.53 # 不支持的操作 # 错误 data[&#39;2018-02-27&#39;][&#39;open&#39;] # 错误 data[:1, :2] 结合 loc 或者 iloc 使用索引 获取从’2018-02-27’:’2018-02-22’，’open’的结果 # 使用loc:只能指定行列索引的名字 data.loc[&#39;2018-02-27&#39;:&#39;2018-02-22&#39;, &#39;open&#39;] 2018-02-27 23.53 2018-02-26 22.80 2018-02-23 22.88 Name: open, dtype: float64 # 使用iloc可以通过索引的下标去获取 # 获取前3天数据,前5列的结果 data.iloc[:3, :5] open high close low 2018-02-27 23.53 25.88 24.16 23.53 2018-02-26 22.80 23.78 23.53 22.80 2018-02-23 22.88 23.37 22.82 22.71 赋值操作对 DataFrame 当中的 close 列进行重新赋值为 1 # 直接修改原来的值 data[&#39;close&#39;] = 1 # 或者 data.close = 1 排序排序有两种形式，一种对于索引进行排序，一种对于内容进行排序 DataFrame 排序 使用 df.sort_values(by=, ascending=) 单个键或者多个键进行排序, 参数： by：指定排序参考的键 ascending:默认升序 ascending=False:降序 ascending=True:升序 # 按照开盘价大小进行排序 , 使用ascending指定按照大小排序 data.sort_values(by=&quot;open&quot;, ascending=True).head() # 按照多个键进行排序 data.sort_values(by=[&#39;open&#39;, &#39;high&#39;]) 使用 df.sort_index 给索引进行排序这个股票的日期索引原来是从大到小，现在重新排序，从小到大 # 对索引进行排序 data.sort_index() Series 排序 使用 series.sort_values(ascending=True)进行排序 series 排序时，只有一列，不需要参数 data[&#39;p_change&#39;].sort_values(ascending=True).head() 2015-09-01 -10.03 2015-09-14 -10.02 2016-01-11 -10.02 2015-07-15 -10.02 2015-08-26 -10.01 Name: p_change, dtype: float64 使用 series.sort_index()进行排序 与 df 一致 # 对索引进行排序 data[&#39;p_change&#39;].sort_index().head() 2015-03-02 2.62 2015-03-03 1.44 2015-03-04 1.57 2015-03-05 2.02 2015-03-06 8.51 Name: p_change, dtype: float64 DataFrame 运算算术运算 add(other) 比如进行数学运算加上具体的一个数字 data[&#39;open&#39;].add(1) 2018-02-27 24.53 2018-02-26 23.80 2018-02-23 23.88 2018-02-22 23.25 2018-02-14 22.49 sub(other) 逻辑运算2.1 逻辑运算符号 例如筛选 data[“open”] &gt; 23 的日期数据 data[“open”] &gt; 23 返回逻辑结果 data[&quot;open&quot;] &gt; 23 2018-02-27 True 2018-02-26 False 2018-02-23 False 2018-02-22 False 2018-02-14 False # 逻辑判断的结果可以作为筛选的依据 data[data[&quot;open&quot;] &gt; 23].head() 完成多个逻辑判断 data[(data[&quot;open&quot;] &gt; 23) &amp; (data[&quot;open&quot;] &lt; 24)].head() 2.2 逻辑运算函数 query(expr) expr:查询字符串 通过 query 使得刚才的过程更加方便简单 data.query(&quot;open&lt;24 &amp; open&gt;23&quot;).head() isin(values) 例如判断’open’是否为 23.53 和 23.85 # 可以指定值进行一个判断，从而进行筛选操作 data[data[&quot;open&quot;].isin([23.53, 23.85])] 统计运算3.1 describe 综合分析: 能够直接得出很多统计结果,count, mean, std, min, max 等 # 计算平均值、标准差、最大值、最小值 data.describe() 3.2 统计函数 Numpy 当中已经详细介绍，在这里我们演示 min(最小值), max(最大值), mean(平均值), median(中位数), var(方差), std(标准差),mode(众数)结果: 对于单个函数去进行统计的时候，坐标轴还是按照默认列“columns” (axis=0, default)，如果要对行“index” 需要指定(axis=1) max()、min() # 使用统计函数：0 代表列求结果， 1 代表行求统计结果 data.max(0) open 34.99 high 36.35 close 35.21 low 34.01 volume 501915.41 price_change 3.03 p_change 10.03 turnover 12.56 my_price_change 3.41 dtype: float64 std()、var() # 方差 data.var(0) open 1.545255e+01 high 1.662665e+01 close 1.554572e+01 low 1.437902e+01 volume 5.458124e+09 price_change 8.072595e-01 p_change 1.664394e+01 turnover 4.323800e+00 my_price_change 6.409037e-01 dtype: float64 # 标准差 data.std(0) open 3.930973 high 4.077578 close 3.942806 low 3.791968 volume 73879.119354 price_change 0.898476 p_change 4.079698 turnover 2.079375 my_price_change 0.800565 dtype: float64 median()：中位数中位数为将数据从小到大排列，在最中间的那个数为中位数。如果没有中间数，取中间两个数的平均值。 df = pd.DataFrame({&#39;COL1&#39; : [2,3,4,5,4,2], &#39;COL2&#39; : [0,1,2,3,4,2]}) df.median() COL1 3.5 COL2 2.0 dtype: float64 idxmax()、idxmin() # 求出最大值的位置 data.idxmax(axis=0) open 2015-06-15 high 2015-06-10 close 2015-06-12 low 2015-06-12 volume 2017-10-26 price_change 2015-06-09 p_change 2015-08-28 turnover 2017-10-26 my_price_change 2015-07-10 dtype: object # 求出最小值的位置 data.idxmin(axis=0) open 2015-03-02 high 2015-03-02 close 2015-09-02 low 2015-03-02 volume 2016-07-06 price_change 2015-06-15 p_change 2015-09-01 turnover 2016-07-06 my_price_change 2015-06-15 dtype: object 3.3 累计统计函数 以上这些函数可以对 series 和 dataframe 操作 这里我们按照时间的从前往后来进行累计 排序 # 排序之后，进行累计求和 data = data.sort_index() 对 p_change 进行求和 stock_rise = data[&#39;p_change&#39;] # plot方法集成了前面直方图、条形图、饼图、折线图 stock_rise.cumsum() 2015-03-02 2.62 2015-03-03 4.06 2015-03-04 5.63 2015-03-05 7.65 2015-03-06 16.16 2015-03-09 16.37 2015-03-10 18.75 2015-03-11 16.36 2015-03-12 15.03 2015-03-13 17.58 2015-03-16 20.34 2015-03-17 22.42 2015-03-18 23.28 2015-03-19 23.74 2015-03-20 23.48 2015-03-23 23.74 如果要使用 plot 函数，需要导入 matplotlib. import matplotlib.pyplot as plt # plot显示图形 stock_rise.cumsum().plot() # 需要调用show，才能显示出结果 plt.show() 自定义运算 apply(func, axis=0) func:自定义函数 axis=0:默认是列，axis=1 为行进行运算 定义一个对列，最大值-最小值的函数 data[[&#39;open&#39;, &#39;close&#39;]].apply(lambda x: x.max() - x.min(), axis=0) open 22.74 close 22.85 dtype: float64 Pandas 画图pandas.DataFrame.plot DataFrame.plot(kind=’line’) kind : str，需要绘制图形的种类 ‘line’ : line plot (default) ‘bar’ : vertical bar plot ‘barh’ : horizontal bar plot 关于“barh”的解释： http://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.plot.barh.html ‘hist’ : histogram ‘pie’ : pie plot ‘scatter’ : scatter plot 更多细节：pandas.DataFrame.plot pandas.Series.plot 更多细节：pandas.Series.plot 文件读取与存储我们的数据大部分存在于文件当中，所以 pandas 会支持复杂的 IO 操作，pandas 的 API 支持众多的文件格式，如 CSV、SQL、XLS、JSON、HDF5。 注：最常用的 HDF5 和 CSV 文件 CSV1.1 read_csv pandas.read_csv(filepath_or_buffer, sep =’,’, usecols ) filepath_or_buffer:文件路径 sep :分隔符，默认用”,”隔开 usecols:指定读取的列名，列表形式 举例：读取之前的股票的数据 # 读取文件,并且指定只获取&#39;open&#39;, &#39;close&#39;指标 data = pd.read_csv(&quot;./data/stock_day.csv&quot;, usecols=[&#39;open&#39;, &#39;close&#39;]) open close 2018-02-27 23.53 24.16 2018-02-26 22.80 23.53 2018-02-23 22.88 22.82 2018-02-22 22.25 22.28 2018-02-14 21.49 21.92 1.2 to_csv DataFrame.to_csv(path_or_buf=None, sep=’, ’, columns=None, header=True, index=True, mode=’w’, encoding=None) path_or_buf :文件路径 sep :分隔符，默认用”,”隔开 columns :选择需要的列索引 header :boolean or list of string, default True,是否写进列索引值 index:是否写进行索引 mode:’w’：重写, ‘a’ 追加 举例：保存读取出来的股票数据 保存&#39;open&#39;列的数据，然后读取查看结果 # 选取 10 行数据保存,便于观察数据 data[:10].to_csv(&quot;./data/test.csv&quot;, columns=[&#39;open&#39;]) # 读取，查看结果 pd.read_csv(&quot;./data/test.csv&quot;) Unnamed: 0 open 0 2018-02-27 23.53 1 2018-02-26 22.80 2 2018-02-23 22.88 3 2018-02-22 22.25 4 2018-02-14 21.49 5 2018-02-13 21.40 6 2018-02-12 20.70 7 2018-02-09 21.20 8 2018-02-08 21.79 9 2018-02-07 22.69 会发现将索引存入到文件当中，变成单独的一列数据。如果需要删除，可以指定 index 参数,删除原来的文件，重新保存一次。 # index:存储不会讲索引值变成一列数据 data[:10].to_csv(&quot;./data/test.csv&quot;, columns=[&#39;open&#39;], index=False) HDF52.1 read_hdf 与 to_hdf HDF5 文件的读取和存储需要指定一个键，值为要存储的 DataFrame pandas.read_hdf(path_or_buf，key =None，** kwargs) 从 h5 文件当中读取数据 path_or_buffer:文件路径 key:读取的键 return:Theselected object DataFrame.to*hdf(path_or_buf, key, *\\kwargs_) 2.2 案例 读取文件 day_close = pd.read_hdf(&quot;./data/day_close.h5&quot;) 如果读取的时候出现以下错误 需要安装安装 tables 模块避免不能读取 HDF5 文件 pip install tables 存储文件 day_close.to_hdf(&quot;./data/test.h5&quot;, key=&quot;day_close&quot;) 再次读取的时候, 需要指定键的名字 new_close = pd.read_hdf(&quot;./data/test.h5&quot;, key=&quot;day_close&quot;) 注意：优先选择使用 HDF5 文件存储 HDF5 在存储的时候支持压缩，使用的方式是 blosc，这个是速度最快的也是 pandas 默认支持的 使用压缩可以提高磁盘利用率，节省空间 HDF5 还是跨平台的，可以轻松迁移到 hadoop 上面 JSONJSON 是我们常用的一种数据交换格式，前面在前后端的交互经常用到，也会在存储的时候选择这种格式。所以我们需要知道 Pandas 如何进行读取和存储 JSON 格式。 3.1 read_json pandas.read_json(path_or_buf=None, orient=None, typ=’frame’, lines=False) 将 JSON 格式准换成默认的 Pandas DataFrame 格式 orient : string,Indication of expected JSON string format. ‘split’ : dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]} split 将索引总结到索引，列名到列名，数据到数据。将三部分都分开了 ‘records’ : list like [{column -&gt; value}, … , {column -&gt; value}] records 以 columns：values 的形式输出 ‘index’ : dict like {index -&gt; {column -&gt; value}} index 以 index：{columns：values}…的形式输出 ‘columns’ : dict like {column -&gt; {index -&gt; value}},默认该格式 colums 以 columns:{index:values}的形式输出 ‘values’ : just the values array values 直接输出值 lines : boolean, default False 按照每行读取 json 对象 typ : default ‘frame’， 指定转换成的对象类型 series 或者 dataframe 3.2 read_josn 案例 数据介绍 这里使用一个新闻标题讽刺数据集，格式为 json。is_sarcastic：1 讽刺的，否则为 0；headline：新闻报道的标题；article_link：链接到原始新闻文章。存储格式为： {&quot;article_link&quot;: &quot;https://www.huffingtonpost.com/entry/versace-black-code_us_5861fbefe4b0de3a08f600d5&quot;, &quot;headline&quot;: &quot;former versace store clerk sues over secret &#39;black code&#39; for minority shoppers&quot;, &quot;is_sarcastic&quot;: 0} {&quot;article_link&quot;: &quot;https://www.huffingtonpost.com/entry/roseanne-revival-review_us_5ab3a497e4b054d118e04365&quot;, &quot;headline&quot;: &quot;the &#39;roseanne&#39; revival catches up to our thorny political mood, for better and worse&quot;, &quot;is_sarcastic&quot;: 0} 读取orient 指定存储的 json 格式，lines 指定按照行去变成一个样本 json_read = pd.read_json(&quot;./data/Sarcasm_Headlines_Dataset.json&quot;, orient=&quot;records&quot;, lines=True)结果为： 3.3 to_json DataFrame.to_json(path_or_buf=None, orient=None, lines=False) 将 Pandas 对象存储为 json 格式 path_or_buf=None：文件地址 orient:存储的 json 形式，{‘split’,’records’,’index’,’columns’,’values’} lines:一个对象存储为一行 3.4 案例 存储文件 json_read.to_json(&quot;./data/test.json&quot;, orient=&#39;records&#39;)结果 [{&quot;article_link&quot;:&quot;https:\\/\\/www.huffingtonpost.com\\/entry\\/versace-black-code_us_5861fbefe4b0de3a08f600d5&quot;,&quot;headline&quot;:&quot;former versace store clerk sues over secret &#39;black code&#39; for minority shoppers&quot;,&quot;is_sarcastic&quot;:0},{&quot;article_link&quot;:&quot;https:\\/\\/www.huffingtonpost.com\\/entry\\/roseanne-revival-review_us_5ab3a497e4b054d118e04365&quot;,&quot;headline&quot;:&quot;the &#39;roseanne&#39; revival catches up to our thorny political mood, for better and worse&quot;,&quot;is_sarcastic&quot;:0},{&quot;article_link&quot;:&quot;https:\\/\\/local.theonion.com\\/mom-starting-to-fear-son-s-web-series-closest-thing-she-1819576697&quot;,&quot;headline&quot;:&quot;mom starting to fear son&#39;s web series closest thing she will have to grandchild&quot;,&quot;is_sarcastic&quot;:1},{&quot;article_link&quot;:&quot;https:\\/\\/politics.theonion.com\\/boehner-just-wants-wife-to-listen-not-come-up-with-alt-1819574302&quot;,&quot;headline&quot;:&quot;boehner just wants wife to listen, not come up with alternative debt-reduction ideas&quot;,&quot;is_sarcastic&quot;:1},{&quot;article_link&quot;:&quot;https:\\/\\/www.huffingtonpost.com\\/entry\\/jk-rowling-wishes-snape-happy-birthday_us_569117c4e4b0cad15e64fdcb&quot;,&quot;headline&quot;:&quot;j.k. rowling wishes snape happy birthday in the most magical way&quot;,&quot;is_sarcastic&quot;:0},{&quot;article_link&quot;:&quot;https:\\/\\/www.huffingtonpost.com\\/entry\\/advancing-the-worlds-women_b_6810038.html&quot;,&quot;headline&quot;:&quot;advancing the world&#39;s women&quot;,&quot;is_sarcastic&quot;:0},....] 修改 lines 参数为 True json_read.to_json(&quot;./data/test.json&quot;, orient=&#39;records&#39;, lines=True)结果 {&quot;article_link&quot;:&quot;https:\\/\\/www.huffingtonpost.com\\/entry\\/versace-black-code_us_5861fbefe4b0de3a08f600d5&quot;,&quot;headline&quot;:&quot;former versace store clerk sues over secret &#39;black code&#39; for minority shoppers&quot;,&quot;is_sarcastic&quot;:0} {&quot;article_link&quot;:&quot;https:\\/\\/www.huffingtonpost.com\\/entry\\/roseanne-revival-review_us_5ab3a497e4b054d118e04365&quot;,&quot;headline&quot;:&quot;the &#39;roseanne&#39; revival catches up to our thorny political mood, for better and worse&quot;,&quot;is_sarcastic&quot;:0} {&quot;article_link&quot;:&quot;https:\\/\\/local.theonion.com\\/mom-starting-to-fear-son-s-web-series-closest-thing-she-1819576697&quot;,&quot;headline&quot;:&quot;mom starting to fear son&#39;s web series closest thing she will have to grandchild&quot;,&quot;is_sarcastic&quot;:1} {&quot;article_link&quot;:&quot;https:\\/\\/politics.theonion.com\\/boehner-just-wants-wife-to-listen-not-come-up-with-alt-1819574302&quot;,&quot;headline&quot;:&quot;boehner just wants wife to listen, not come up with alternative debt-reduction ideas&quot;,&quot;is_sarcastic&quot;:1} {&quot;article_link&quot;:&quot;https:\\/\\/www.huffingtonpost.com\\/entry\\/jk-rowling-wishes-snape-happy-birthday_us_569117c","tags":[{"name":"Python","slug":"Python","permalink":"https://www.flaglee.cn/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.flaglee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://www.flaglee.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://www.flaglee.cn/tags/Matplotlib/"},{"name":"Numpy","slug":"Numpy","permalink":"https://www.flaglee.cn/tags/Numpy/"},{"name":"Pandas","slug":"Pandas","permalink":"https://www.flaglee.cn/tags/Pandas/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","permalink":"https://www.flaglee.cn/tags/Jupyter-Notebook/"}]},{"title":"机器学习基础知识(二)：Numpy的使用","date":"2020-09-25T01:30:27.000Z","path":"2020/09/25/机器学习基础知识-二-：Numpy的使用/","text":"Numpy（Numerical Python）是一个开源的 Python 科学计算库，用于快速处理任意维度的数组。 Numpy 支持常见的数组和矩阵操作。对于同样的数值计算任务，使用 Numpy 比直接使用 Python 要简洁的多。 Numpy 使用 ndarray 对象来处理多维数组，该对象是一个快速而灵活的大数据容器。 NumPy 提供了一个N 维数组类型 ndarray，它描述了相同类型的“items”的集合。 Numpy 的使用用 ndarray 进行存储： import numpy as np # 创建ndarray score = np.array( [[80, 89, 86, 67, 79], [78, 97, 89, 67, 81], [90, 94, 78, 67, 74], [91, 91, 90, 67, 69], [76, 87, 75, 67, 86], [70, 79, 84, 67, 84], [94, 92, 93, 67, 64], [86, 85, 83, 67, 80]]) score 返回结果： array([[80, 89, 86, 67, 79], [78, 97, 89, 67, 81], [90, 94, 78, 67, 74], [91, 91, 90, 67, 69], [76, 87, 75, 67, 86], [70, 79, 84, 67, 84], [94, 92, 93, 67, 64], [86, 85, 83, 67, 80]]) 机器学习的最大特点就是大量的数据运算，那么如果没有一个快速的解决方案，那可能现在 python 也在机器学习领域达不到好的效果。 Numpy 专门针对 ndarray 的操作和运算进行了设计，所以数组的存储效率和输入输出性能远优于 Python 中的嵌套列表，数组越大，Numpy 的优势就越明显。 ndarray 的优势内存块风格ndarray 跟原生 python 列表的不同: 从图中我们可以看出 ndarray 在存储数据的时候，数据与数据的地址都是连续的，这样就给使得批量操作数组元素时速度更快。 这是因为 ndarray 中的所有元素的类型都是相同的，而 Python 列表中的元素类型是任意的，所以 ndarray 在存储元素时内存可以连续，而 python 原生 list 就只能通过寻址方式找到下一个元素，这虽然也导致了在通用性能方面 Numpy 的 ndarray 不及 Python 原生 list，但在科学计算中，Numpy 的 ndarray 就可以省掉很多循环语句，代码使用方面比 Python 原生 list 简单的多。 ndarray 支持并行化运算（向量化运算）numpy 内置了并行运算功能，当系统有多个核心时，做某种计算时，numpy 会自动做并行计算 效率远高于纯 Python 代码Numpy 底层使用 C 语言编写，内部解除了 GIL（全局解释器锁），其对数组的操作速度不受 Python 解释器的限制，所以，其效率远高于纯 Python 代码。 N 维数组-ndarray1 ndarray 的属性 2 ndarray 的形状 首先创建一些数组，分别打印出形状。 # 创建不同形状的数组 &gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]]) &gt;&gt;&gt; b = np.array([1,2,3,4]) &gt;&gt;&gt; c = np.array([[[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]]]) &gt;&gt;&gt; a.shape &gt;&gt;&gt; b.shape &gt;&gt;&gt; c.shape (2, 3) # 二维数组 (4,) # 一维数组 (2, 2, 3) # 三维数组 如何理解数组的形状？ 二维数组： 三维数组： 3 ndarray 的类型 &gt;&gt;&gt; type(score.dtype) &lt;type &#39;numpy.dtype&#39;&gt; dtype 是 numpy.dtype 类型，先看看对于数组来说都有哪些类型 创建数组的时候指定类型 &gt;&gt;&gt; a = np.array([[1, 2, 3],[4, 5, 6]], dtype=np.float32) &gt;&gt;&gt; a.dtype dtype(&#39;float32&#39;) &gt;&gt;&gt; arr = np.array([&#39;python&#39;, &#39;tensorflow&#39;, &#39;scikit-learn&#39;, &#39;numpy&#39;], dtype = np.string_) &gt;&gt;&gt; arr array([b&#39;python&#39;, b&#39;tensorflow&#39;, b&#39;scikit-learn&#39;, b&#39;numpy&#39;], dtype=&#39;|S12&#39;) 注意：若不指定，整数默认 int64，小数默认 float64 基本操作生成数组的方法生成 0 和 1 的数组 np.ones(shape, dtype) np.ones_like(a, dtype) np.zeros(shape, dtype) np.zeros_like(a, dtype) ones = np.ones((4,8)) ones 返回结果: array([[1., 1., 1., 1., 1., 1., 1., 1.], [1., 1., 1., 1., 1., 1., 1., 1.], [1., 1., 1., 1., 1., 1., 1., 1.], [1., 1., 1., 1., 1., 1., 1., 1.]]) np.zeros_like(ones) 返回结果: array([[0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0.]]) 从现有数组生成 生成方式 np.array(object, dtype) np.asarray(a, dtype) a = np.array([[1,2,3],[4,5,6]]) # 从现有的数组当中创建 a1 = np.array(a) # 相当于索引的形式，并没有真正的创建一个新的 a2 = np.asarray(a) 关于 array 和 asarray 的不同 生成固定范围的数组 np.linspace (start, stop, num, endpoint) 创建等差数组 — 指定数量 参数: start:序列的起始值 stop:序列的终止值 num:要生成的等间隔样例数量，默认为 50 endpoint:序列中是否包含 stop 值，默认为 ture # 生成等间隔的数组 np.linspace(0, 100, 11) 返回结果： array([ 0., 10., 20., 30., 40., 50., 60., 70., 80., 90., 100.]) np.arange(start,stop, step, dtype) 创建等差数组 — 指定步长 参数 step:步长,默认值为 1 np.arange(10, 50, 2) 返回结果： array([10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,44, 46, 48]) np.logspace(start,stop, num) 创建等比数列 参数: num:要生成的等比数列数量，默认为 50 # 生成10^x np.logspace(0, 2, 3) 返回结果: array([ 1., 10., 100.]) 生成随机数组 正态分布创建方式: np.random.randn(d0, d1, …, dn) 功能：从标准正态分布中返回一个或多个样本值 np.random.normal(loc=0.0, scale=1.0, size=None) loc：float 此概率分布的均值（对应着整个分布的中心 centre） scale：float 此概率分布的标准差（对应于分布的宽度，scale 越大越矮胖，scale 越小，越瘦高） size：int or tuple of ints 输出的 shape，默认为 None，只输出一个值 np.random.standard_normal(size=None) 返回指定形状的标准正态分布的数组。 举例：生成均值为 1.75，标准差为 1 的正态分布数据，100000000 个 x1 = np.random.normal(1.75, 1, 100000000) 返回结果： array([2.90646763, 1.46737886, 2.21799024, ..., 1.56047411, 1.87969135,0.9028096 ]) # 生成均匀分布的随机数 x1 = np.random.normal(1.75, 1, 100000000) # 画图看分布状况 # 1）创建画布 plt.figure(figsize=(20, 10), dpi=100) # 2）绘制直方图 plt.hist(x1, 1000) # 3）显示图像 plt.show() 均匀分布创建方式 np.random.rand(d0, d1, …, dn) 返回[0.0，1.0)内的一组均匀分布的数。 np.random.uniform(low=0.0, high=1.0, size=None) 功能：从一个均匀分布[low,high)中随机采样，注意定义域是左闭右开，即包含 low，不包含 high. 参数介绍: low: 采样下界，float 类型，默认值为 0； high: 采样上界，float 类型，默认值为 1； size: 输出样本数目，为 int 或元组(tuple)类型，例如，size=(m,n,k), 则输出 mnk 个样本，缺省时输出 1 个值。 返回值：ndarray 类型，其形状和参数 size 中描述一致。 np.random.randint(low, high=None, size=None, dtype=’l’) 从一个均匀分布中随机采样，生成一个整数或 N 维整数数组， 取数范围：若 high 不为 None 时，取[low,high)之间随机整数，否则取值[0,low)之间随机整数。 # 生成均匀分布的随机数 x2 = np.random.uniform(-1, 1, 100000000) 返回结果： array([ 0.22411206, 0.31414671, 0.85655613, ..., -0.92972446, 0.95985223, 0.23197723]) 画图看分布状况： import matplotlib.pyplot as plt # 生成均匀分布的随机数 x2 = np.random.uniform(-1, 1, 100000000) # 画图看分布状况 # 1）创建画布 plt.figure(figsize=(10, 10), dpi=100) # 2）绘制直方图 plt.hist(x=x2, bins=1000) # x代表要使用的数据，bins表示要划分区间数 # 3）显示图像 plt.show() 数组的索引、切片一维、二维、三维的数组如何索引？ 直接进行索引,切片 对象[:, :] – 先行后列 二维数组索引方式： 举例：获取第一个股票的前 3 个交易日的涨跌幅数据 # 二维的数组，两个维度 stock_change[0, 0:3] 返回结果： array([-0.03862668, -1.46128096, -0.75596237]) 三维数组索引方式： # 三维 a1 = np.array([ [[1,2,3],[4,5,6]], [[12,3,34],[5,6,7]]]) # 返回结果 array([[[ 1, 2, 3], [ 4, 5, 6]], [[12, 3, 34], [ 5, 6, 7]]]) # 索引、切片 &gt;&gt;&gt; a1[0, 0, 1] # 输出: 2 形状修改 ndarray.reshape(shape, order) 返回一个具有相同数据域，但 shape 不一样的视图 行、列不进行互换 # 在转换形状的时候，一定要注意数组的元素匹配 stock_change.reshape([5, 4]) stock_change.reshape([-1,10]) # 数组的形状被修改为: (2, 10), -1: 表示通过待计算 ndarray.resize(new_shape) 修改数组本身的形状（需要保持元素个数前后相同） 行、列不进行互换 stock_change.resize([5, 4]) # 查看修改后结果 stock_change.shape (5, 4) ndarray.T 数组的转置 将数组的行、列进行互换 stock_change.T.shape (4, 5) 类型修改 ndarray.astype(type) 返回修改了类型之后的数组 stock_change.astype(np.int32) ndarray.tostring([order])或者 ndarray.tobytes([order]) 构造包含数组中原始数据字节的 Python 字节 arr = np.array([[[1, 2, 3], [4, 5, 6]], [[12, 3, 34], [5, 6, 7]]]) arr.tostring() jupyter 输出太大可能导致崩溃问题如果遇到 IOPub data rate exceeded. The notebook server will temporarily stop sending output to the client in order to avoid crashing it. To change this limit, set the config variable `--NotebookApp.iopub_data_rate_limit`.这个问题是在 jupyer 当中对输出的字节数有限制，需要去修改配置文件 创建配置文件 jupyter notebook --generate-config vi ~/.jupyter/jupyter_notebook_config.py取消注释,多增加 ## (bytes/sec) Maximum rate at which messages can be sent on iopub before they # are limited. c.NotebookApp.iopub_data_rate_limit = 10000000但是不建议这样去修改，jupyter 输出太大会崩溃 数组的去重np.unique() temp = np.array([[1, 2, 3, 4],[3, 4, 5, 6]]) &gt;&gt;&gt; np.unique(temp) array([1, 2, 3, 4, 5, 6]) ndarray 运算逻辑运算# 生成10名同学，5门功课的数据 &gt;&gt;&gt; score = np.random.randint(40, 100, (10, 5)) # 取出最后4名同学的成绩，用于逻辑判断 &gt;&gt;&gt; test_score = score[6:, 0:5] # 逻辑判断, 如果成绩大于60就标记为True 否则为False &gt;&gt;&gt; test_score &gt; 60 array([[ True, True, True, False, True], [ True, True, True, False, True], [ True, True, False, False, True], [False, True, True, True, True]]) # BOOL赋值, 将满足条件的设置为指定的值-布尔索引 &gt;&gt;&gt; test_score[test_score &gt; 60] = 1 &gt;&gt;&gt; test_score array([[ 1, 1, 1, 52, 1], [ 1, 1, 1, 59, 1], [ 1, 1, 44, 44, 1], [59, 1, 1, 1, 1]]) 通用判断函数 np.all() # 判断前两名同学的成绩[0:2, :]是否全及格 &gt;&gt;&gt; np.all(score[0:2, :] &gt; 60) False np.any() # 判断前两名同学的成绩[0:2, :]是否有大于90分的 &gt;&gt;&gt; np.any(score[0:2, :] &gt; 80) True np.where（三元运算符）通过使用 np.where 能够进行更加复杂的运算 np.where() # 判断前四名学生,前四门课程中，成绩中大于60的置为1，否则为0 temp = score[:4, :4] np.where(temp &gt; 60, 1, 0) 复合逻辑需要结合 np.logical_and 和 np.logical_or 使用 # 判断前四名学生,前四门课程中，成绩中大于60且小于90的换为1，否则为0 np.where(np.logical_and(temp &gt; 60, temp &lt; 90), 1, 0) # 判断前四名学生,前四门课程中，成绩中大于90或小于60的换为1，否则为0 np.where(np.logical_or(temp &gt; 90, temp &lt; 60), 1, 0) 统计运算如果想要知道学生成绩最大的分数，或者做小分数应该怎么做？ 统计指标在数据挖掘/机器学习领域，统计指标的值也是我们分析问题的一种方式。常用的指标如下： min(a, axis) Return the minimum of an array or minimum along an axis. max(a, axis]) Return the maximum of an array or maximum along an axis. median(a, axis) Compute the median along the specified axis. mean(a, axis, dtype) Compute the arithmetic mean along the specified axis. std(a, axis, dtype) Compute the standard deviation along the specified axis. var(a, axis, dtype) Compute the variance along the specified axis. 案例：学生成绩统计运算 进行统计的时候，axis 轴的取值并不一定，Numpy 中不同的 API 轴的值都不一样，在这里，axis 0 代表列, axis 1 代表行去进行统计 # 接下来对于前四名学生,进行一些统计运算 # 指定列 去统计 temp = score[:4, 0:5] print(&quot;前四名学生,各科成绩的最大分：{}&quot;.format(np.max(temp, axis=0))) print(&quot;前四名学生,各科成绩的最小分：{}&quot;.format(np.min(temp, axis=0))) print(&quot;前四名学生,各科成绩波动情况：{}&quot;.format(np.std(temp, axis=0))) print(&quot;前四名学生,各科成绩的平均分：{}&quot;.format(np.mean(temp, axis=0))) 结果： 前四名学生,各科成绩的最大分：[96 97 72 98 89] 前四名学生,各科成绩的最小分：[55 57 45 76 77] 前四名学生,各科成绩波动情况：[16.25576821 14.92271758 10.40432602 8.0311892 4.32290412] 前四名学生,各科成绩的平均分：[78.5 75.75 62.5 85. 82.25] 如果需要统计出某科最高分对应的是哪个同学？ np.argmax(temp, axis=) np.argmin(temp, axis=) print(&quot;前四名学生，各科成绩最高分对应的学生下标：{}&quot;.format(np.argmax(temp, axis=0))) 结果： 前四名学生，各科成绩最高分对应的学生下标：[0 2 0 0 1] 数组间运算数组与数的运算arr = np.array([[1, 2, 3, 2, 1, 4], [5, 6, 1, 2, 3, 1]]) arr + 1 Out[1]: array([[2, 3, 4, 3, 2, 5], [6, 7, 2, 3, 4, 2]]) arr / 2 Out[2]: array([[0.5, 1. , 1.5, 1. , 0.5, 2. ], [2.5, 3. , 0.5, 1. , 1.5, 0.5]]) # 可以对比python列表的运算，看出区别 a = [1, 2, 3, 4, 5] a * 3 Out[3]: [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5] 数组与数组的运算广播机制 数组在进行矢量化运算时，要求数组的形状是相等的。当形状不相等的数组执行算术运算的时候，就会出现广播机制，该机制会对数组进行扩展，使数组的 shape 属性值一样，这样，就可以进行矢量化运算了。下面通过一个例子进行说明： arr1 = np.array([[0],[1],[2],[3]]) arr1.shape # (4, 1) arr2 = np.array([1,2,3]) arr2.shape # (3,) arr1+arr2 # 结果是： array([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]) 上述代码中，数组 arr1 是 4 行 1 列，arr2 是 1 行 3 列。这两个数组要进行相加，按照广播机制会对数组 arr1 和 arr2 都进行扩展，使得数组 arr1 和 arr2 都变成 4 行 3 列。 下面通过一张图来描述广播机制扩展数组的过程： 广播机制实现了时两个或两个以上数组的运算，即使这些数组的 shape 不是完全相同的，只需要满足如下任意一个条件即可。 1.数组的某一维度等长。 2.其中一个数组的某一维度为 1 。 广播机制需要扩展维度小的数组，使得它与维度最大的数组的 shape 值相同，以便使用元素级函数或者运算符进行运算。 如果是下面这样，则不匹配： A (1d array): 10 B (1d array): 12 A (2d array): 2 x 1 B (3d array): 8 x 4 x 3矩阵乘法 api np.matmul np.dot &gt;&gt;&gt; a = np.array([[80, 86], [82, 80], [85, 78], [90, 90], [86, 82], [82, 90], [78, 80], [92, 94]]) &gt;&gt;&gt; b = np.array([[0.7], [0.3]]) &gt;&gt;&gt; np.matmul(a, b) array([[81.8], [81.4], [82.9], [90. ], [84.8], [84.4], [78.6], [92.6]]) &gt;&gt;&gt; np.dot(a,b) array([[81.8], [81.4], [82.9], [90. ], [84.8], [84.4], [78.6], [92.6]]) np.matmul 和 np.dot 的区别: 二者都是矩阵乘法。 np.matmul 中禁止矩阵与标量的乘法。 在矢量乘矢量的內积运算中，np.matmul 与 np.dot 没有区别。","tags":[{"name":"Python","slug":"Python","permalink":"https://www.flaglee.cn/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.flaglee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://www.flaglee.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://www.flaglee.cn/tags/Matplotlib/"},{"name":"Numpy","slug":"Numpy","permalink":"https://www.flaglee.cn/tags/Numpy/"},{"name":"Pandas","slug":"Pandas","permalink":"https://www.flaglee.cn/tags/Pandas/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","permalink":"https://www.flaglee.cn/tags/Jupyter-Notebook/"}]},{"title":"机器学习基础知识(一)：Jupyter Notebook与Matplotlib","date":"2020-09-18T01:16:43.000Z","path":"2020/09/18/机器学习基础知识-一-：Jupyter Notebook与matplotlib/","text":"机器学习是从数据中自动分析获得模型，并利用模型对未知数据进行预测。机器学习研究和构建的是一种特殊算法（而非某一个特定的算法），能够让计算机自己在数据中学习从而进行预测。机器学习是人工智能的一个实现途径,深度学习是机器学习的一个方法发展而来。本文主要介绍机器学习基础知识及常用科学计算库(Numpy, Pandas 等)的使用 机器学习概念机器学习定义通过训练集，不断识别特征，不断建模，最后形成有效的模型，这个过程就叫“机器学习”。 机器学习基本思路 把现实生活中的问题抽象成数学模型，并且很清楚模型中不同参数的作用 利用数学方法对这个数学模型进行求解，从而解决现实生活中的问题 评估这个数学模型，是否真正的解决了现实生活中的问题，解决的如何？ 机器学习分类机器学习根据训练方法大致可以分为 3 大类： 监督学习 非监督学习 强化学习 此外的“半监督学习”之类的说法，都是基于上面 3 类的变种，本质没有改变。 监督学习 监督学习是指我们给算法一个数据集，并且给定正确答案。机器通过数据来学习正确答案的计算方法。这种通过大量人工打标签来帮助机器学习的方式就是监督学习。这种学习方式效果非常好，但是成本也非常高。 非监督学习 非监督学习中，给定的数据集没有“正确答案”，所有的数据都是一样的。无监督学习的任务是从给定的数据集中，挖掘出潜在的结构。比如，通过学习，机器会把一堆猫和狗照片分为 2 类，一类都是猫的照片，一类都是狗的照片。与监督学习有着本质的差别：非监督学习中，虽然照片分为了猫和狗，但是机器并不知道哪个是猫，哪个是狗。对于机器来说，相当于分成了 A、B 两类。 强化学习 强化学习更接近生物学习的本质，因此有望获得更高的智能。它关注的是智能体如何在环境中采取一系列行为，从而获得最大的累积回报。通过强化学习，一个智能体应该知道在什么状态下应该采取什么行为。 机器学习常见算法决策树算法决策树及其变种是一类将输入空间分成不同的区域，每个区域有独立参数的算法。决策树算法充分利用了树形模型，根节点到一个叶子节点是一条分类的路径规则，每个叶子节点象征一个判断类别。先将样本分成不同的子集，再进行分割递推，直至每个子集得到同类型的样本，从根节点开始测试，到子树再到叶子节点，即可得出预测类别。此方法的特点是结构简单、处理数据效率较高。 朴素贝叶斯算法朴素贝叶斯算法是一种分类算法。它不是单一算法，而是一系列算法，它们都有一个共同的原则，即被分类的每个特征都与任何其他特征的值无关。朴素贝叶斯分类器认为这些“特征”中的每一个都独立地贡献概率，而不管特征之间的任何相关性。然而，特征并不总是独立的，这通常被视为朴素贝叶斯算法的缺点。简而言之，朴素贝叶斯算法允许我们使用概率给出一组特征来预测一个类。与其他常见的分类方法相比，朴素贝叶斯算法需要的训练很少。在进行预测之前必须完成的唯一工作是找到特征的个体概率分布的参数，这通常可以快速且确定地完成。这意味着即使对于高维数据点或大量数据点，朴素贝叶斯分类器也可以表现良好。 支持向量机算法基本思想可概括如下：首先，要利用一种变换将空间高维化，当然这种变换是非线性的，然后，在新的复杂空间取最优线性分类表面。由此种方式获得的分类函数在形式上类似于神经网络算法。支持向量机是统计学习领域中一个代表性算法，但它与传统方式的思维方法很不同，输入空间、提高维度从而将问题简短化，使问题归结为线性可分的经典解问题。支持向量机应用于垃圾邮件识别，人脸识别等多种分类问题。 随机森林算法控制数据树生成的方式有多种，根据前人的经验，大多数时候更倾向选择分裂属性和剪枝，但这并不能解决所有问题，偶尔会遇到噪声或分裂属性过多的问题。基于这种情况，总结每次的结果可以得到袋外数据的估计误差，将它和测试样本的估计误差相结合可以评估组合树学习器的拟合及预测精度。此方法的优点有很多，可以产生高精度的分类器，并能够处理大量的变数，也可以平衡分类资料集之间的误差。 人工神经网络算法人工神经网络与神经元组成的异常复杂的网络此大体相似，是个体单元互相连接而成，每个单元有数值量的输入和输出，形式可以为实数或线性组合函数。它先要以一种学习准则去学习，然后才能进行工作。当网络判断错误时，通过学习使其减少犯同样错误的可能性。此方法有很强的泛化能力和非线性映射能力，可以对信息量少的系统进行模型处理。从功能模拟角度看具有并行性，且传递信息速度极快。 Boosting 与 Bagging 算法Boosting 是种通用的增强基础算法性能的回归分析算法。不需构造一个高精度的回归分析，只需一个粗糙的基础算法即可，再反复调整基础算法就可以得到较好的组合回归模型。它可以将弱学习算法提高为强学习算法，可以应用到其它基础回归算法，如线性回归、神经网络等，来提高精度。Bagging 和前一种算法大体相似但又略有差别，主要想法是给出已知的弱学习算法和训练集，它需要经过多轮的计算，才可以得到预测函数列，最后采用投票方式对示例进行判别。 关联规则算法关联规则是用规则去描述两个变量或多个变量之间的关系，是客观反映数据本身性质的方法。它是机器学习的一大类任务，可分为两个阶段，先从资料集中找到高频项目组，再去研究它们的关联规则。其得到的分析结果即是对变量间规律的总结。 EM（期望最大化）算法在进行机器学习的过程中需要用到极大似然估计等参数估计方法，在有潜在变量的情况下，通常选择 EM 算法，不是直接对函数对象进行极大估计，而是添加一些数据进行简化计算，再进行极大化模拟。它是对本身受限制或比较难直接处理的数据的极大似然估计算法。 深度学习深度学习(DL, Deep Learning)是机器学习(ML, Machine Learning)领域中一个新的研究方向，它被引入机器学习使其更接近于最初的目标——人工智能(AI, Artificial Intelligence)。深度学习是学习样本数据的内在规律和表示层次，这些学习过程中获得的信息对诸如文字，图像和声音等数据的解释有很大的帮助。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。 深度学习是一个复杂的机器学习算法，在语音和图像识别方面取得的效果，远远超过先前相关技术。深度学习在搜索技术、数据挖掘、机器学习、机器翻译、自然语言处理、多媒体学习、语音、推荐和个性化技术，以及其他相关领域都取得了很多成果。深度学习使机器模仿视听和思考等人类的活动，解决了很多复杂的模式识别难题，使得人工智能相关技术取得了很大进步。 人工智能、机器学习、深度学习关系机器学习包含了很多种不同的算法，深度学习就是其中之一，其他方法包括决策树，聚类，贝叶斯等。 深度学习的灵感来自大脑的结构和功能，即许多神经元的互连。人工神经网络（ANN）是模拟大脑生物结构的算法。 不管是机器学习还是深度学习，都属于人工智能（AI）的范畴。 Jupyter NotebookJupyter Notebook 简介Jupyter 项目是一个非盈利的开源项目，源于 2014 年的 ipython 项目，因为它逐渐发展为支持跨所有编程语言的交互式数据科学和科学计算。 实时运行的代码、叙事性的文本和可视化被整合在一起，方便使用代码和数据来讲述故事，Jupyter Notebook 相比 Pycharm 在画图和数据展示方面更有优势。 Jupyter Notebook，原名 IPython Notbook，是 IPython 的加强网页版，一个开源 Web 应用程序 名字源自 Julia、Python 和 R（数据科学的三种开源语言） 是一款程序员和科学工作者的编程/文档/笔记/展示软件 .ipynb 文件格式是用于计算型叙述的 JSON 文档格式的正式规范 传统软件开发：工程／目标明确 需求分析，设计架构，开发模块，测试 数据挖掘：艺术／目标不明确 目的是具体的洞察目标，而不是机械的完成任务 通过执行代码来理解问题 迭代式地改进代码来改进解决方法 Jupyter Notebook 使用安装 安装 Jupyter Notebook 的前提是需要安装了 Python（3.3 版本及以上，或 2.7 版本）。 pip install jupyter启动 在终端中输入以下命令： jupyter notebook想让 notebook 打开指定目录，只要进入此目录后执行命令即可。 执行命令之后，在终端中将会显示一系列 notebook 的服务器信息，同时浏览器将会自动启动 Jupyter Notebook。 注意：之后在 Jupyter Notebook 的所有操作，都请保持终端不要关闭，因为一旦关闭终端，就会断开与本地服务器的链接，你将无法在 Jupyter Notebook 中进行其他操作啦。 新建 notebook 文档 notebook 的文档格式是.ipynb 点击标题（如 Untitled）修改文档名 Jupyter Notebook 操作cell 操作 什么是 cell？ cell：一对 In Out 会话被视作一个代码单元，称为 cell cell 行号前的 * ，表示 \b 代码正在运行 Jupyter 支持两种模式： 编辑模式（Enter） 命令模式下回车 Enter 或鼠标双击 cell 进入编辑模式 可以操作 cell 内文本或代码，剪切／复制／粘贴移动等操作 命令模式（Esc） 按 Esc 退出编辑，进入命令模式 可以操作 cell 单元本身进行剪切／复制／粘贴／移动等操作 鼠标操作 快捷键操作 两种模式通用快捷键 Shift+Enter，执行本单元代码，并跳转到下一单元 Ctrl+Enter，执行本单元代码，留在本单元 命令模式：按 ESC 进入 Y，cell 切换到 Code 模式 M，cell 切换到 Markdown 模式 A，在当前 cell 的上面添加 cell B，在当前 cell 的下面添加 cell 双击 D：删除当前 cell 编辑模式：按 Enter 进入 与常规方式一样 附： Jupyter Notebook 介绍、安装及使用教程 Matplotlib 是专门用于开发 2D 图表(包括 3D 图表) 以渐进、交互式方式实现数据可视化 Matplotlib 使用matplotlib.pytplot 包含了一系列类似于 matlab 的画图函数。 import matplotlib.pyplot as plt 图形绘制流程： 1.创建画布 – plt.figure() plt.figure(figsize=(), dpi=) figsize:指定图的长宽 dpi:图像的清晰度 返回fig对象 2.绘制图像 – plt.plot(x, y) 以折线图为例 3.显示图像 – plt.show() 基础绘图功能以折线图为例： import matplotlib.pyplot as plt import random from pylab import mpl # 设置显示中文字体 mpl.rcParams[&quot;font.sans-serif&quot;] = [&quot;SimHei&quot;] # 设置正常显示符号 mpl.rcParams[&quot;axes.unicode_minus&quot;] = False # 0.准备数据 x = range(60) y_shanghai = [random.uniform(15, 18) for i in x] # 1.创建画布 plt.figure(figsize=(20, 8), dpi=100) # 2.绘制图像 plt.plot(x, y_shanghai) # 2.1 添加x,y轴刻度 # 构造x,y轴刻度标签 x_ticks_label = [&quot;11点{}分&quot;.format(i) for i in x] y_ticks = range(40) # 刻度显示 plt.xticks(x[::5], x_ticks_label[::5]) plt.yticks(y_ticks[::5]) # 2.2 添加网格显示 plt.grid(True, linestyle=&quot;--&quot;, alpha=0.5) # 2.3 添加描述信息 plt.xlabel(&quot;时间&quot;) plt.ylabel(&quot;温度&quot;) plt.title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize=20) # 2.4 图像保存 plt.savefig(&quot;./test.png&quot;) # 3.图像显示 plt.show() 在一个坐标系中绘制多个图像多次 plot # 增加北京的温度数据 y_beijing = [random.uniform(1, 3) for i in x] # 绘制折线图 plt.plot(x, y_shanghai) # 使用多次plot可以画多个折线 plt.plot(x, y_beijing, color=&#39;r&#39;, linestyle=&#39;--&#39;) 设置图形风格 显示图例 如果只在 plt.plot()中设置 label 还不能最终显示出图例，还需要通过 plt.legend()将图例显示出来。 # 绘制折线图 plt.plot(x, y_shanghai, label=&quot;上海&quot;) # 使用多次plot可以画多个折线 plt.plot(x, y_beijing, color=&#39;r&#39;, linestyle=&#39;--&#39;, label=&quot;北京&quot;) # 显示图例 plt.legend(loc=&quot;best&quot;) 多个坐标系显示# 0.准备数据 x = range(60) y_shanghai = [random.uniform(15, 18) for i in x] y_beijing = [random.uniform(1, 5) for i in x] # 1.创建画布 # plt.figure(figsize=(20, 8), dpi=100) fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(20, 8), dpi=100) # 2.绘制图像 # plt.plot(x, y_shanghai, label=&quot;上海&quot;) # plt.plot(x, y_beijing, color=&quot;r&quot;, linestyle=&quot;--&quot;, label=&quot;北京&quot;) axes[0].plot(x, y_shanghai, label=&quot;上海&quot;) axes[1].plot(x, y_beijing, color=&quot;r&quot;, linestyle=&quot;--&quot;, label=&quot;北京&quot;) # 2.1 添加x,y轴刻度 # 构造x,y轴刻度标签 x_ticks_label = [&quot;11点{}分&quot;.format(i) for i in x] y_ticks = range(40) # 刻度显示 # plt.xticks(x[::5], x_ticks_label[::5]) # plt.yticks(y_ticks[::5]) axes[0].set_xticks(x[::5]) axes[0].set_yticks(y_ticks[::5]) axes[0].set_xticklabels(x_ticks_label[::5]) axes[1].set_xticks(x[::5]) axes[1].set_yticks(y_ticks[::5]) axes[1].set_xticklabels(x_ticks_label[::5]) # 2.2 添加网格显示 # plt.grid(True, linestyle=&quot;--&quot;, alpha=0.5) axes[0].grid(True, linestyle=&quot;--&quot;, alpha=0.5) axes[1].grid(True, linestyle=&quot;--&quot;, alpha=0.5) # 2.3 添加描述信息 # plt.xlabel(&quot;时间&quot;) # plt.ylabel(&quot;温度&quot;) # plt.title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize=20) axes[0].set_xlabel(&quot;时间&quot;) axes[0].set_ylabel(&quot;温度&quot;) axes[0].set_title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize=20) axes[1].set_xlabel(&quot;时间&quot;) axes[1].set_ylabel(&quot;温度&quot;) axes[1].set_title(&quot;中午11点--12点某城市温度变化图&quot;, fontsize=20) # # 2.4 图像保存 plt.savefig(&quot;./test.png&quot;) # # 2.5 添加图例 # plt.legend(loc=0) axes[0].legend(loc=0) axes[1].legend(loc=0) # 3.图像显示 plt.show() 常见图形绘制matplotlib 示例 散点图绘制 api：plt.scatter(x, y) # 0.准备数据 x = [225.98, 247.07, 253.14, 457.85, 241.58, 301.01, 20.67, 288.64, 163.56, 120.06, 207.83, 342.75, 147.9 , 53.06, 224.72, 29.51, 21.61, 483.21, 245.25, 399.25, 343.35] y = [196.63, 203.88, 210.75, 372.74, 202.41, 247.61, 24.9 , 239.34, 140.32, 104.15, 176.84, 288.23, 128.79, 49.64, 191.74, 33.1 , 30.74, 400.02, 205.35, 330.64, 283.45] # 1.创建画布 plt.figure(figsize=(20, 8), dpi=100) # 2.绘制散点图 plt.scatter(x, y) # 3.显示图像 plt.show() 柱状图绘制 api：plt.bar(x, width, align=’center’, **kwargs) Parameters: x : 需要传递的数据 width : 柱状图的宽度 align : 每个柱状图的位置对齐方式 {‘center’, ‘edge’}, optional, default: ‘center’ **kwargs : color:选择柱状图的颜色 # 0.准备数据 # 电影名字 movie_name = [&#39;雷神3：诸神黄昏&#39;,&#39;正义联盟&#39;,&#39;东方快车谋杀案&#39;,&#39;寻梦环游记&#39;,&#39;全球风暴&#39;,&#39;降魔传&#39;,&#39;追捕&#39;,&#39;七十七天&#39;,&#39;密战&#39;,&#39;狂兽&#39;,&#39;其它&#39;] # 横坐标 x = range(len(movie_name)) # 票房数据 y = [73853,57767,22354,15969,14839,8725,8716,8318,7916,6764,52222] # 1.创建画布 plt.figure(figsize=(20, 8), dpi=100) # 2.绘制柱状图 plt.bar(x, y, width=0.5, color=[&#39;b&#39;,&#39;r&#39;,&#39;g&#39;,&#39;y&#39;,&#39;c&#39;,&#39;m&#39;,&#39;y&#39;,&#39;k&#39;,&#39;c&#39;,&#39;g&#39;,&#39;b&#39;]) # 2.1b修改x轴的刻度显示 plt.xticks(x, movie_name) # 2.2 添加网格显示 plt.grid(linestyle=&quot;--&quot;, alpha=0.5) # 2.3 添加标题 plt.title(&quot;电影票房收入对比&quot;) # 3.显示图像 plt.show() 直方图 api：matplotlib.pyplot.hist(x, bins=None) Parameters: x : 需要传递的数据 bins : 组距 饼图 api：plt.pie(x, labels=,autopct=,colors) Parameters: x:数量，自动算百分比 labels:每部分名称 autopct:占比显示指定%1.2f%% colors:每部分颜色","tags":[{"name":"Python","slug":"Python","permalink":"https://www.flaglee.cn/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.flaglee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"深度学习","slug":"深度学习","permalink":"https://www.flaglee.cn/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Matplotlib","slug":"Matplotlib","permalink":"https://www.flaglee.cn/tags/Matplotlib/"},{"name":"Numpy","slug":"Numpy","permalink":"https://www.flaglee.cn/tags/Numpy/"},{"name":"Pandas","slug":"Pandas","permalink":"https://www.flaglee.cn/tags/Pandas/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","permalink":"https://www.flaglee.cn/tags/Jupyter-Notebook/"}]},{"title":"Python项目汇总","date":"2020-09-14T12:45:12.000Z","path":"2020/09/14/Python项目汇总/","text":"记录汇总个人的 Python 项目 外星人入侵 外星人入侵本项目是在阅览《Python 编程： 从入门到实践》时敲的练手项目，在本项目中，将在游戏《外星人入侵》中添加外星人。 首先，在屏幕上边缘附近添加一个外星人，然后生成一群外星人。 让这群外星人向两边和下面移动，并删除被子弹击中的外星人。 最后，将显示玩家拥有的飞船数量，并在玩家的飞船用完后结束游戏。 通过本项目，将更深入地了解 Pygame 和大型项目的管理，还将学习如何检测游戏对象之间的碰撞，如子弹和外星人之间的碰撞，检测碰撞有助于你定义游戏元素之间的交互：可以将角色限定在迷宫墙壁之内或在两个角色之间传球。我们将时不时地查看游戏开发计划， 以确保编程工作不偏离轨道。 本项目开源地址在https://github.com/FLAGLEE/Python_Project/tree/master/外星人入侵 settings.pyclass Settings(): &quot;&quot;&quot;存储《外星人入侵》所有设置的类&quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;初始化游戏的静态设置&quot;&quot;&quot; # 屏幕设置 self.screen_width = 1200 self.screen_height = 800 self.bg_color = (230, 230, 230) # 飞船的设置 self.ship_limit = 3 # 外星人设置 # 子弹的设置 self.bullet_width = 3 self.bullet_height = 15 self.bullet_color = 60, 60, 60 self.bullets_allowed = 3 # 以什么样的速度加快游戏节奏 self.speedup_scale = 1.1 # 外星人点数的提高速度 self.score_scale = 2 self.initialize_dynamic_settings() def initialize_dynamic_settings(self): &quot;&quot;&quot;初始化随游戏进行而变化的设置&quot;&quot;&quot; self.ship_speed_factor = 1.5 self.alien_speed_factor = 1 self.bullet_speed_factor = 3 self.fleet_drop_speed = 10 # fleet_direction为1表示向右移， 为-1表示向左移 self.fleet_direction = 1 # 记分 self.alien_score = 50 def increase_speed(self): &quot;&quot;&quot;提高速度设置和外星人点数&quot;&quot;&quot; self.ship_speed_factor *= self.speedup_scale self.alien_speed_factor *= self.speedup_scale self.bullet_speed_factor *= self.speedup_scale self.fleet_drop_speed *= self.speedup_scale self.alien_score = int(self.alien_score * self.score_scale) game_stats.pyimport pygame class GameStats(): &quot;&quot;&quot;跟踪游戏的统计信息&quot;&quot;&quot; def __init__(self, ai_settings): &quot;&quot;&quot;初始化统计信息&quot;&quot;&quot; self.ai_settings = ai_settings self.reset_stats() # 让游戏一开始处于非活动状态 self.game_active = False # 在任何情况下都不应重置最高得分 self.high_score = 0 def reset_stats(self): &quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot; self.ships_left = self.ai_settings.ship_limit self.score = 0 self.level = 1 score_board.pyimport pygame.font from pygame.sprite import Group from ship import Ship class Scoreboard(): &quot;&quot;&quot;显示得分信息的类&quot;&quot;&quot; def __init__(self, ai_settings, screen, stats): &quot;&quot;&quot;初始化显示得分涉及的属性&quot;&quot;&quot; self.screen = screen self.screen_rect = screen.get_rect() self.ai_settings = ai_settings self.stats = stats # 显示得分信息时使用的字体设置 self.text_color = (30, 30, 30) self.font = pygame.font.SysFont(None, 48) # 准备包含最高得分和当前得分的图像 self.prep_score() self.prep_high_score() self.prep_level() self.prep_ships() def prep_score(self): &quot;&quot;&quot;将得分转换为一幅渲染的图像&quot;&quot;&quot; score_str = &quot;{:,}&quot;.format(self.stats.score) self.score_image = self.font.render(score_str, True, self.text_color, self.ai_settings.bg_color) # 将得分放在屏幕右上角 self.score_rect = self.score_image.get_rect() self.score_rect.right = self.screen_rect.right - 20 self.score_rect.top = 20 def prep_high_score(self): high_score_str = &quot;{:,}&quot;.format(self.stats.high_score) self.high_score_image = self.font.render(high_score_str, True, self.text_color, self.ai_settings.bg_color) # 将得分放在屏幕上中央 self.high_score_rect = self.high_score_image.get_rect() self.high_score_rect.centerx = self.screen_rect.centerx self.high_score_rect.top = 20 def prep_level(self): &quot;&quot;&quot;将等级转换为渲染的图像&quot;&quot;&quot; self.level_image = self.font.render(str(self.stats.level), True, self.text_color, self.ai_settings.bg_color) # 将等级放在得分下方 self.level_rect = self.level_image.get_rect() self.level_rect.centerx = self.screen_rect.centerx self.level_rect.top = 20 def prep_ships(self): &quot;&quot;&quot;显示还余下多少艘飞船&quot;&quot;&quot; self.ships = Group() for ship_number in range(self.stats.ships_left): ship = Ship(self.ai_settings, self.screen) ship.rect.x = 10 + ship.rect.width * ship_number ship.rect.y = 10 self.ships.add(ship) def show_score(self): &quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot; self.screen.blit(self.score_image, self.score_rect) self.screen.blit(self.high_score_image, self.high_score_rect) self.screen.blit(self.level_image, self.level_rect) # 绘制飞船 self.ships.draw(self.screen) button.pyimport pygame.font class Button(): def __init__(self, ai_settings, screen, msg): &quot;&quot;&quot;初始化按钮的属性&quot;&quot;&quot; self.screen = screen self.screen_rect = screen.get_rect() # 设置按钮的尺寸和其他属性 self.width, self.height = 200, 50 self.button_color = (0, 250, 0) self.text_color = (255, 255, 255) self.font = pygame.font.SysFont(None, 48) # 创建按钮的rect对象， 并使其居中 self.rect = pygame.Rect(0, 0, self.width, self.height) self.rect.center = self.screen_rect.center # 按钮的标签只需创建一次 self.prep_msg(msg) def prep_msg(self, msg): &quot;&quot;&quot;将msg渲染为图像， 并使其在按钮上居中&quot;&quot;&quot; self.msg_image = self.font.render(msg, True, self.text_color, self.button_color) self.msg_image_rect = self.msg_image.get_rect() self.msg_image_rect.center = self.rect.center def draw_button(self): # 绘制一个用颜色填充的按钮， 再绘制文本 self.screen.fill(self.button_color, self.rect) self.screen.blit(self.msg_image, self.msg_image_rect) game_functions.pyimport sys from time import sleep import pygame from bullet import Bullet from alien import Alien def check_keydown_events(event, ai_settings, stats, play_button, screen, ship, bullets): &quot;&quot;&quot;响应按键&quot;&quot;&quot; if event.key == pygame.K_RIGHT: # 向右移动飞船 ship.moving_right = True elif event.key == pygame.K_LEFT: # 向左移动飞船 ship.moving_left = True elif event.key == pygame.K_SPACE: # 创建一颗子弹， 并将其加入到编组bullets中 fire_bullet(ai_settings, screen, ship, bullets) elif event.key == pygame.K_q: sys.exit() def check_play_button(ai_settings, screen, stats, play_button, sb, ship, aliens, bullets, mouse_x, mouse_y): &quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot; button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y) if button_clicked and not stats.game_active: # 重置游戏设置 ai_settings.initialize_dynamic_settings() # 重置游戏统计信息 stats.reset_stats() stats.game_active = True # 隐藏光标 pygame.mouse.set_visible(False) # 重置记分牌图像 sb.prep_score() # sb.prep_high_score() sb.prep_level() sb.prep_ships() # 清空外星人列表和子弹列表 aliens.empty() bullets.empty() # 创建一群新的外星人， 并让飞船居中 create_fleet(ai_settings, screen, ship, aliens) ship.center_ship() def fire_bullet(ai_settings, screen, ship, bullets): &quot;&quot;&quot;如果还没有到达限制， 就发射一颗子弹&quot;&quot;&quot; # 创建新子弹， 并将其加入到编组bullets中 if len(bullets) &lt; ai_settings.bullets_allowed: new_bullet = Bullet(ai_settings, screen, ship) bullets.add(new_bullet) def check_keyup_events(event, ship): &quot;&quot;&quot;响应按键&quot;&quot;&quot; if event.key == pygame.K_RIGHT: # 向右移动飞船 ship.moving_right = False elif event.key == pygame.K_LEFT: # 向左移动飞船 ship.moving_left = False def check_event(ai_settings, stats, play_button, screen, sb, ship, aliens, bullets): &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot; for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() elif event.type == pygame.MOUSEBUTTONDOWN: mouse_x, mouse_y = pygame.mouse.get_pos() check_play_button(ai_settings, screen, stats, play_button, sb, ship, aliens, bullets, mouse_x, mouse_y) elif event.type == pygame.KEYDOWN: check_keydown_events(event, ai_settings, stats, play_button, screen, ship, bullets) elif event.type == pygame.KEYUP: check_keyup_events(event, ship) def update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets, play_button): &quot;&quot;&quot;更新屏幕上的图像， 并切换到新屏幕&quot;&quot;&quot; # 设置背景色bg_color = (230, 230, 230) screen.fill(ai_settings.bg_color) # 在飞船和外星人后面重绘所有子弹 for bullet in bullets: bullet.draw_bullet() ship.blitme() # alien.blitme() aliens.draw(screen) # 显示得分 sb.show_score() # 如果游戏处于非活动状态， 就绘制Play按钮 if not stats.game_active: play_button.draw_button() # 让绘制的屏幕可见 pygame.display.flip() def get_number_aliens_x(ai_settings, alien_width): &quot;&quot;&quot;创建一个外星人， 并计算一行可容纳多少个外星人&quot;&quot;&quot; # 外星人间距为外星人宽度 available_space_x = ai_settings.screen_width - alien_width * 2 return int(available_space_x / (alien_width * 2)) def get_number_aliens_y(ai_settings, ship_height, alien_height): available_space_y = ai_settings.screen_height - alien_height * 3 - ship_height return int(available_space_y / (2 * alien_height)) def create_alien(ai_settings, screen, aliens, alien_number, alien_row): &quot;&quot;&quot;创建一个外星人并将其放在当前行&quot;&quot;&quot; alien = Alien(ai_settings, screen) alien_width = alien.rect.width alien.x = alien_width + 2 * alien_width * alien_number alien.rect.x = alien.x alien.rect.y = alien.rect.height + 2 * alien.rect.height * alien_row aliens.add(alien) def create_fleet(ai_settings, screen, ship, aliens): &quot;&quot;&quot;创建外星人群&quot;&quot;&quot; # 创建一个外星人， 并计算一行可容纳多少个外星人 alien = Alien(ai_settings, screen) alien_width = alien.rect.width alien_height = alien.rect.height ship_height = ship.rect.height number_aliens_x = get_number_aliens_x(ai_settings, alien_width) number_aliens_y = get_number_aliens_y(ai_settings, ship_height, alien_height) # 创建n行外星人 for alien_row in range(number_aliens_y): for alien_number in range(number_aliens_x): create_alien(ai_settings, screen, aliens, alien_number, alien_row) def check_fleet_edges(ai_settings, aliens): &quot;&quot;&quot;有外星人到达边缘时采取相应的措施&quot;&quot;&quot; for alien in aliens.sprites(): if alien.check_edge(): change_directions(ai_settings, aliens) break def change_directions(ai_settings, aliens): &quot;&quot;&quot;将整群外星人下移， 并改变它们的方向&quot;&quot;&quot; for alien in aliens.sprites(): alien.rect.y += ai_settings.fleet_drop_speed ai_settings.fleet_direction *= -1 def ship_hit(ai_settings, stats, screen, sb, ship, aliens, bullets): &quot;&quot;&quot;响应被外星人撞到的飞船&quot;&quot;&quot; if stats.ships_left &gt; 0: # 将ships_left减1 stats.ships_left -= 1 # 清空外星人列表和子弹列表 aliens.empty() bullets.empty() # 更新记分牌 sb.prep_ships() # 创建一群新的外星人， 并将飞船放到屏幕底端中央 create_fleet(ai_settings, screen, ship, aliens) ship.center_ship() # 暂停 sleep(0.5) else: stats.game_active = False pygame.mouse.set_visible(True) def update_aliens(ai_settings, stats, screen, sb, ship, aliens, bullets): &quot;&quot;&quot;检查是否有外星人位于屏幕边缘， 并更新整群外星人的位置&quot;&quot;&quot; check_fleet_edges(ai_settings, aliens) aliens.update() # 检测外星人和飞船之间的碰撞 if pygame.sprite.spritecollideany(ship, aliens): ship_hit(ai_settings, stats, screen, sb, ship, aliens, bullets) # 检查是否有外星人到达屏幕底端 check_aliens_bottom(ai_settings, stats, screen, sb, ship, aliens, bullets) def update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets): &quot;&quot;&quot;更新子弹的位置， 并删除已消失的子弹&quot;&quot;&quot; # 更新子弹的位置 bullets.update() # 删除已消失的子弹 for bullet in bullets.copy(): if bullet.rect.bottom &lt;= 0: bullets.remove(bullet) # 检查是否有子弹击中了外星人 check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, aliens, bullets) def check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, aliens, bullets): &quot;&quot;&quot;如果有子弹击中了外星，就删除相应的子弹和外星人&quot;&quot;&quot; collisions = pygame.sprite.groupcollide(bullets, aliens, True, True) if collisions: for alien in collisions.values(): stats.score += ai_settings.alien_score * len(alien) sb.prep_score() # check_high_score(stats, sb) if len(aliens) == 0: # 删除现有的子弹， 加快游戏节奏， 并创建一群新的外星人 bullets.empty() ai_settings.increase_speed() # 提高等级 stats.level += 1 sb.prep_level() create_fleet(ai_settings, screen, ship, aliens) def check_aliens_bottom(ai_settings, stats, screen, sb, ship, aliens, bullets): &quot;&quot;&quot;检查是否有外星人到达了屏幕底端&quot;&quot;&quot; screen_rect = screen.get_rect() for alien in aliens.sprites(): if alien.rect.bottom &gt;= screen_rect.bottom: # 像飞船被撞到一样进行处理 ship_hit(ai_settings, stats, screen, sb, ship, aliens, bullets) break def check_high_score(stats, sb): &quot;&quot;&quot;检查是否诞生了新的最高得分&quot;&quot;&quot; if stats.score &gt; stats.high_score: stats.high_score = stats.score sb.prep_high_score() ship.pyimport pygame from pygame.sprite import Sprite class Ship(Sprite): def __init__(self, ai_settings, screen): &quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot; super().__init__() self.screen = screen self.ai_settings = ai_settings # 加载飞船图像并获取其外接矩形 self.image = pygame.image.load(&#39;images/ship.bmp&#39;) self.rect = self.image.get_rect() self.screen_rect = screen.get_rect() # 将每艘新飞船放到屏幕底部中央 self.rect.centerx = self.screen_rect.centerx self.rect.bottom = self.screen_rect.bottom # 在飞船的属性center中存储小数值 self.center = float(self.rect.centerx) # 移动标志 self.moving_right = False self.moving_left = False def update(self): &quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot; if self.moving_right and self.rect.right &lt; self.screen_rect.right: self.center += self.ai_settings.ship_speed_factor if self.moving_left and self.rect.left &gt; 0: self.center -= self.ai_settings.ship_speed_factor # 根据self.center更新rect对象 self.rect.centerx = self.center def blitme(self): &quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot; self.screen.blit(self.image, self.rect) def center_ship(self): &quot;&quot;&quot;让飞船在屏幕上居中&quot;&quot;&quot; self.center = self.screen_rect.centerx bullet.pyimport pygame from pygame.sprite import Sprite class Bullet(Sprite): &quot;&quot;&quot;一个对飞船发射的子弹进行管理的类&quot;&quot;&quot; def __init__(self, ai_settings, screen, ship): &quot;&quot;&quot;在飞船所处的位置创建一个子弹对象&quot;&quot;&quot; super().__init__() self.screen = screen # 在(0,0)处创建一个表示子弹的矩形，再设置正确的位置 self.rect = pygame.Rect(0, 0, ai_settings.bullet_width, ai_settings.bullet_height) self.rect.centerx = ship.rect.centerx self.rect.top = ship.rect.top # 存储用小数表示的子弹位置 self.y = float(self.rect.y) self.color = ai_settings.bullet_color self.speed_factor = ai_settings.bullet_speed_factor def update(self): &quot;&quot;&quot;向上移动子弹&quot;&quot;&quot; # 更新表示子弹位置的小数值 self.y -= self.speed_factor # 更新表示子弹的rect的位置 self.rect.y = self.y def draw_bullet(self): &quot;&quot;&quot;绘制子弹&quot;&quot;&quot; pygame.draw.rect(self.screen, self.color, self.rect) alien_invasion.pyimport pygame from pygame.sprite import Group from settings import Settings from game_stats import GameStats from ship import Ship from button import Button from scoreboard import Scoreboard import game_functions as gf def run_game(): # 初始化游戏并创建一个屏幕对象 pygame.init() ai_settings = Settings() screen = pygame.display.set_mode((ai_settings.screen_width, ai_settings.screen_height)) pygame.display.set_caption(&quot;Alien Invasion&quot;) # 创建Play按钮 play_button = Button(ai_settings, screen, &quot;Play&quot;) # 创建存储游戏统计信息的实例， 并创建记分牌 stats = GameStats(ai_settings) sb = Scoreboard(ai_settings, screen, stats) # 创建一艘飞船 ship = Ship(ai_settings, screen) # 创建一个用于存储子弹的编组 bullets = Group() # 创建一个外星人 # alien = Alien(ai_settings, screen) # 创建一个外星人编组 aliens = Group() # 创建外星人群 gf.create_fleet(ai_settings, screen, ship, aliens) # 开始游戏主循环 while True: # 监视键盘和鼠标事件 gf.check_event(ai_settings, stats, play_button, screen, sb, ship, aliens, bullets) if stats.game_active: # 更新飞船状态 ship.update() # 更新子弹的位置， 并删除已消失的子弹 gf.update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets) # 更新外星人位置 gf.update_aliens(ai_settings, stats, screen, sb, ship, aliens, bullets) # 每次循环时都重绘屏幕 gf.update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets, play_button) if __name__ == &#39;__main__&#39;: run_game() 游戏示例","tags":[{"name":"Python","slug":"Python","permalink":"https://www.flaglee.cn/tags/Python/"},{"name":"项目","slug":"项目","permalink":"https://www.flaglee.cn/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"pygame","slug":"pygame","permalink":"https://www.flaglee.cn/tags/pygame/"}]},{"title":"C语言中内存分区与内存管理详解","date":"2020-09-08T01:00:36.000Z","path":"2020/09/08/C中内存分区与内存管理详解/","text":"c 语言五大内存分区 栈区（stack）:由编译器自动分配与释放，存放函数的参数值，局部变量，临时变量等等，它们获取的方式都是由编译器自动执行的 堆区（heap）:该区由程序员申请后使用，需要手动释放否则会造成内存泄漏。一般由程序员分配与释放，基程序员不释放，程序结束时可能由操作系统回收（C/C++没有此等回收机制，Java/C#有），注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 全局/静态存储区：存放全局变量和静态变量（包括静态全局变量与静态局部变量），全局变量和静态变量的存储是放在一块儿的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。 文字常量区：常量在统一运行被创建，常量区的内存是只读的，程序结束后由系统释放。 程序代码区：存放程序的二进制代码，内存由系统管理 c 语言五大内存分区栈区： 在函数中定义的变量存放的内存区域。 常见的 int、float、char 等变量均存放于栈区中，它的特点是由系统自动分配与释放，不需要程序员考虑资源回收的问题，方便简洁。 ps：栈区的地址分配是从内存的高地址开始向地地址分配。 堆区： 程序员通过指令自主向系统申请的内存区域，大小由程序员决定，它在使用完后同样需要程序员通过指令去释放该区域内存，否则将有可能出现内存的浪费与溢出。 C 语言中申请堆区指令为： int *p = (int *) malloc( N * sizeof(int) ); //分配N个int型（4字节） 的内存，即 4 * N 个字节 ps：但指针 p 存放于栈区。 C 语言中释放堆区指令为： free( p ); //注意此处参数为指针 使用中应该注意，尽量不要去修改 p 指针对应的地址值，否则在内存释放时将出现错误。（编译可通过，运行出现问题） 全局变量&amp;静态变量区： 全局变量与静态变量本应是两个概念，但由于它们在内存中存放的区域相同，所以将他们放在一起讨论。 全局变量： 位于所有函数外部定义的变量，在整个工程中可见，可修改。 静态变量： 位于所有函数内部定义的由 static 修饰的变量，仅在定义的函数中可见，可修改。（这是它与全局变量的关键区别） ps：静态变量仅在第一次创建时初始化一次，之后自动跳过初始化语句。 全局变量与静态变量均由系统分配和释放内存，若未对它们进行初始化操作，系统将自动将其值设置为 0。（堆区与栈区则不会） 文字常量区： 用于存放文字等不可修改的常量，由系统分配和释放内存。 常见的使用： char *s = &quot;HelloWorld&quot;;//该字符串 HelloWorld 即存放于文字常量区，不可修改 ps：但指针 s 存放于栈区。 pps：若在程序中尝试对其修改（例如尝试修改第一个字符 *s = ‘h’;），将出现编译可通过，运行报错的情况。 同时因注意它与 const 修饰的变量之间的区别： char aa = &#39;A&#39;;//aa存放于栈区 const char bb = &#39;B&#39;; //bb同样存放于栈区 const 修饰的变量仅仅用于告诉编译器 bb 是一个常量，如果后续的程序中有出现尝试修改 bb 的操作时，编译将报错。 这种写法主要是为了防止程序员在后续的代码中误操作 bb 变量而添加的一个约束条件，并不会影响它存放的位置。 程序代码区： 用于存储程序编译连接后生成的二进制机器码指令的内存区域。该部分内容可通过反汇编操作将机器码转换为汇编语言。 C 语言例子： #include &lt;stdio.h&gt; static unsigned int val1 = 1; //val1存放在.data段 unsigned int val2 = 1; //初始化的全局变量存放在.data段 unsigned int val3 ; //未初始化的全局变量存放在.bss段 const unsigned int val4 = 1; //val4存放在.rodata（只读数据段） unsigned char Demo(unsigned int num) //num 存放在栈区 { char var = &quot;123456&quot;; //var存放在栈区，&quot;123456&quot;存放在常量区 unsigned int num1 = 1 ; //num1存放在栈区 static unsigned int num2 = 0; //num2存放在.data段 const unsigned int num3 = 7; //num3存放在栈区 void *p; p = malloc(8); //p存放在堆区 free(p); return 1; } void main() { unsigned int num = 0 ; num = Demo(num); //Demo()函数的返回值存放在栈区。 } 可执行程序程序三段一个程序的 3 个基本段：text 段，dtae 段，bss 段 text 段在内存中被映射为只读，但 date 段与 bss 段是可写的 text 段：代码段，就是放程序代码的，编译时确定，只读 date 段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域 bss 段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。 可执行程序程序三段与五大分区两者之间区别是： 代码段，数据段，堆栈段是 cpu 级别的概念 五大分区属于语言级别的概念，两者是不同的概念。 存储类型关键字定义变量与函数作用域与生命周期 auto 变量：函数的局部变量，如果没有声明为 static,函数中定义的局部变量全部为 auto 类型，auto 变量包括未加 static 声明的局部变量和函数的形参。在函数调用时系统会给他们分配存储空间，在函数调用结束后会自动释放这些空间。属于动态存储方式。 static 变量：用 static 声明的局部变量在调用结束后不会消失而保存原来的值。static 局部变量定义使用后值会存储下来。所以使用 static 局部变量定义只需要一次赋值。静态局部变量的作用域仅限于所定义的函数。但函数结束后变量的值会保留。直到整个程序运行结束。全局变量从定义开始作用于整个文件直至程序运行结束。 register 寄存器变量：寄存器变量可以提高 c 语言的执行效率，即将局部变量的值存入 CPU 的寄存器中。需要注意的是！！！：1.只有动态存储的变量（自动局部变量和形参）才可以作为寄存器变量来存储，局部静态变量不可以定义为寄存器变量。2.计算机的寄存器数目是有限的，所以不能定义任意多个寄存器变量。 extern 外部变量：即全局变量的外部表现形式，是在函数外部定义的变量。全局变量的作用域为从定义开始到源文件结束。exten 对该变量作外部变量声明，扩展变量作用域。 堆与栈的区别 申请方式 stack:栈;由系统自动分配，自动开辟空间 heap:由程序员自己申请并指明大小，c 中 malloc,c++中 new。如 p1=(char)malloc(10);p2=(char)new(10);但需要注意的是 p1,p2 本事是在栈中的 申请后系统的响应 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出 堆：首先操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外对于大部分系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的 delete 语句才能正确的释放本内存空间。另外由于找到的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 申请大小的限制 栈：在 windows 下栈是向低地址扩展的数据结构，是一块连续的内存区域。所以栈的栈顶地址和最大容量是系统预先设定好的。在 windows 下栈的大小是 2M.因此能从栈获得的空间比较小。 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是是由于系统用链表来存储空闲内存地址的，所以是不连续的。而链表的遍历方向是由低地址到高地址。堆得大小受限于计算机系统中有效的虚拟内存大小。相比较而言堆获得的空间比较灵活，也比较大。 申请效率的比较 栈：由系统自动分配，速度较快，但程序员是无法控制的。 堆：由 new 分配的内存，一般速度比较慢，而且比较容易产生内存碎片，不过用起来最方便。 堆和栈中的存储内容 栈：在函数调用时，第一个进栈的是主函数中的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数。在大多数 c 编译器中，参数是由右往左压栈的，然后是函数中的局部变量。静态变量是不入栈的。当函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，，也就是主函数的下一条指令，程序由该点继续执行。 堆：一般是在堆的头部用一个字节存放堆得大小，其他内容自己安排。 存取效率的比较 1 char str1[]=&quot;aaaaaa&quot;; 2 char \\*str2=&quot;cccccc&quot;; 第一行是在运行时刻赋值的，第二行是在编译时就已经确定的，但在以后的存取过程中，在栈上的数组比指针指向的字符串快。 堆内存管理函数C 标准函数库提供了许多函数来实现对堆上内存管理，其中包括：malloc()函数，free()函数，calloc()函数和 realloc()函数。使用这些函数需要包含头文件 stdlib.h。它们的声明如下： void _malloc(size_t n); void free(void _ p); void _calloc(size_t n, size_t size); void _realloc(void \\* p, size_t n); malloc()malloc()函数可以从堆上获得指定字节的内存空间，其函数声明如下： void \\* malloc(size_t n); 其中，形参 n 为要求 分配的字节数。如果函数执行成功，malloc()返回获得内存空间的首地址；如果函数执行失败，那么返回值为 NULL。由于 malloc()函数值的类型为 void 型指针，因此，可以将其值类型转换后赋给任意类型指针，这样就可以通过操作该类型指针来操作从堆上获得的内存空间。 需要注意的是，malloc()函数分配得到的内存空间是未初始化的。因此，一般在使用该内存空间时，要调用另一个函数 memset 来将其初始化为全 0。memset 函数的声明如下： void _ memset (void _ p, int c, size_t n); 该函数可以将指定的内存空间按字节单位置为指定的字符 c。其中，p 为要清零的内存空间的首地址，c 为要设定的值，n 为被操作的内存空间的字节长度。如果要用 memset 清 0，变量 c 实参要为 0。malloc()函数和 memset 函数的操作语句一般如下： int _p = NULL; p = (int _) malloc(sizeof(int)); if (p == NULL){ printf(&quot;Can’t get memory!\\n&quot;); } memset(p, 0, sizeof(int)); 注意：通过 malloc()函数得到的堆内存必须使用 memset()函数来初始化。 示例代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; int main(){ int _p = NULL; p = (int _) malloc(sizeof(int)); if (NULL == p){ printf(&quot;Can&#39;t get memory!\\n&quot;); return -1; } printf(&quot;%d\\n&quot;, *p); // 输出分配的空间上的值 memset(p, 0, sizeof(int)); // 将p指向的空间清0 printf(&quot;%d\\n&quot;, *p); // 输出调用memset函数后的结果 *p = 2; printf(&quot;%d\\n&quot;, *p); return 0; } C 语言- 5 分钟看懂什么是 malloc free()从堆上获得的内存空间在程序结束以后，系统不会将其自动释放，需要程序员来自己管理。一个程序结束时，必须保证所有从堆上获得的内存空间已被安全释放，否则，会导致内存泄露。例如上面的 demo 就会发生内存泄露。 free()函数可以实现释放内存的功能。其函数声明为： void free(void * p); 由于形参为 void 指针，free()函数可以接受任意类型的指针实参。 但是，free()函数只是释放指针指向的内容，而该指针仍然指向原来指向的地方，此时，指针为野指针，如果此时操作该指针会导致不可预期的错误。安全做法 是：在使用 free()函数释放指针指向的空间之后，将指针的值置为 NULL。因此，对于上面的 demo，需要在 return 语句前加入以下两行语句： free(p); p = NULL; 注意：使用 malloc()函数分配的堆空间在程序结束之前必须释放。 calloc()calloc()函数的功能与 malloc()函数的功能相似，都是从堆分配内存。其函数声明如下： void *calloc(size_t n, size_t size); 函数返回值为 void 型指针。如果执行成功，函数从堆上获得 size X n 的字节空间，并返回该空间的首地址。如果执行失败，函数返回 NULL。该函数与 malloc()函数的一个显著不同时是，calloc()函数得到的内存空间是经过初始化的，其内容全为 0。calloc()函数适合为数组申请空间，可以将 size 设置为数组元素的空间长度，将 n 设置为数组的容量。 示例代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define SIZE 5 int main() { int *p = NULL; int i = 0; // 为p从堆上分配SIZE个int型空间 p = (int *) calloc(SIZE, sizeof(int)); if (NULL == p) { printf(&quot;Error in calloc.\\n&quot;); return -1; } // 为p指向的SIZE个int型空间赋值 for (i = 0; i &lt; SIZE; i++) { p[i] = i; } // 输出各个空间的值 for (i = 0; i &lt; SIZE; i++) { printf(&quot;p[%d]=%d\\n&quot;, i, p[i]); } free(p); p = NULL; return 0; } 提示：calloc()函数的分配的内存也需要自行释放。 realloc()realloc()函数的功能比 malloc()函数和 calloc()函数的功能更为丰富，可以实现内存分配和内存释放的功能，其函数声明如下： void * realloc(void * p, size_t n); 其中，指针 p 必须为指向堆内存空间的指针，即由 malloc()函数、calloc()函数或 realloc()函数分配空间的指针。realloc()函数将指针 p 指向的内存块的大小改变为 n 字节。如果 n 小于或等于 p 之前指向的空间大小，那么。保持原有状态不变。如果 n 大于原来 p 之前指向的空间大小，那么，系统将 重新为 p 从堆上分配一块大小为 n 的内存空间，同时，将原来指向空间的内容依次复制到新的内存空间上，p 之前指向的空间被释放。realloc()函数分配的空间也是未初始化的。 注意：使用 malloc()函数，calloc()函数和 realloc()函数分配的内存空间都要使用 free()函数或指针参数为 NULL 的 realloc()函数来释放。 示例代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int *p = NULL; p = (int *) malloc(sizeof(int)); *p = 3; printf(&quot;p=%p\\n&quot;, p); printf(&quot;*p=%d\\n&quot;, *p); p = (int *) realloc(p, sizeof(int)); printf(&quot;p=%p\\n&quot;, p); printf(&quot;*p=%d\\n&quot;, *p); p = (int *) realloc(p, 3 * sizeof(int)); printf(&quot;p=%p\\n&quot;, p); printf(&quot;*p=%d&quot;, *p); // 释放p指向的空间 realloc(p, 0); p = NULL; return 0; } 下面要注意的几点是： 函数 malloc()和 calloc()都可以用来动态分配内存空间。 malloc()函数有一个参数，即分配的内存空间的大小，malloc()在分配内存的时候会保留一定的空间用来记录分配情况，分配的次数越多，这些记录占用的空间就越多。 另外，根据 malloc()实现策略的不同，malloc()每次在分配的时候，可能分配的空间比实际要求的多些，多次分配会导致更多的这种浪费，当然，这些都跟 malloc()的实现有关； calloc()函数有两个参数，分别为元素的个数和每个元素的大小，这两个参数的乘积就是要分配的内存空间的大小。如果调用成功，它们都将返回所分配内存空间的首地址。 函数 malloc()和 calloc()的主要区别是前者不能初始化所分配的内存空间，而后者可以。 realloc()可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或者缩小，原有内存中的内容将保持不变。当然，对于缩小，则被缩小的那一部分的内容会丢失。 realloc()并不保证调整后的内存空间和原来的内存空间保持同一内存地址，相反，realloc()返回的指针很可能指向一个新地址。所以在代码 中，我们必须将 realloc()的返回值，重新赋值给 p ： p = (int _) realloc (p, sizeof(int) _ 15); realloc()函数，另外一个注意点： realloc()有可能操作失败，返回 NULL，所以不要把它的返回值直接赋值给原来的指针变量，以免原值丢失： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { char *str = NULL; str = (char *)malloc(sizeof(char)); *str = &#39;a&#39;; char *p = (char *)realloc(str, sizeof(char) * 10); if (p != NULL) { str = p; } printf(&quot;%s\\n&quot;, str); return 0; } 安全起见，小心使用 C 语言 realloc()函数 malloc\\calloc\\realloc 区别三个函数的申明分别是: void* realloc(void* ptr, unsigned newsize); void* malloc(unsigned size); void* calloc(size_t numElements, size_t sizeOfElement); 都在 stdlib.h 函数库内它们的返回值都是请求系统分配的地址,如果请求失败就返回 NULL malloc 用于申请一段新的地址,参数 size 为需要内存空间的长度,如: char* p; p=(char*)malloc(20); calloc 与 malloc 相似,参数 sizeOfElement 为申请地址的单位元素长度,numElements 为元素个数,如: char* p; p=(char*)calloc(20,sizeof(char)); 这个例子与上一个效果相同 realloc 是给一个已经分配了地址的指针重新分配空间,参数 ptr 为原有的空间地址,newsize 是重新申请的地址长度如: char* p; p=(char*)malloc(sizeof(char)_20); p=(char_)realloc(p,sizeof(char)\\*40); 注意，这里的空间长度都是以字节为单位。 C 语言的标准内存分配函数：malloc，calloc，realloc，free 等。 malloc 与 calloc 的区别为 1 块与 n 块的区别： malloc 调用形式为(类型*)malloc(size)：在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址。 calloc 调用形式为(类型*)calloc(n，size)：在内存的动态存储区中分配 n 块长度为“size”字节的连续区域，返回首地址。 realloc 调用形式为(类型)realloc(ptr，size)：将 ptr 内存大小增大到 size。","tags":[{"name":"C","slug":"C","permalink":"https://www.flaglee.cn/tags/C/"},{"name":"内存分区","slug":"内存分区","permalink":"https://www.flaglee.cn/tags/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"},{"name":"内存管理","slug":"内存管理","permalink":"https://www.flaglee.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"Python多任务编程：进程和线程","date":"2020-09-04T15:04:37.000Z","path":"2020/09/04/Python多任务编程：进程和线程/","text":"一般写的程序都是单任务的，也就是说一个函数或者方法执行完成之后另外一个函数或者方法才能执行，要想实现多个任务同时执行的操作就需要使用多任务。多任务的最大好处是充分利用 CPU 资源，提高程序的执行效率。 多任务的概念多任务是指在同一时间内执行多个任务。多任务能充分利用 CPU 资源，提高程序的执行效率，让程序具备处理多个任务的能力。 多任务的执行方式： 并发 并行 并发 任务数 &gt; CPU核心数，在一段时间内交替去执行任务。对于单核cpu处理多任务,操作系统轮流让各个软件交替执行。 假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。 表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。并行 任务数 &lt; CPU核心数，对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。 这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。并行才是多个任务真正意义一起执行。进程进程的概念一个正在运行的程序或者软件就是一个进程，它是操作系统进行资源分配的基本单位，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。 比如:现实生活中的公司可以理解成是一个进程，公司提供办公资源(电脑、办公桌椅等)，真正干活的是员工，员工可以理解成线程。 一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。 多进程的使用1.导入进程包 #导入进程包 import multiprocessing 2.Process 进程类的说明Process([group [, target [, name [, args [, kwargs]]]]]) group：指定进程组，目前只能使用 None target：执行的目标任务名 name：进程名字 args：以元组方式给执行任务传参 kwargs：以字典方式给执行任务传参 Process 创建的实例对象的常用方法: start()：启动子进程实例（创建子进程） join()：等待子进程执行结束 terminate()：不管任务是否完成，立即终止子进程 Process 创建的实例对象的步骤: 导入进程包 import multiprocessing 创建子进程并指定执行的任务 sub_process = multiprocessing.Process (target=任务名) 启动进程执行任务 sub_process.start() 多进程完成多任务的代码 import multiprocessing import time # 跳舞任务 def dance(): for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 唱歌任务 def sing(): for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果: 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 获取进程编号1.获取进程编号的目的 获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。 获取进程编号的两种操作 获取当前进程编号 获取当前父进程编号 获取当前进程编号方法 os.getpid() 获取当前父进程编号 os.getppid() 获取进程编号可以查看父子进程的关系 2.获取当前进程编号 os.getpid() 表示获取当前进程编号 示例代码: import multiprocessing import time import os # 跳舞任务 def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9) # 唱歌任务 def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果: main: 70763 main: &lt;_MainProcess(MainProcess, started)&gt; dance: 70768 dance: &lt;Process(myprocess1, started)&gt; 跳舞中... sing: 70769 sing: &lt;Process(Process-2, started)&gt; 唱歌中... 唱歌中... 唱歌中... 唱歌中... 唱歌中... **3.获取当前父进程编号 os.getppid() 表示获取当前父进程编号 示例代码: import multiprocessing import time import os # 跳舞任务 def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;dance的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9) # 唱歌任务 def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;sing的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果： main: 70860 main: &lt;_MainProcess(MainProcess, started)&gt; dance: 70861 dance: &lt;Process(myprocess1, started)&gt; dance的父进程编号: 70860 跳舞中... sing: 70862 sing: &lt;Process(Process-2, started)&gt; sing的父进程编号: 70860 唱歌中... 唱歌中... 唱歌中... 唱歌中... 唱歌中... 进程执行带有参数的任务1. 进程执行带有参数的任务的介绍 前面使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢? Process 类执行任务并给任务传参数有两种方式: 元组方式传参(args): 元组方式传参一定要和参数的顺序保持一致。 字典方式传参(kwargs): 字典方式传参字典中的 key 一定要和参数名保持一致。 2. args 参数的使用 示例代码: import multiprocessing import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子进程 # args: 以元组的方式给任务传入参数 sub_process = multiprocessing.Process(target=task, args=(5,)) sub_process.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 3. kwargs 参数的使用 示例代码: import multiprocessing import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子进程 # kwargs: 表示以字典方式传入参数 sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3}) sub_process.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 进程之间不共享全局变量创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。 示例代码： import multiprocessing import time # 定义全局变量 g_list = list() # 添加数据的任务 def add_data(): for i in range(5): g_list.append(i) print(&quot;add:&quot;, i) time.sleep(0.2) # 代码执行到此，说明数据添加完成 print(&quot;add_data:&quot;, g_list) def read_data(): print(&quot;read_data&quot;, g_list) if __name__ == &#39;__main__&#39;: # 创建添加数据的子进程 add_data_process = multiprocessing.Process(target=add_data) # 创建读取数据的子进程 read_data_process = multiprocessing.Process(target=read_data) # 启动子进程执行对应的任务 add_data_process.start() # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据 add_data_process.join() read_data_process.start() print(&quot;main:&quot;, g_list) # 总结: 多进程之间不共享全局变量 执行结果: add: 0 add: 1 add: 2 add: 3 add: 4 add_data: [0, 1, 2, 3, 4] main: [] read_data [] 进程之间不共享全局变量的解释效果图: 主进程会等待所有的子进程执行结束再结束为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是主进程退出子进程销毁，不让主进程再等待子进程去执行。 设置守护主进程方式： 子进程对象.daemon = True 销毁子进程方式： 子进程对象.terminate() 假如我们现在创建一个子进程，这个子进程执行完大概需要 2 秒钟，现在让主进程执行 0.5 秒钟就退出程序，查看一下执行结果，示例代码如下: import multiprocessing import time # 定义进程所需要执行的任务 def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建子进程 sub_process = multiprocessing.Process(target=task) sub_process.start() # 主进程延时0.5秒钟 time.sleep(0.5) print(&quot;over&quot;) exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 执行结果: 任务执行中... 任务执行中... 任务执行中... over 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 说明: 通过上面代码的执行结果，我们可以得知: 主进程会等待所有的子进程执行结束再结束 假如我们就让主进程执行 0.5 秒钟，子进程就销毁不再执行，那怎么办呢? 我们可以设置守护主进程 或者 在主进程退出之前 让子进程销毁 守护主进程: 守护主进程就是主进程退出子进程销毁不再执行 子进程销毁: 子进程执行结束 保证主进程正常退出的示例代码: import multiprocessing import time # 定义进程所需要执行的任务 def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建子进程 sub_process = multiprocessing.Process(target=task) # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程 # sub_process.daemon = True sub_process.start() time.sleep(0.5) print(&quot;over&quot;) # 让子进程销毁 sub_process.terminate() exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁 执行结果: 任务执行中... 任务执行中... 任务执行中... over 线程线程的概念在 Python 中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。 线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要 cpu 进行调度 ，也就是说线程是 cpu 调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。 多线程的使用1. 导入线程模块 #导入线程模块 import threading 2. 线程类 Thread 参数说明 Thread([group [, target [, name [, args [, kwargs]]]]]) group: 线程组，目前只能使用 None target: 执行的目标任务名 args: 以元组的方式给执行任务传参 kwargs: 以字典方式给执行任务传参 name: 线程名，一般不用设置 3. 启动线程 导入线程模块 import threading 创建子线程并指定执行的任务 sub_thread = threading.Thread(target=任务名) 启动线程执行任务 sub_thread.start() 示例代码： import threading import time # 唱歌任务 def sing(): # 扩展： 获取当前线程 # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在唱歌...%d&quot; % i) time.sleep(1) # 跳舞任务 def dance(): # 扩展： 获取当前线程 # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在跳舞...%d&quot; % i) time.sleep(1) if __name__ == &#39;__main__&#39;: # 扩展： 获取当前线程 # print(&quot;当前执行的线程为：&quot;, threading.current_thread()) # 创建唱歌的线程 # target： 线程执行的函数名 sing_thread = threading.Thread(target=sing) # 创建跳舞的线程 dance_thread = threading.Thread(target=dance) # 开启线程 sing_thread.start() dance_thread.start() 执行结果： 正在唱歌...0 正在跳舞...0 正在唱歌...1 正在跳舞...1 正在唱歌...2 正在跳舞...2 线程执行带有参数的任务1. 线程执行带有参数的任务的介绍 前面使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢? Thread 类执行任务并给任务传参数有两种方式: 元组方式传参(args) ：元组方式传参一定要和参数的顺序保持一致。 字典方式传参(kwargs)：字典方式传参字典中的 key 一定要和参数名保持一致。 2. args 参数的使用 示例代码: import threading import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子线程 # args: 以元组的方式给任务传入参数 sub_thread = threading.Thread(target=task, args=(5,)) sub_thread.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 3. kwargs 参数的使用 示例代码: import threading import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子线程 # kwargs: 表示以字典方式传入参数 sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3}) sub_thread.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 线程之间执行是无序的线程之间执行是无序的，它是由 cpu 调度决定的 ，cpu 调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。 进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。 示例代码： import threading import time def task(): time.sleep(1) print(&quot;当前线程:&quot;, threading.current_thread().name) if __name__ == &#39;__main__&#39;: for _ in range(5): sub_thread = threading.Thread(target=task) sub_thread.start() 运行结果： 当前线程: Thread-1 当前线程: Thread-2 当前线程: Thread-4 当前线程: Thread-5 当前线程: Thread-3 主线程会等待所有的子线程执行结束再结束主线程默认会等待所有子线程执行结束再结束，设置守护主线程的目的是主线程退出子线程销毁。 假如我们现在创建一个子线程，这个子线程执行完大概需要 2.5 秒钟，现在让主线程执行 1 秒钟就退出程序，查看一下执行结果，示例代码如下: import threading import time # 测试主线程是否会等待子线程执行完成以后程序再退出 def show_info(): for i in range(5): print(&quot;test:&quot;, i) time.sleep(0.5) if __name__ == &#39;__main__&#39;: sub_thread = threading.Thread(target=show_info) sub_thread.start() # 主线程延时1秒 time.sleep(1) print(&quot;over&quot;) 执行结果： test: 0 test: 1 over test: 2 test: 3 test: 4 说明: 通过上面代码的执行结果，我们可以得知: 主线程会等待所有的子线程执行结束再结束 假如我们就让主线程执行 1 秒钟，子线程就销毁不再执行，那怎么办呢? 我们可以设置守护主线程 守护主线程: 守护主线程就是主线程退出子线程销毁不再执行 设置守护主线程有两种方式： threading.Thread(target=show_info, daemon=True) 线程对象.setDaemon(True) 设置守护主线程的示例代码: import threading import time # 测试主线程是否会等待子线程执行完成以后程序再退出 def show_info(): for i in range(5): print(&quot;test:&quot;, i) time.sleep(0.5) if __name__ == &#39;__main__&#39;: # 创建子线程守护主线程 # daemon=True 守护主线程 # 守护主线程方式1 sub_thread = threading.Thread(target=show_info, daemon=True) # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码 # 守护主线程方式2 # sub_thread.setDaemon(True) sub_thread.start() # 主线程延时1秒 time.sleep(1) print(&quot;over&quot;) 执行结果: test: 0 test: 1 over 线程之间共享全局变量线程之间共享全局变量，好处是可以对全局变量的数据进行共享。 需求: 定义一个列表类型的全局变量 创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务 查看线程之间是否共享全局变量数据 import threading import time # 定义全局变量 my_list = list() # 写入数据任务 def write_data(): for i in range(5): my_list.append(i) time.sleep(0.1) print(&quot;write_data:&quot;, my_list) # 读取数据任务 def read_data(): print(&quot;read_data:&quot;, my_list) if __name__ == &#39;__main__&#39;: # 创建写入数据的线程 write_thread = threading.Thread(target=write_data) # 创建读取数据的线程 read_thread = threading.Thread(target=read_data) write_thread.start() # 延时 # time.sleep(1) # 主线程等待写入线程执行完成以后代码在继续往下执行 write_thread.join() print(&quot;开始读取数据啦&quot;) read_thread.start() 执行结果: write_data: [0, 1, 2, 3, 4] 开始读取数据啦 read_data: [0, 1, 2, 3, 4] 线程之间共享全局变量数据出现错误问题线程之间共享全局变量可能会导致数据出现错误问题，可以使用线程同步方式来解决这个问题。 需求: 定义两个函数，实现循环 100 万次，每循环一次给全局变量加 1 创建两个子线程执行对应的两个函数，查看计算后的结果 import threading # 定义全局变量 g_num = 0 # 循环一次给全局变量加1 def sum_num1(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 循环一次给全局变量加1 def sum_num2(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() # 启动线程 second_thread.start() 执行结果: sum1: 1210949 sum2: 1496035 注意点: 多线程同时对全局变量操作数据发生了错误 错误分析: 两个线程 first_thread 和 second_thread 都要对全局变量 g_num(默认是 0)进行加 1 运算，但是由于是多线程同时操作，有可能出现下面情况： 在 g_num=0 时，first_thread 取得 g_num=0。此时系统把 first_thread 调度为”sleeping”状态，把 second_thread 转换为”running”状态，t2 也获得 g_num=0 然后 second_thread 对得到的值进行加 1 并赋给 g_num，使得 g_num=1 然后系统又把 second_thread 调度为”sleeping”，把 first_thread 转为”running”。线程 t1 又把它之前得到的 0 加 1 后赋值给 g_num。 这样导致虽然 first_thread 和 first_thread 都对 g_num 加 1，但结果仍然是 g_num=1 全局变量数据错误的解决办法: 线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机 线程同步的方式: 线程等待(join) 互斥锁 线程等待的示例代码: import threading # 定义全局变量 g_num = 0 # 循环1000000次每次给全局变量加1 def sum_num1(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 循环1000000次每次给全局变量加1 def sum_num2(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程 # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行 first_thread.join() # 启动线程 second_thread.start() 执行结果: sum1: 1000000 sum2: 2000000 互斥锁与死锁互斥锁的概念互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。 互斥锁的作用就是保证同一时刻只能有一个线程去操作共享数据，保证共享数据不会出现错误问题 使用互斥锁的好处确保某段关键代码只能由一个线程从头到尾完整地去执行 使用互斥锁会影响代码的执行效率，多任务改成了单任务执行 互斥锁如果没有使用好容易出现死锁的情况 注意: 互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。 互斥锁的使用threading 模块中定义了 Lock 变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。 互斥锁使用步骤: # 创建锁 mutex = threading.Lock() # 上锁 mutex.acquire() ...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定... # 释放锁 mutex.release() 注意点: acquire 和 release 方法之间的代码同一时刻只能有一个线程去操作 如果在调用 acquire 方法的时候 其他线程已经使用了这个互斥锁，那么此时 acquire 方法会堵塞，直到这个互斥锁释放后才能再次上锁。 互斥锁示例使用互斥锁完成 2 个线程对同一个全局变量各加 100 万次的操作 import threading # 定义全局变量 g_num = 0 # 创建全局互斥锁 lock = threading.Lock() # 循环一次给全局变量加1 def sum_num1(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 释放锁 lock.release() # 循环一次给全局变量加1 def sum_num2(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() second_thread.start() # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待 # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行 执行结果: sum1: 1000000 sum2: 2000000 说明: 通过执行结果可以地址互斥锁能够保证多个线程访问共享数据不会出现数据错误问题 死锁的概念死锁: 一直等待对方释放锁的情景就是死锁 使用互斥锁的时候需要注意死锁的问题，要在合适的地方注意释放锁。 死锁一旦产生就会造成应用程序的停止响应，应用程序无法再继续往下执行了。 死锁的结果 会造成应用程序的停止响应，不能再处理其它任务了。 死锁示例 需求: 根据下标在列表中取值, 保证同一时刻只能有一个线程去取值 import threading import time # 创建互斥锁 lock = threading.Lock() # 根据下标去取值， 保证同一时刻只能有一个线程去取值 def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] # 判断下标释放越界 if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 避免死锁 在合适的地方释放锁 import threading import time # 创建互斥锁 lock = threading.Lock() # 根据下标去取值， 保证同一时刻只能有一个线程去取值 def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) # 当下标越界需要释放锁，让后面的线程还可以取值 lock.release() return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 进程和线程的对比关系对比 线程是依附在进程里面的，没有进程就没有线程。 一个进程默认提供一条线程，进程可以创建多个线程。 区别对比 进程之间不共享全局变量 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步 创建进程的资源开销要比创建线程的资源开销要大 进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位 线程不能够独立执行，必须依存在进程中 多进程开发比单进程多线程开发稳定性要强 优缺点对比 进程优缺点: 优点：可以用多核 缺点：资源开销大 线程优缺点: 优点：资源开销小 缺点：不能使用多核 小结 进程和线程都是完成多任务的一种方式 多进程要比多线程消耗的资源多，但是多进程开发比单进程多线程开发稳定性要强，某个进程挂掉不会影响其它进程。 多进程可以使用 cpu 的多核运行，多线程可以共享全局变量。 线程不能单独执行必须依附在进程里面 计算密集型的应用使用多进程，有效利用多核提升运算效率；其他应用（文件写入、文件下载、IO 操作）使用多线程，更加节省资源并且可以完成多任务。","tags":[{"name":"Python","slug":"Python","permalink":"https://www.flaglee.cn/tags/Python/"},{"name":"多任务","slug":"多任务","permalink":"https://www.flaglee.cn/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/"},{"name":"进程","slug":"进程","permalink":"https://www.flaglee.cn/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://www.flaglee.cn/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"接收机星历融合算法","date":"2020-09-01T10:00:00.000Z","path":"2020/09/01/接收机星历融合算法/","text":"近期在各种项目中，总是不可避免地遇到星历异常问题，而广播星历的误差会对 GPS 定位精度会产生严重影响。因此，设计一种监测数据实时解算星历异常处理方法极为重要。 这篇文章记录一下做的第一个工作，将各个参考站接收机的星历融合为一个文件。 星历异常问题目前项目中广播星历实时获取主要有两种方式： 接收网上各个分析中心的实时广播星历数据（包括 products.igs-ip.net、rt.igs.org 等） 使用 GNSS 变形监测的接收机本身接收到的星历 但是两种方式都存在不稳定因素： 第一种广播星历实时融合流会不可避免地遇到网络延迟、播发延迟甚至网络传输故障问题 第二种广播星历实时接收流因为依赖于接收机，所以可能会遇到设备没电、设备网络信号不好甚至设备遭到人为破坏等问题 每一种问题对于实时变形监测工程来说都是致命的，因此要设计一种方式得到最优的星历。 主要方案 将实时从各个网站上接收的星历融合为一个文件，同时收集各个接收机的星历融合为一个文件，在分别筛选两个星历文件有无异常，得出最优星历。这篇文章先谈一下第一部分融合星历。 关键代码int main(int argc, char *argv[]) { double nmeapos[3]; int i, strs[MAXSTRINPPP] = { 0 }; char* paths[MAXSTRINPPP], * cmds[MAXSTRINPPP] = { 0 }, * cmds_periodic[MAXSTRINPPP] = { 0 }, * rcvopts[MAXSTRINPPP] = { 0 }, info[MAXSTRINPPP][100]; int formats[MAXSTRINPPP] = { 0 }; prcopt_t prcopt = prcopt_default; solopt_t solopt = solopt_default; int cycle = 10; int buffsize = 32768; int navsel = 3; int nmeacycle = 1000; int nmeareq = 2; char errmsg[100] = { 0 }; char cmdm8t[1024] = &quot;&quot;; eph_t eph0 = { 0,-1,-1 }; geph_t geph0 = { 0,-1 }; seph_t seph0 = { 0 }; ephh_t nhead0 = { 0 }; char* p, buff[200], currDir[MAX_PATH], streamFile[MAX_PATH], fileFile[MAX_PATH]; int n = 0; initlock(&amp;global_lock); GetCurrentDirectoryA(MAX_PATH, currDir); printf(&quot;\\nStart receiving broadcast ephemeris...\\n&quot;); for (i = 1; i &lt; argc; i++) { if (!strcmp(argv[i], &quot;-p&quot;) &amp;&amp; i + 1 &lt; argc) { printf(&quot;Self-defined prefix is %s\\n\\n&quot;, argv[i+1]); strcpy(ephprefix, argv[++i]); prefixflag = 1; break; } } if (!prefixflag) { printf(&quot;Default prefix is brdc\\n\\n&quot;); } /* load stream options from configuration file */ for (i = 1; i &lt; argc; i++) { if (!strcmp(argv[i], &quot;-s&quot;)) { typeflag = 2; printf(&quot;Read nav from stream\\n\\n&quot;); sprintf(streamFile, &quot;%s\\\\%s&quot;, currDir, &quot;stream.txt&quot;); if (!loadoptxt(typeflag, streamFile, info, strs, &amp;corNum)) { printf(&quot;no input path\\n&quot;); return -1; } } else if (!strcmp(argv[i], &quot;-f&quot;)) { typeflag = 1; printf(&quot;Read nav from file\\n\\n&quot;); sprintf(fileFile, &quot;%s\\\\%s&quot;, currDir, &quot;file.txt&quot;); if (!loadoptxt(typeflag, fileFile, info, strs, &amp;corNum)) { printf(&quot;no input path\\n&quot;); return -1; } } else if (!strcmp(argv[i], &quot;-o&quot;) &amp;&amp; i + 1 &lt; argc) { strcpy(brdmdir, argv[++i]); printf(&quot;output path is %s\\n&quot;, brdmdir); verbrdc = 2.0; } else if (!strcmp(argv[i], &quot;-p&quot;) &amp;&amp; i + 1 &lt; argc) { ++i; continue; } else if (n &lt; MAXSTRINPPP) { strcpy(info[n], argv[i]); printf(&quot;file path %d is %s\\n&quot;, n+1, info[n]); strs[n++] = 2; } } if (!typeflag) { corNum = n; } for (i = 0; i&lt; MAXSTRINPPP; i++) { paths[i] = (char *)malloc(256 * sizeof(char)); paths[i][0] = &#39;\\0&#39;; } for (i = 0; i &lt; corNum; i++) { strcpy(paths[i], info[i]); formats[i] = STRFMT_RTCM3; cmds[i] = (char *)malloc(256 * sizeof(char)); rcvopts[i] = (char *)malloc(256 * sizeof(char)); cmds[i][0] = rcvopts[i][0] = &#39;\\0&#39;; } pppsvr = (pppsvr_t*)malloc(sizeof(pppsvr_t) * (corNum)); for (i = 0; i &lt; corNum; i++) { rtksvrinit(pppsvr + i); } if (!(navppp.eph = (eph_t*)malloc(sizeof(eph_t) * (MAXSAT) * 2)) || !(navppp.geph = (geph_t*)malloc(sizeof(geph_t) * NSATGLO * 2)) || !(navppp.seph = (seph_t*)malloc(sizeof(seph_t) * NSATSBS * 2))) { return 0; } for (i = 0; i &lt; (MAXSAT) * 2; i++) navppp.eph[i] = eph0; for (i = 0; i &lt; NSATGLO * 2; i++) navppp.geph[i] = geph0; for (i = 0; i &lt; NSATSBS * 2; i++) navppp.seph[i] = seph0; navppp.n = (MAXSAT) * 2; navppp.ng = NSATGLO * 2; navppp.ns = NSATSBS * 2; navppp.nhead = nhead0; //printf(&quot;%d file\\n&quot;, corNum); printf(&quot;\\nStart fusion...\\n&quot;); rtksvrstart(pppsvr, cycle, buffsize, strs, paths, formats, navsel, cmds, cmds_periodic, rcvopts, nmeacycle, nmeareq, nmeapos,&amp;prcopt, &amp;solopt, &amp;monistr, errmsg); //system(&quot;pause&quot;); for (i = 0; i &lt; MAXSTRINPPP; i++) { free(paths[i]); } for (i = 0; i &lt; MAXSTRINPPP; i++) { free(rcvopts[i]); free(cmds[i]); } //printf(&quot;pthread join\\n&quot;); for (int i = 0; i &lt; corNum; i++) { if (pppsvr[i].thread &gt; 0) { printf(&quot;thread is %d\\n&quot;, pppsvr[i].thread); WaitForSingleObject(pppsvr[i].thread, INFINITE); } } printf(&quot;Fusion finish.\\n&quot;); return 0; } 各个函数详细内容欢迎查看FLAG’s GitHub。 程序示例 融合后的文件中包含了所有接收机的星历，且不含重复星历。 软件下载软件开源提供给大家使用，目前有 Windows 版本和 Linux 版本，软件地址为FLAG’s GitHub。 # MergeNav V2.0 ## -s stream type read stream_path\\out_path\\out_file_prefix from stream.txt e.g. ./MergeNav -s ## -f file type read stream_path\\out_path\\out_file_prefix from file.txt e.g. ./MergeNav -f ## -p self-define output file prefix e.g. ./MergeNav -p WHUSGG out: WHUSGG.20p default: brdcDOY0.20p ## -o output path e.g. ./MergeNav -o ./Result/ ## other input file path # e.g. ## read from cmd ./MergeNav -p LQZcmdflie -o ./Result/ ./RTCM3/HH0012.2020330binRTCM3 ./RTCM3/HH0013.2020330binRTCM3 ./RTCM3/HH0014.2020330binRTCM3 ./MergeNav -p LQZcmdflie -o ./Result/ ./RTCM3/HH0012.2020330binRTCM3 ./RTCM3/HH0013.2020330binRTCM3 ./RTCM3/HH0014.2020330binRTCM3 ./RTCM3/HH0015.2020330binRTCM3 ./RTCM3/HH0016.2020330binRTCM3 ./RTCM3/HH0017.2020330binRTCM3 ./RTCM3/HH0018.2020330binRTCM3 ./RTCM3/HH0019.2020330binRTCM3 ./RTCM3/HH0020.2020330binRTCM3 ./RTCM3/HH0021.2020330binRTCM3 ## read from stream file ./MergeNav -s ./MergeNav -s -p LQZstreamfile ./MergeNav -s -p LQZstreamfile -o -o ./Result/ ## read from file file ./MergeNav -f ./MergeNav -s -p LQZfilefile ./MergeNav -s -p LQZfilefile -o -o ./Result/ # ver log ## 1.0 ## 1.1 - add file auto stop - add linux version ## 1.2 - fix one file bug ## 2.0 - fix thread bug, now can calculate 1 to 10 files, More files have not been tested. &quot;# MergeNav&quot;","tags":[{"name":"GNSS","slug":"GNSS","permalink":"https://www.flaglee.cn/tags/GNSS/"},{"name":"RTKlib","slug":"RTKlib","permalink":"https://www.flaglee.cn/tags/RTKlib/"},{"name":"RTK","slug":"RTK","permalink":"https://www.flaglee.cn/tags/RTK/"}]},{"title":"使用QT编译RTKLIB的GUI程序","date":"2020-08-10T09:26:54.000Z","path":"2020/08/10/使用QT编译RTKLIB-GUI程序/","text":"近期在基于 RTKLIB 改了一些代码，但一直是基于源码运行的，于是便想着编译一个自己的图形用户界面。查阅 manual 2.4.2 手册上使用的是 Embarcadero C++ Builder XE2 or XE3，上网查了一下实在是太古老，无奈放弃。之后使用 QT 编译成功，写下这篇博客记录一下方法和注意事项。 所用版本这篇博客基于的是 demo5 源码版本，链接见http://rtkexplorer.com/downloads/rtklib-code/。QT 使用的是 5.14.2，国内镜像链接见https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.14/5.14.2/。本文只针对以上版本记录编译过程中遇到的问题。其实版本之间大同小异，博主之前也用别的版本编译成功过，希望大家举一反三。 编译流程首先使用 QT creator 打开源码根目录下的.pro 文件，创建工程。 这里使用的是 MinGW 32 位，注意区分。 以 rtkpost 软件为例，选择 Release 构建下的 rtkpost_qt。 按绿色三角或 Ctrl+R 开始运行。 问题 1第一个问题发现提示 :-1: error: No rule to make target ‘rcv/ss2.c’, needed by ‘release/ss2.o’. Stop. 这个问题是由于之前的代码中有这个文件，而最新的版本已经去掉，我们可以在 src.pro 中找到这一条将其注释掉。 重新运行程序。 问题 2发现提示 :-1: error: No rule to make target ‘../../src/debug/libRTKLib.a’, needed by ‘release/rtknavi_qt.exe’. Stop. 这是因为缺少库文件 libRTKLib.a，这个文件就是我们源代码生成的库文件，当你改了源码之后，这个也会随之改变，所以千万不要乱用。这个文件可以在 Debug 模式下生成，我们切到 Debug 模式下重新运行。 问题 3发现一连串报错 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\RTKLIB-demo5..\\RTKLIB-demo5\\app\\rtkconv_qt\\codeopt.cpp:333: error: ‘FREQTYPE_L7’ was not declared in this scope E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); 这是由于 demo5 版本在头文件改了一些配置，源码编译文件改了，但是 qt 编译文件还没有改，我们可以找到 app&gt;rtkconv&gt;codeopt.cpp 查看它是怎么使用的，我们 rtkconv_qt&gt;codeopt.cpp 只要随之改变就好 E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); 改为 E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); 改为 J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); 改为 C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); 改为 I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); 同样 convopt.cpp 下也有这个问题，也采用上面的方法改完，重新运行。编译成功，我们已经可以看到 Debug 模式下的程序界面。 之后我们在 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Debug\\src\\debug 路径下找到我们编译的 libRTKLib.a 将其复制到 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Release\\src\\debug 且回到 Release 模式，重新运行，即可成功。 程序打包这样直接生成的程序是不能直接运行的，需要进行打包。打开 Qt 版本号 for Desktop (MinGW 版本号 32bit)命令行，注意与一开始选择的对应。 接着输入命令行，cd /d 路径(指的是需要打包的 exe 程序目录，就是刚才拷贝出来的 exe 程序所在的目录)，回车后， 输入如下命令行：windeployqt 程序名 敲击回车。这一步操作是将所需的库文件全都拷贝到 exe 程序的当前文件。 现在，便可以双击 exe 直接运行软件了！ 若你要将程序给别人使用，一定要注意 dll 文件也要一起打包哦。","tags":[{"name":"QT","slug":"QT","permalink":"https://www.flaglee.cn/tags/QT/"},{"name":"GNSS","slug":"GNSS","permalink":"https://www.flaglee.cn/tags/GNSS/"},{"name":"RTKlib","slug":"RTKlib","permalink":"https://www.flaglee.cn/tags/RTKlib/"},{"name":"RTK","slug":"RTK","permalink":"https://www.flaglee.cn/tags/RTK/"}]},{"title":"RTKlib源码解析-高精度GNSS定位处理过程","date":"2020-07-15T14:17:30.000Z","path":"2020/07/15/RTKlib-关于高精度GPS动态定位处理过程/","text":"RTKLIB 是用于 GNSS（全球导航卫星系统）的标准和精确定位的开源程序包。二进制文件以及完整原始代码见RTKlib.com。Demo5 是 RTKLIB 代码的修改版本，针对低成本的单频和双频接收器而定制，旨在提高性能。二进制文件以及完整原始代码见http://rtkexplorer.com/downloads/rtklib-code/。 本文主要介绍用 RTKLIB 实现精密动态定位的过程，该过程包括观测文件和导航文件的读取、基准站位置的计算、流动站位置的求解、运行结果的输出。 主函数配置解算流程文件读取求解基站参数相对动态定位","tags":[{"name":"GNSS","slug":"GNSS","permalink":"https://www.flaglee.cn/tags/GNSS/"},{"name":"RTKlib","slug":"RTKlib","permalink":"https://www.flaglee.cn/tags/RTKlib/"},{"name":"RTK","slug":"RTK","permalink":"https://www.flaglee.cn/tags/RTK/"},{"name":"GPS","slug":"GPS","permalink":"https://www.flaglee.cn/tags/GPS/"},{"name":"BDS","slug":"BDS","permalink":"https://www.flaglee.cn/tags/BDS/"}]},{"title":"Markdown语法汇总","date":"2020-05-26T02:58:53.000Z","path":"2020/05/26/Markdown语法汇总/","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息，例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等。 Markdown 标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加#+space号即可。使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 Markdown 段落段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 字体Markdown 可以使用以下几种字体： _斜体文本_ _斜体文本_ **粗体文本** **粗体文本** **_粗斜体文本_** **_粗斜体文本_** 斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： --- --- --- --- --- 删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： GOOGLE.COM ~~BAIDU.COM~~ GOOGLE.COMBAIDU.COM 下划线下划线可以通过 HTML 标签来实现： &lt;u&gt;带下划线文本&lt;/u&gt; 带下划线文本 Markdown 列表Markdown 支持有序列表和无序列表。 无序列表无序列表使用星号*、加号+或是减号-作为列表标记，这些标记后面要添加一个space，然后再填写内容： - 第一项 - 第二项 - 第三项 * 第一项 * 第二项 * 第三项 - 第一项 - 第二项 - 第三项 第一项 第二项 第三项 有序列表有序列表使用数字并加上space. 号来表示，如： 1. 第一项 2. 第二项 3. 第三项 第一项 第二项 第三项 Markdown 区块Markdown 区块引用是在段落开头使用 >符号 ，然后后面紧跟一个space符号： &gt; 区块引用 区块引用 Markdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来`，例如： `printf()` 函数 printf() 函数代码区块使用 4 个空格或者一个制表符Tab。也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定） Markdown 链接链接使用方法如下： [链接名称](链接地址) 或者 &lt;链接地址&gt; [FLAG&#39;s blog](www.flaglee.cn) FLAG’s blog 高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行： 这个链接用 1 作为网址变量 [Google][1] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ Markdown 图片Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) ![Markdown](https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png &quot;markdown图标&quot;) Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ------ | ------ | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 对齐方式 可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 | 左对齐 | 右对齐 | 居中对齐 | | :----- | -----: | :------: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 Markdown 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等，如： 使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 使用 Ctrl+Alt+Del 重启电脑 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： **文本加粗** \\*\\* 正常显示星号 \\*\\* 文本加粗** 正常显示星号 ** 公式当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。","tags":[{"name":"blog","slug":"blog","permalink":"https://www.flaglee.cn/tags/blog/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.flaglee.cn/tags/Markdown/"}]},{"title":"Hello World","date":"2020-05-26T02:53:03.254Z","path":"2020/05/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[{"name":"blog","slug":"blog","permalink":"https://www.flaglee.cn/tags/blog/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.flaglee.cn/tags/Hexo/"}]}]