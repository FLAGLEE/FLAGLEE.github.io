[{"title":"Python多任务编程：进程和线程","date":"2020-09-04T15:04:37.000Z","path":"2020/09/04/Python多任务编程：进程和线程/","text":"一般写的程序都是单任务的，也就是说一个函数或者方法执行完成之后另外一个函数或者方法才能执行，要想实现多个任务同时执行的操作就需要使用多任务。多任务的最大好处是充分利用 CPU 资源，提高程序的执行效率。 多任务的概念多任务是指在同一时间内执行多个任务。多任务能充分利用 CPU 资源，提高程序的执行效率，让程序具备处理多个任务的能力。 多任务的执行方式： 并发 并行 并发 任务数 &gt; CPU核心数，在一段时间内交替去执行任务。对于单核cpu处理多任务,操作系统轮流让各个软件交替执行。 假如:软件1执行0.01秒，切换到软件2，软件2执行0.01秒，再切换到软件3，执行0.01秒……这样反复执行下去。 表面上看，每个软件都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像这些软件都在同时执行一样，这里需要注意单核cpu是并发的执行多任务的。并行 任务数 &lt; CPU核心数，对于多核cpu处理多任务，操作系统会给cpu的每个内核安排一个执行的软件，多个内核是真正的一起执行软件。 这里需要注意多核cpu是并行的执行多任务，始终有多个软件一起执行。并行才是多个任务真正意义一起执行。进程进程的概念一个正在运行的程序或者软件就是一个进程，它是操作系统进行资源分配的基本单位，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行。 比如:现实生活中的公司可以理解成是一个进程，公司提供办公资源(电脑、办公桌椅等)，真正干活的是员工，员工可以理解成线程。 一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程。 多进程的使用1.导入进程包 #导入进程包 import multiprocessing 2.Process 进程类的说明Process([group [, target [, name [, args [, kwargs]]]]]) group：指定进程组，目前只能使用 None target：执行的目标任务名 name：进程名字 args：以元组方式给执行任务传参 kwargs：以字典方式给执行任务传参 Process 创建的实例对象的常用方法: start()：启动子进程实例（创建子进程） join()：等待子进程执行结束 terminate()：不管任务是否完成，立即终止子进程 Process 创建的实例对象的步骤: 导入进程包 import multiprocessing 创建子进程并指定执行的任务 sub_process = multiprocessing.Process (target=任务名) 启动进程执行任务 sub_process.start() 多进程完成多任务的代码 import multiprocessing import time # 跳舞任务 def dance(): for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 唱歌任务 def sing(): for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果: 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 唱歌中... 跳舞中... 获取进程编号1.获取进程编号的目的 获取进程编号的目的是验证主进程和子进程的关系，可以得知子进程是由那个主进程创建出来的。 获取进程编号的两种操作 获取当前进程编号 获取当前父进程编号 获取当前进程编号方法 os.getpid() 获取当前父进程编号 os.getppid() 获取进程编号可以查看父子进程的关系 2.获取当前进程编号 os.getpid() 表示获取当前进程编号 示例代码: import multiprocessing import time import os # 跳舞任务 def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9) # 唱歌任务 def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果: main: 70763 main: &lt;_MainProcess(MainProcess, started)&gt; dance: 70768 dance: &lt;Process(myprocess1, started)&gt; 跳舞中... sing: 70769 sing: &lt;Process(Process-2, started)&gt; 唱歌中... 唱歌中... 唱歌中... 唱歌中... 唱歌中... **3.获取当前父进程编号 os.getppid() 表示获取当前父进程编号 示例代码: import multiprocessing import time import os # 跳舞任务 def dance(): # 获取当前进程的编号 print(&quot;dance:&quot;, os.getpid()) # 获取当前进程 print(&quot;dance:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;dance的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;跳舞中...&quot;) time.sleep(0.2) # 扩展:根据进程编号杀死指定进程 os.kill(os.getpid(), 9) # 唱歌任务 def sing(): # 获取当前进程的编号 print(&quot;sing:&quot;, os.getpid()) # 获取当前进程 print(&quot;sing:&quot;, multiprocessing.current_process()) # 获取父进程的编号 print(&quot;sing的父进程编号:&quot;, os.getppid()) for i in range(5): print(&quot;唱歌中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 获取当前进程的编号 print(&quot;main:&quot;, os.getpid()) # 获取当前进程 print(&quot;main:&quot;, multiprocessing.current_process()) # 创建跳舞的子进程 # group: 表示进程组，目前只能使用None # target: 表示执行的目标任务名(函数名、方法名) # name: 进程名称, 默认是Process-1, ..... dance_process = multiprocessing.Process(target=dance, name=&quot;myprocess1&quot;) sing_process = multiprocessing.Process(target=sing) # 启动子进程执行对应的任务 dance_process.start() sing_process.start() 执行结果： main: 70860 main: &lt;_MainProcess(MainProcess, started)&gt; dance: 70861 dance: &lt;Process(myprocess1, started)&gt; dance的父进程编号: 70860 跳舞中... sing: 70862 sing: &lt;Process(Process-2, started)&gt; sing的父进程编号: 70860 唱歌中... 唱歌中... 唱歌中... 唱歌中... 唱歌中... 进程执行带有参数的任务1. 进程执行带有参数的任务的介绍 前面使用进程执行的任务是没有参数的，假如我们使用进程执行的任务带有参数，如何给函数传参呢? Process 类执行任务并给任务传参数有两种方式: 元组方式传参(args): 元组方式传参一定要和参数的顺序保持一致。 字典方式传参(kwargs): 字典方式传参字典中的 key 一定要和参数名保持一致。 2. args 参数的使用 示例代码: import multiprocessing import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子进程 # args: 以元组的方式给任务传入参数 sub_process = multiprocessing.Process(target=task, args=(5,)) sub_process.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 3. kwargs 参数的使用 示例代码: import multiprocessing import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子进程 # kwargs: 表示以字典方式传入参数 sub_process = multiprocessing.Process(target=task, kwargs={&quot;count&quot;: 3}) sub_process.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 进程之间不共享全局变量创建子进程会对主进程资源进行拷贝，也就是说子进程是主进程的一个副本，好比是一对双胞胎，之所以进程之间不共享全局变量，是因为操作的不是同一个进程里面的全局变量，只不过不同进程里面的全局变量名字相同而已。 示例代码： import multiprocessing import time # 定义全局变量 g_list = list() # 添加数据的任务 def add_data(): for i in range(5): g_list.append(i) print(&quot;add:&quot;, i) time.sleep(0.2) # 代码执行到此，说明数据添加完成 print(&quot;add_data:&quot;, g_list) def read_data(): print(&quot;read_data&quot;, g_list) if __name__ == &#39;__main__&#39;: # 创建添加数据的子进程 add_data_process = multiprocessing.Process(target=add_data) # 创建读取数据的子进程 read_data_process = multiprocessing.Process(target=read_data) # 启动子进程执行对应的任务 add_data_process.start() # 主进程等待添加数据的子进程执行完成以后程序再继续往下执行，读取数据 add_data_process.join() read_data_process.start() print(&quot;main:&quot;, g_list) # 总结: 多进程之间不共享全局变量 执行结果: add: 0 add: 1 add: 2 add: 3 add: 4 add_data: [0, 1, 2, 3, 4] main: [] read_data [] 进程之间不共享全局变量的解释效果图: 主进程会等待所有的子进程执行结束再结束为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是主进程退出子进程销毁，不让主进程再等待子进程去执行。 设置守护主进程方式： 子进程对象.daemon = True 销毁子进程方式： 子进程对象.terminate() 假如我们现在创建一个子进程，这个子进程执行完大概需要 2 秒钟，现在让主进程执行 0.5 秒钟就退出程序，查看一下执行结果，示例代码如下: import multiprocessing import time # 定义进程所需要执行的任务 def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建子进程 sub_process = multiprocessing.Process(target=task) sub_process.start() # 主进程延时0.5秒钟 time.sleep(0.5) print(&quot;over&quot;) exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 执行结果: 任务执行中... 任务执行中... 任务执行中... over 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 任务执行中... 说明: 通过上面代码的执行结果，我们可以得知: 主进程会等待所有的子进程执行结束再结束 假如我们就让主进程执行 0.5 秒钟，子进程就销毁不再执行，那怎么办呢? 我们可以设置守护主进程 或者 在主进程退出之前 让子进程销毁 守护主进程: 守护主进程就是主进程退出子进程销毁不再执行 子进程销毁: 子进程执行结束 保证主进程正常退出的示例代码: import multiprocessing import time # 定义进程所需要执行的任务 def task(): for i in range(10): print(&quot;任务执行中...&quot;) time.sleep(0.2) if __name__ == &#39;__main__&#39;: # 创建子进程 sub_process = multiprocessing.Process(target=task) # 设置守护主进程，主进程退出子进程直接销毁，子进程的生命周期依赖与主进程 # sub_process.daemon = True sub_process.start() time.sleep(0.5) print(&quot;over&quot;) # 让子进程销毁 sub_process.terminate() exit() # 总结： 主进程会等待所有的子进程执行完成以后程序再退出 # 如果想要主进程退出子进程销毁，可以设置守护主进程或者在主进程退出之前让子进程销毁 执行结果: 任务执行中... 任务执行中... 任务执行中... over 线程线程的概念在 Python 中，想要实现多任务除了使用进程，还可以使用线程来完成，线程是实现多任务的另外一种方式。 线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要 cpu 进行调度 ，也就是说线程是 cpu 调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程。 多线程的使用1. 导入线程模块 #导入线程模块 import threading 2. 线程类 Thread 参数说明 Thread([group [, target [, name [, args [, kwargs]]]]]) group: 线程组，目前只能使用 None target: 执行的目标任务名 args: 以元组的方式给执行任务传参 kwargs: 以字典方式给执行任务传参 name: 线程名，一般不用设置 3. 启动线程 导入线程模块 import threading 创建子线程并指定执行的任务 sub_thread = threading.Thread(target=任务名) 启动线程执行任务 sub_thread.start() 示例代码： import threading import time # 唱歌任务 def sing(): # 扩展： 获取当前线程 # print(&quot;sing当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在唱歌...%d&quot; % i) time.sleep(1) # 跳舞任务 def dance(): # 扩展： 获取当前线程 # print(&quot;dance当前执行的线程为：&quot;, threading.current_thread()) for i in range(3): print(&quot;正在跳舞...%d&quot; % i) time.sleep(1) if __name__ == &#39;__main__&#39;: # 扩展： 获取当前线程 # print(&quot;当前执行的线程为：&quot;, threading.current_thread()) # 创建唱歌的线程 # target： 线程执行的函数名 sing_thread = threading.Thread(target=sing) # 创建跳舞的线程 dance_thread = threading.Thread(target=dance) # 开启线程 sing_thread.start() dance_thread.start() 执行结果： 正在唱歌...0 正在跳舞...0 正在唱歌...1 正在跳舞...1 正在唱歌...2 正在跳舞...2 线程执行带有参数的任务1. 线程执行带有参数的任务的介绍 前面使用线程执行的任务是没有参数的，假如我们使用线程执行的任务带有参数，如何给函数传参呢? Thread 类执行任务并给任务传参数有两种方式: 元组方式传参(args) ：元组方式传参一定要和参数的顺序保持一致。 字典方式传参(kwargs)：字典方式传参字典中的 key 一定要和参数名保持一致。 2. args 参数的使用 示例代码: import threading import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子线程 # args: 以元组的方式给任务传入参数 sub_thread = threading.Thread(target=task, args=(5,)) sub_thread.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 3. kwargs 参数的使用 示例代码: import threading import time # 带有参数的任务 def task(count): for i in range(count): print(&quot;任务执行中..&quot;) time.sleep(0.2) else: print(&quot;任务执行完成&quot;) if __name__ == &#39;__main__&#39;: # 创建子线程 # kwargs: 表示以字典方式传入参数 sub_thread = threading.Thread(target=task, kwargs={&quot;count&quot;: 3}) sub_thread.start() 执行结果: 任务执行中.. 任务执行中.. 任务执行中.. 任务执行完成 线程之间执行是无序的线程之间执行是无序的，它是由 cpu 调度决定的 ，cpu 调度哪个线程，哪个线程就先执行，没有调度的线程不能执行。 进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行。 示例代码： import threading import time def task(): time.sleep(1) print(&quot;当前线程:&quot;, threading.current_thread().name) if __name__ == &#39;__main__&#39;: for _ in range(5): sub_thread = threading.Thread(target=task) sub_thread.start() 运行结果： 当前线程: Thread-1 当前线程: Thread-2 当前线程: Thread-4 当前线程: Thread-5 当前线程: Thread-3 主线程会等待所有的子线程执行结束再结束主线程默认会等待所有子线程执行结束再结束，设置守护主线程的目的是主线程退出子线程销毁。 假如我们现在创建一个子线程，这个子线程执行完大概需要 2.5 秒钟，现在让主线程执行 1 秒钟就退出程序，查看一下执行结果，示例代码如下: import threading import time # 测试主线程是否会等待子线程执行完成以后程序再退出 def show_info(): for i in range(5): print(&quot;test:&quot;, i) time.sleep(0.5) if __name__ == &#39;__main__&#39;: sub_thread = threading.Thread(target=show_info) sub_thread.start() # 主线程延时1秒 time.sleep(1) print(&quot;over&quot;) 执行结果： test: 0 test: 1 over test: 2 test: 3 test: 4 说明: 通过上面代码的执行结果，我们可以得知: 主线程会等待所有的子线程执行结束再结束 假如我们就让主线程执行 1 秒钟，子线程就销毁不再执行，那怎么办呢? 我们可以设置守护主线程 守护主线程: 守护主线程就是主线程退出子线程销毁不再执行 设置守护主线程有两种方式： threading.Thread(target=show_info, daemon=True) 线程对象.setDaemon(True) 设置守护主线程的示例代码: import threading import time # 测试主线程是否会等待子线程执行完成以后程序再退出 def show_info(): for i in range(5): print(&quot;test:&quot;, i) time.sleep(0.5) if __name__ == &#39;__main__&#39;: # 创建子线程守护主线程 # daemon=True 守护主线程 # 守护主线程方式1 sub_thread = threading.Thread(target=show_info, daemon=True) # 设置成为守护主线程，主线程退出后子线程直接销毁不再执行子线程的代码 # 守护主线程方式2 # sub_thread.setDaemon(True) sub_thread.start() # 主线程延时1秒 time.sleep(1) print(&quot;over&quot;) 执行结果: test: 0 test: 1 over 线程之间共享全局变量线程之间共享全局变量，好处是可以对全局变量的数据进行共享。 需求: 定义一个列表类型的全局变量 创建两个子线程分别执行向全局变量添加数据的任务和向全局变量读取数据的任务 查看线程之间是否共享全局变量数据 import threading import time # 定义全局变量 my_list = list() # 写入数据任务 def write_data(): for i in range(5): my_list.append(i) time.sleep(0.1) print(&quot;write_data:&quot;, my_list) # 读取数据任务 def read_data(): print(&quot;read_data:&quot;, my_list) if __name__ == &#39;__main__&#39;: # 创建写入数据的线程 write_thread = threading.Thread(target=write_data) # 创建读取数据的线程 read_thread = threading.Thread(target=read_data) write_thread.start() # 延时 # time.sleep(1) # 主线程等待写入线程执行完成以后代码在继续往下执行 write_thread.join() print(&quot;开始读取数据啦&quot;) read_thread.start() 执行结果: write_data: [0, 1, 2, 3, 4] 开始读取数据啦 read_data: [0, 1, 2, 3, 4] 线程之间共享全局变量数据出现错误问题线程之间共享全局变量可能会导致数据出现错误问题，可以使用线程同步方式来解决这个问题。 需求: 定义两个函数，实现循环 100 万次，每循环一次给全局变量加 1 创建两个子线程执行对应的两个函数，查看计算后的结果 import threading # 定义全局变量 g_num = 0 # 循环一次给全局变量加1 def sum_num1(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 循环一次给全局变量加1 def sum_num2(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() # 启动线程 second_thread.start() 执行结果: sum1: 1210949 sum2: 1496035 注意点: 多线程同时对全局变量操作数据发生了错误 错误分析: 两个线程 first_thread 和 second_thread 都要对全局变量 g_num(默认是 0)进行加 1 运算，但是由于是多线程同时操作，有可能出现下面情况： 在 g_num=0 时，first_thread 取得 g_num=0。此时系统把 first_thread 调度为”sleeping”状态，把 second_thread 转换为”running”状态，t2 也获得 g_num=0 然后 second_thread 对得到的值进行加 1 并赋给 g_num，使得 g_num=1 然后系统又把 second_thread 调度为”sleeping”，把 first_thread 转为”running”。线程 t1 又把它之前得到的 0 加 1 后赋值给 g_num。 这样导致虽然 first_thread 和 first_thread 都对 g_num 加 1，但结果仍然是 g_num=1 全局变量数据错误的解决办法: 线程同步: 保证同一时刻只能有一个线程去操作全局变量 同步: 就是协同步调，按预定的先后次序进行运行。如:你说完，我再说, 好比现实生活中的对讲机 线程同步的方式: 线程等待(join) 互斥锁 线程等待的示例代码: import threading # 定义全局变量 g_num = 0 # 循环1000000次每次给全局变量加1 def sum_num1(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 循环1000000次每次给全局变量加1 def sum_num2(): for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() # 主线程等待第一个线程执行完成以后代码再继续执行，让其执行第二个线程 # 线程同步： 一个任务执行完成以后另外一个任务才能执行，同一个时刻只有一个任务在执行 first_thread.join() # 启动线程 second_thread.start() 执行结果: sum1: 1000000 sum2: 2000000 互斥锁与死锁互斥锁的概念互斥锁: 对共享数据进行锁定，保证同一时刻只能有一个线程去操作。 互斥锁的作用就是保证同一时刻只能有一个线程去操作共享数据，保证共享数据不会出现错误问题 使用互斥锁的好处确保某段关键代码只能由一个线程从头到尾完整地去执行 使用互斥锁会影响代码的执行效率，多任务改成了单任务执行 互斥锁如果没有使用好容易出现死锁的情况 注意: 互斥锁是多个线程一起去抢，抢到锁的线程先执行，没有抢到锁的线程需要等待，等互斥锁使用完释放后，其它等待的线程再去抢这个锁。 互斥锁的使用threading 模块中定义了 Lock 变量，这个变量本质上是一个函数，通过调用这个函数可以获取一把互斥锁。 互斥锁使用步骤: # 创建锁 mutex = threading.Lock() # 上锁 mutex.acquire() ...这里编写代码能保证同一时刻只能有一个线程去操作, 对共享数据进行锁定... # 释放锁 mutex.release() 注意点: acquire 和 release 方法之间的代码同一时刻只能有一个线程去操作 如果在调用 acquire 方法的时候 其他线程已经使用了这个互斥锁，那么此时 acquire 方法会堵塞，直到这个互斥锁释放后才能再次上锁。 互斥锁示例使用互斥锁完成 2 个线程对同一个全局变量各加 100 万次的操作 import threading # 定义全局变量 g_num = 0 # 创建全局互斥锁 lock = threading.Lock() # 循环一次给全局变量加1 def sum_num1(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum1:&quot;, g_num) # 释放锁 lock.release() # 循环一次给全局变量加1 def sum_num2(): # 上锁 lock.acquire() for i in range(1000000): global g_num g_num += 1 print(&quot;sum2:&quot;, g_num) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 创建两个线程 first_thread = threading.Thread(target=sum_num1) second_thread = threading.Thread(target=sum_num2) # 启动线程 first_thread.start() second_thread.start() # 提示：加上互斥锁，那个线程抢到这个锁我们决定不了，那线程抢到锁那个线程先执行，没有抢到的线程需要等待 # 加上互斥锁多任务瞬间变成单任务，性能会下降，也就是说同一时刻只能有一个线程去执行 执行结果: sum1: 1000000 sum2: 2000000 说明: 通过执行结果可以地址互斥锁能够保证多个线程访问共享数据不会出现数据错误问题 死锁的概念死锁: 一直等待对方释放锁的情景就是死锁 使用互斥锁的时候需要注意死锁的问题，要在合适的地方注意释放锁。 死锁一旦产生就会造成应用程序的停止响应，应用程序无法再继续往下执行了。 死锁的结果 会造成应用程序的停止响应，不能再处理其它任务了。 死锁示例 需求: 根据下标在列表中取值, 保证同一时刻只能有一个线程去取值 import threading import time # 创建互斥锁 lock = threading.Lock() # 根据下标去取值， 保证同一时刻只能有一个线程去取值 def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] # 判断下标释放越界 if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 避免死锁 在合适的地方释放锁 import threading import time # 创建互斥锁 lock = threading.Lock() # 根据下标去取值， 保证同一时刻只能有一个线程去取值 def get_value(index): # 上锁 lock.acquire() print(threading.current_thread()) my_list = [3,6,8,1] if index &gt;= len(my_list): print(&quot;下标越界:&quot;, index) # 当下标越界需要释放锁，让后面的线程还可以取值 lock.release() return value = my_list[index] print(value) time.sleep(0.2) # 释放锁 lock.release() if __name__ == &#39;__main__&#39;: # 模拟大量线程去执行取值操作 for i in range(30): sub_thread = threading.Thread(target=get_value, args=(i,)) sub_thread.start() 进程和线程的对比关系对比 线程是依附在进程里面的，没有进程就没有线程。 一个进程默认提供一条线程，进程可以创建多个线程。 区别对比 进程之间不共享全局变量 线程之间共享全局变量，但是要注意资源竞争的问题，解决办法: 互斥锁或者线程同步 创建进程的资源开销要比创建线程的资源开销要大 进程是操作系统资源分配的基本单位，线程是 CPU 调度的基本单位 线程不能够独立执行，必须依存在进程中 多进程开发比单进程多线程开发稳定性要强 优缺点对比 进程优缺点: 优点：可以用多核 缺点：资源开销大 线程优缺点: 优点：资源开销小 缺点：不能使用多核 小结 进程和线程都是完成多任务的一种方式 多进程要比多线程消耗的资源多，但是多进程开发比单进程多线程开发稳定性要强，某个进程挂掉不会影响其它进程。 多进程可以使用 cpu 的多核运行，多线程可以共享全局变量。 线程不能单独执行必须依附在进程里面 计算密集型的应用使用多进程，有效利用多核提升运算效率；其他应用（文件写入、文件下载、IO 操作）使用多线程，更加节省资源并且可以完成多任务。","tags":[{"name":"Python","slug":"Python","permalink":"https://www.flaglee.cn/tags/Python/"},{"name":"多任务","slug":"多任务","permalink":"https://www.flaglee.cn/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/"},{"name":"进程","slug":"进程","permalink":"https://www.flaglee.cn/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"线程","slug":"线程","permalink":"https://www.flaglee.cn/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"使用QT编译RTKLIB的GUI程序","date":"2020-08-10T09:26:54.000Z","path":"2020/08/10/使用QT编译RTKLIB-GUI程序/","text":"近期在基于 RTKLIB 改了一些代码，但一直是基于源码运行的，于是便想着编译一个自己的图形用户界面。查阅 manual 2.4.2 手册上使用的是 Embarcadero C++ Builder XE2 or XE3，上网查了一下实在是太古老，无奈放弃。之后使用 QT 编译成功，写下这篇博客记录一下方法和注意事项。 所用版本这篇博客基于的是 demo5 源码版本，链接见http://rtkexplorer.com/downloads/rtklib-code/。QT 使用的是 5.14.2，国内镜像链接见https://mirrors.tuna.tsinghua.edu.cn/qt/archive/qt/5.14/5.14.2/。本文只针对以上版本记录编译过程中遇到的问题。其实版本之间大同小异，博主之前也用别的版本编译成功过，希望大家举一反三。 编译流程首先使用 QT creator 打开源码根目录下的.pro 文件，创建工程。 这里使用的是 MinGW 32 位，注意区分。 以 rtkpost 软件为例，选择 Release 构建下的 rtkpost_qt。 按绿色三角或 Ctrl+R 开始运行。 问题 1第一个问题发现提示 :-1: error: No rule to make target ‘rcv/ss2.c’, needed by ‘release/ss2.o’. Stop. 这个问题是由于之前的代码中有这个文件，而最新的版本已经去掉，我们可以在 src.pro 中找到这一条将其注释掉。 重新运行程序。 问题 2发现提示 :-1: error: No rule to make target ‘../../src/debug/libRTKLib.a’, needed by ‘release/rtknavi_qt.exe’. Stop. 这是因为缺少库文件 libRTKLib.a，这个文件就是我们源代码生成的库文件，当你改了源码之后，这个也会随之改变，所以千万不要乱用。这个文件可以在 Debug 模式下生成，我们切到 Debug 模式下重新运行。 问题 3发现一连串报错 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\RTKLIB-demo5..\\RTKLIB-demo5\\app\\rtkconv_qt\\codeopt.cpp:333: error: ‘FREQTYPE_L7’ was not declared in this scope E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); 这是由于 demo5 版本在头文件改了一些配置，源码编译文件改了，但是 qt 编译文件还没有改，我们可以找到 app&gt;rtkconv&gt;codeopt.cpp 查看它是怎么使用的，我们 rtkconv_qt&gt;codeopt.cpp 只要随之改变就好 E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L8)); 改为 E27-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E28-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E29-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); E30-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E31-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E32-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E33-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E34-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); E37-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); E38-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); E39-&gt;setEnabled((NavSys&amp;SYS_GAL)&amp;&amp;(FreqType&amp;FREQTYPE_E5ab)); J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); 改为 J35-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); J36-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); J33-&gt;setEnabled((NavSys&amp;SYS_QZS)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L7)); C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L6)); 改为 C27-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C28-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C29-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L2)); C42-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C43-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); C33-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_E6)); I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_L9)); 改为 I52-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I53-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I54-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); I55-&gt;setEnabled((NavSys&amp;SYS_CMP)&amp;&amp;(FreqType&amp;FREQTYPE_S)); 同样 convopt.cpp 下也有这个问题，也采用上面的方法改完，重新运行。编译成功，我们已经可以看到 Debug 模式下的程序界面。 之后我们在 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Debug\\src\\debug 路径下找到我们编译的 libRTKLib.a 将其复制到 D:\\Document\\RTK\\RTKLIB-demo5_for_QT\\build-RTKLib-Desktop_Qt_5_14_2_MinGW_32_bit-Release\\src\\debug 且回到 Release 模式，重新运行，即可成功。 程序打包这样直接生成的程序是不能直接运行的，需要进行打包。打开 Qt 版本号 for Desktop (MinGW 版本号 32bit)命令行，注意与一开始选择的对应。 接着输入命令行，cd /d 路径(指的是需要打包的 exe 程序目录，就是刚才拷贝出来的 exe 程序所在的目录)，回车后， 输入如下命令行：windeployqt 程序名 敲击回车。这一步操作是将所需的库文件全都拷贝到 exe 程序的当前文件。 现在，便可以双击 exe 直接运行软件了！ 若你要将程序给别人使用，一定要注意 dll 文件也要一起打包哦。","tags":[{"name":"GNSS","slug":"GNSS","permalink":"https://www.flaglee.cn/tags/GNSS/"},{"name":"RTKlib","slug":"RTKlib","permalink":"https://www.flaglee.cn/tags/RTKlib/"},{"name":"RTK","slug":"RTK","permalink":"https://www.flaglee.cn/tags/RTK/"},{"name":"QT","slug":"QT","permalink":"https://www.flaglee.cn/tags/QT/"}]},{"title":"RTKlib源码解析-高精度GNSS定位处理过程","date":"2020-07-15T14:17:30.000Z","path":"2020/07/15/RTKlib-关于高精度GPS动态定位处理过程/","text":"RTKLIB 是用于 GNSS（全球导航卫星系统）的标准和精确定位的开源程序包。二进制文件以及完整原始代码见RTKlib.com。Demo5 是 RTKLIB 代码的修改版本，针对低成本的单频和双频接收器而定制，旨在提高性能。二进制文件以及完整原始代码见http://rtkexplorer.com/downloads/rtklib-code/。 本文主要介绍用 RTKLIB 实现精密动态定位的过程，该过程包括观测文件和导航文件的读取、基准站位置的计算、流动站位置的求解、运行结果的输出。 主函数配置解算流程文件读取求解基站参数相对动态定位","tags":[{"name":"GNSS","slug":"GNSS","permalink":"https://www.flaglee.cn/tags/GNSS/"},{"name":"GPS","slug":"GPS","permalink":"https://www.flaglee.cn/tags/GPS/"},{"name":"BDS","slug":"BDS","permalink":"https://www.flaglee.cn/tags/BDS/"},{"name":"RTKlib","slug":"RTKlib","permalink":"https://www.flaglee.cn/tags/RTKlib/"},{"name":"RTK","slug":"RTK","permalink":"https://www.flaglee.cn/tags/RTK/"}]},{"title":"Markdown语法汇总","date":"2020-05-26T02:58:53.000Z","path":"2020/05/26/Markdown语法汇总/","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息，例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等。 Markdown 标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加#+space号即可。使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 Markdown 段落段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 字体Markdown 可以使用以下几种字体： _斜体文本_ _斜体文本_ **粗体文本** **粗体文本** **_粗斜体文本_** **_粗斜体文本_** 斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 分割线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： --- --- --- --- --- 删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： GOOGLE.COM ~~BAIDU.COM~~ GOOGLE.COMBAIDU.COM 下划线下划线可以通过 HTML 标签来实现： &lt;u&gt;带下划线文本&lt;/u&gt; 带下划线文本 Markdown 列表Markdown 支持有序列表和无序列表。 无序列表无序列表使用星号*、加号+或是减号-作为列表标记，这些标记后面要添加一个space，然后再填写内容： - 第一项 - 第二项 - 第三项 * 第一项 * 第二项 * 第三项 - 第一项 - 第二项 - 第三项 第一项 第二项 第三项 有序列表有序列表使用数字并加上space. 号来表示，如： 1. 第一项 2. 第二项 3. 第三项 第一项 第二项 第三项 Markdown 区块Markdown 区块引用是在段落开头使用 >符号 ，然后后面紧跟一个space符号： &gt; 区块引用 区块引用 Markdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来`，例如： `printf()` 函数 printf() 函数代码区块使用 4 个空格或者一个制表符Tab。也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定） Markdown 链接链接使用方法如下： [链接名称](链接地址) 或者 &lt;链接地址&gt; [FLAG&#39;s blog](www.flaglee.cn) FLAG’s blog 高级链接可以通过变量来设置一个链接，变量赋值在文档末尾进行： 这个链接用 1 作为网址变量 [Google][1] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ Markdown 图片Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) ![Markdown](https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png &quot;markdown图标&quot;) Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ------ | ------ | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 对齐方式 可以设置表格的对齐方式： -: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。 | 左对齐 | 右对齐 | 居中对齐 | | :----- | -----: | :------: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 Markdown 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等，如： 使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 使用 Ctrl+Alt+Del 重启电脑 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： **文本加粗** \\*\\* 正常显示星号 \\*\\* 文本加粗** 正常显示星号 ** 公式当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。","tags":[{"name":"blog","slug":"blog","permalink":"https://www.flaglee.cn/tags/blog/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.flaglee.cn/tags/Markdown/"}]},{"title":"Hello World","date":"2020-05-26T02:53:03.254Z","path":"2020/05/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.flaglee.cn/tags/Hexo/"},{"name":"blog","slug":"blog","permalink":"https://www.flaglee.cn/tags/blog/"}]}]